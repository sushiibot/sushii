import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { DocumentNode } from 'graphql';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: string;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { [key: string]: any };
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
};

/** All input for the `addRoleMenuRoles` mutation. */
export type AddRoleMenuRolesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
  roleIds?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
};

/** The output of our `addRoleMenuRoles` mutation. */
export type AddRoleMenuRolesPayload = {
  __typename?: 'AddRoleMenuRolesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  roleMenuRoles?: Maybe<Array<RoleMenuRole>>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']>>;
};

/** A filter to be used against BigInt List fields. All fields are combined with a logical ‘and.’ */
export type BigIntListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['BigInt']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['BigInt']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['BigInt']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
};

export enum BlockType {
  Channel = 'CHANNEL',
  Role = 'ROLE'
}

/** A filter to be used against BlockType fields. All fields are combined with a logical ‘and.’ */
export type BlockTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<BlockType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<BlockType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<BlockType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<BlockType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<BlockType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<BlockType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<BlockType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<BlockType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<BlockType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<BlockType>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type BotStat = Node & {
  __typename?: 'BotStat';
  category: Scalars['String'];
  count: Scalars['BigInt'];
  createdAt: Scalars['Datetime'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  updatedAt: Scalars['Datetime'];
};

export type BotStatAggregates = {
  __typename?: 'BotStatAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BotStatAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BotStatDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BotStatMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BotStatMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BotStatStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BotStatStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BotStatSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BotStatVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BotStatVarianceSampleAggregates>;
};

export type BotStatAverageAggregates = {
  __typename?: 'BotStatAverageAggregates';
  /** Mean average of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `BotStat` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type BotStatCondition = {
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `count` field. */
  count?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type BotStatDistinctCountAggregates = {
  __typename?: 'BotStatDistinctCountAggregates';
  /** Distinct count of category across the matching connection */
  category?: Maybe<Scalars['BigInt']>;
  /** Distinct count of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
  /** Distinct count of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of name across the matching connection */
  name?: Maybe<Scalars['BigInt']>;
  /** Distinct count of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `BotStat` object types. All fields are combined with a logical ‘and.’ */
export type BotStatFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BotStatFilter>>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `count` field. */
  count?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BotStatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BotStatFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `BotStat` */
export type BotStatInput = {
  category: Scalars['String'];
  count: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type BotStatMaxAggregates = {
  __typename?: 'BotStatMaxAggregates';
  /** Maximum of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
};

export type BotStatMinAggregates = {
  __typename?: 'BotStatMinAggregates';
  /** Minimum of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `BotStat`. Fields that are set will be updated. */
export type BotStatPatch = {
  category?: InputMaybe<Scalars['String']>;
  count?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type BotStatStddevPopulationAggregates = {
  __typename?: 'BotStatStddevPopulationAggregates';
  /** Population standard deviation of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
};

export type BotStatStddevSampleAggregates = {
  __typename?: 'BotStatStddevSampleAggregates';
  /** Sample standard deviation of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
};

export type BotStatSumAggregates = {
  __typename?: 'BotStatSumAggregates';
  /** Sum of count across the matching connection */
  count: Scalars['BigFloat'];
};

export type BotStatVariancePopulationAggregates = {
  __typename?: 'BotStatVariancePopulationAggregates';
  /** Population variance of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
};

export type BotStatVarianceSampleAggregates = {
  __typename?: 'BotStatVarianceSampleAggregates';
  /** Sample variance of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `BotStat` values. */
export type BotStatsConnection = {
  __typename?: 'BotStatsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BotStatAggregates>;
  /** A list of edges which contains the `BotStat` and cursor to aid in pagination. */
  edges: Array<BotStatsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BotStatAggregates>>;
  /** A list of `BotStat` objects. */
  nodes: Array<BotStat>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BotStat` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `BotStat` values. */
export type BotStatsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BotStatsGroupBy>;
  having?: InputMaybe<BotStatsHavingInput>;
};

/** A `BotStat` edge in the connection. */
export type BotStatsEdge = {
  __typename?: 'BotStatsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BotStat` at the end of the edge. */
  node: BotStat;
};

/** Grouping methods for `BotStat` for usage during aggregation. */
export enum BotStatsGroupBy {
  Category = 'CATEGORY',
  Count = 'COUNT',
  CreatedAt = 'CREATED_AT',
  CreatedAtTruncatedToDay = 'CREATED_AT_TRUNCATED_TO_DAY',
  CreatedAtTruncatedToHour = 'CREATED_AT_TRUNCATED_TO_HOUR',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT',
  UpdatedAtTruncatedToDay = 'UPDATED_AT_TRUNCATED_TO_DAY',
  UpdatedAtTruncatedToHour = 'UPDATED_AT_TRUNCATED_TO_HOUR'
}

export type BotStatsHavingAverageInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingDistinctCountInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `BotStat` aggregates. */
export type BotStatsHavingInput = {
  AND?: InputMaybe<Array<BotStatsHavingInput>>;
  OR?: InputMaybe<Array<BotStatsHavingInput>>;
  average?: InputMaybe<BotStatsHavingAverageInput>;
  distinctCount?: InputMaybe<BotStatsHavingDistinctCountInput>;
  max?: InputMaybe<BotStatsHavingMaxInput>;
  min?: InputMaybe<BotStatsHavingMinInput>;
  stddevPopulation?: InputMaybe<BotStatsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BotStatsHavingStddevSampleInput>;
  sum?: InputMaybe<BotStatsHavingSumInput>;
  variancePopulation?: InputMaybe<BotStatsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BotStatsHavingVarianceSampleInput>;
};

export type BotStatsHavingMaxInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingMinInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingStddevPopulationInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingStddevSampleInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingSumInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingVariancePopulationInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type BotStatsHavingVarianceSampleInput = {
  count?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Methods to use when ordering `BotStat`. */
export enum BotStatsOrderBy {
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** All input for the `bulkDeleteModLog` mutation. */
export type BulkDeleteModLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  endCaseId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  startCaseId: Scalars['BigInt'];
};

/** The output of our `bulkDeleteModLog` mutation. */
export type BulkDeleteModLogPayload = {
  __typename?: 'BulkDeleteModLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  modLogs?: Maybe<Array<ModLog>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `bulkUpdateModLogReason` mutation. */
export type BulkUpdateModLogReasonInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  endCaseId: Scalars['BigInt'];
  executorId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  onlyEmptyReason?: InputMaybe<Scalars['Boolean']>;
  reason: Scalars['String'];
  startCaseId: Scalars['BigInt'];
};

/** The output of our `bulkUpdateModLogReason` mutation. */
export type BulkUpdateModLogReasonPayload = {
  __typename?: 'BulkUpdateModLogReasonPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  modLogs?: Maybe<Array<ModLog>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type CachedGuild = Node & {
  __typename?: 'CachedGuild';
  banner?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  features: Array<Maybe<Scalars['String']>>;
  /** Reads a single `GuildConfig` that is related to this `CachedGuild`. */
  guildConfigById?: Maybe<GuildConfig>;
  icon?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  splash?: Maybe<Scalars['String']>;
  updatedAt: Scalars['Datetime'];
  /** Reads and enables pagination through a set of `WebUserGuild`. */
  webUserGuildsByGuildId: WebUserGuildsConnection;
};


export type CachedGuildWebUserGuildsByGuildIdArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<WebUserGuildCondition>;
  filter?: InputMaybe<WebUserGuildFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

/** An input for mutations affecting `CachedGuild` */
export type CachedGuildInput = {
  banner?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  features?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  icon?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  name: Scalars['String'];
  splash?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** Represents an update to a `CachedGuild`. Fields that are set will be updated. */
export type CachedGuildPatch = {
  banner?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  features?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  icon?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  splash?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A `CachedGuild` edge in the connection. */
export type CachedGuildsEdge = {
  __typename?: 'CachedGuildsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CachedGuild` at the end of the edge. */
  node: CachedGuild;
};

/** Methods to use when ordering `CachedGuild`. */
export enum CachedGuildsOrderBy {
  BannerAsc = 'BANNER_ASC',
  BannerDesc = 'BANNER_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  FeaturesAsc = 'FEATURES_ASC',
  FeaturesDesc = 'FEATURES_DESC',
  IconAsc = 'ICON_ASC',
  IconDesc = 'ICON_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SplashAsc = 'SPLASH_ASC',
  SplashDesc = 'SPLASH_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  WebUserGuildsByGuildIdAverageGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_GUILD_ID_ASC',
  WebUserGuildsByGuildIdAverageGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_GUILD_ID_DESC',
  WebUserGuildsByGuildIdAverageManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdAverageManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdAverageOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_OWNER_ASC',
  WebUserGuildsByGuildIdAverageOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_OWNER_DESC',
  WebUserGuildsByGuildIdAveragePermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdAveragePermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdAverageUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_USER_ID_ASC',
  WebUserGuildsByGuildIdAverageUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_AVERAGE_USER_ID_DESC',
  WebUserGuildsByGuildIdCountAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_COUNT_ASC',
  WebUserGuildsByGuildIdCountDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_COUNT_DESC',
  WebUserGuildsByGuildIdDistinctCountGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_GUILD_ID_ASC',
  WebUserGuildsByGuildIdDistinctCountGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_GUILD_ID_DESC',
  WebUserGuildsByGuildIdDistinctCountManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdDistinctCountManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdDistinctCountOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_OWNER_ASC',
  WebUserGuildsByGuildIdDistinctCountOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_OWNER_DESC',
  WebUserGuildsByGuildIdDistinctCountPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdDistinctCountPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdDistinctCountUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_USER_ID_ASC',
  WebUserGuildsByGuildIdDistinctCountUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_DISTINCT_COUNT_USER_ID_DESC',
  WebUserGuildsByGuildIdMaxGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_GUILD_ID_ASC',
  WebUserGuildsByGuildIdMaxGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_GUILD_ID_DESC',
  WebUserGuildsByGuildIdMaxManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdMaxManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdMaxOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_OWNER_ASC',
  WebUserGuildsByGuildIdMaxOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_OWNER_DESC',
  WebUserGuildsByGuildIdMaxPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdMaxPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdMaxUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_USER_ID_ASC',
  WebUserGuildsByGuildIdMaxUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MAX_USER_ID_DESC',
  WebUserGuildsByGuildIdMinGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_GUILD_ID_ASC',
  WebUserGuildsByGuildIdMinGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_GUILD_ID_DESC',
  WebUserGuildsByGuildIdMinManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdMinManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdMinOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_OWNER_ASC',
  WebUserGuildsByGuildIdMinOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_OWNER_DESC',
  WebUserGuildsByGuildIdMinPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdMinPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdMinUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_USER_ID_ASC',
  WebUserGuildsByGuildIdMinUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_MIN_USER_ID_DESC',
  WebUserGuildsByGuildIdStddevPopulationGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_GUILD_ID_ASC',
  WebUserGuildsByGuildIdStddevPopulationGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_GUILD_ID_DESC',
  WebUserGuildsByGuildIdStddevPopulationManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdStddevPopulationManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdStddevPopulationOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_OWNER_ASC',
  WebUserGuildsByGuildIdStddevPopulationOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_OWNER_DESC',
  WebUserGuildsByGuildIdStddevPopulationPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdStddevPopulationPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdStddevPopulationUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_USER_ID_ASC',
  WebUserGuildsByGuildIdStddevPopulationUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_POPULATION_USER_ID_DESC',
  WebUserGuildsByGuildIdStddevSampleGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_GUILD_ID_ASC',
  WebUserGuildsByGuildIdStddevSampleGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_GUILD_ID_DESC',
  WebUserGuildsByGuildIdStddevSampleManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdStddevSampleManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdStddevSampleOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_OWNER_ASC',
  WebUserGuildsByGuildIdStddevSampleOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_OWNER_DESC',
  WebUserGuildsByGuildIdStddevSamplePermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdStddevSamplePermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdStddevSampleUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_USER_ID_ASC',
  WebUserGuildsByGuildIdStddevSampleUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_STDDEV_SAMPLE_USER_ID_DESC',
  WebUserGuildsByGuildIdSumGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_GUILD_ID_ASC',
  WebUserGuildsByGuildIdSumGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_GUILD_ID_DESC',
  WebUserGuildsByGuildIdSumManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdSumManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdSumOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_OWNER_ASC',
  WebUserGuildsByGuildIdSumOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_OWNER_DESC',
  WebUserGuildsByGuildIdSumPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdSumPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdSumUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_USER_ID_ASC',
  WebUserGuildsByGuildIdSumUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_SUM_USER_ID_DESC',
  WebUserGuildsByGuildIdVariancePopulationGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_GUILD_ID_ASC',
  WebUserGuildsByGuildIdVariancePopulationGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_GUILD_ID_DESC',
  WebUserGuildsByGuildIdVariancePopulationManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdVariancePopulationManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdVariancePopulationOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_OWNER_ASC',
  WebUserGuildsByGuildIdVariancePopulationOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_OWNER_DESC',
  WebUserGuildsByGuildIdVariancePopulationPermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdVariancePopulationPermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdVariancePopulationUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_USER_ID_ASC',
  WebUserGuildsByGuildIdVariancePopulationUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_POPULATION_USER_ID_DESC',
  WebUserGuildsByGuildIdVarianceSampleGuildIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_GUILD_ID_ASC',
  WebUserGuildsByGuildIdVarianceSampleGuildIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_GUILD_ID_DESC',
  WebUserGuildsByGuildIdVarianceSampleManageGuildAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_MANAGE_GUILD_ASC',
  WebUserGuildsByGuildIdVarianceSampleManageGuildDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_MANAGE_GUILD_DESC',
  WebUserGuildsByGuildIdVarianceSampleOwnerAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_OWNER_ASC',
  WebUserGuildsByGuildIdVarianceSampleOwnerDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_OWNER_DESC',
  WebUserGuildsByGuildIdVarianceSamplePermissionsAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_PERMISSIONS_ASC',
  WebUserGuildsByGuildIdVarianceSamplePermissionsDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_PERMISSIONS_DESC',
  WebUserGuildsByGuildIdVarianceSampleUserIdAsc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_USER_ID_ASC',
  WebUserGuildsByGuildIdVarianceSampleUserIdDesc = 'WEB_USER_GUILDS_BY_GUILD_ID_VARIANCE_SAMPLE_USER_ID_DESC'
}

export type CachedUser = Node & {
  __typename?: 'CachedUser';
  avatarUrl: Scalars['String'];
  discriminator: Scalars['Int'];
  id: Scalars['BigInt'];
  lastChecked: Scalars['Datetime'];
  name: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** An input for mutations affecting `CachedUser` */
export type CachedUserInput = {
  avatarUrl: Scalars['String'];
  discriminator: Scalars['Int'];
  id: Scalars['BigInt'];
  lastChecked: Scalars['Datetime'];
  name: Scalars['String'];
};

/** Represents an update to a `CachedUser`. Fields that are set will be updated. */
export type CachedUserPatch = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  discriminator?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['BigInt']>;
  lastChecked?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
};

/** A `CachedUser` edge in the connection. */
export type CachedUsersEdge = {
  __typename?: 'CachedUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CachedUser` at the end of the edge. */
  node: CachedUser;
};

/** Methods to use when ordering `CachedUser`. */
export enum CachedUsersOrderBy {
  AvatarUrlAsc = 'AVATAR_URL_ASC',
  AvatarUrlDesc = 'AVATAR_URL_DESC',
  DiscriminatorAsc = 'DISCRIMINATOR_ASC',
  DiscriminatorDesc = 'DISCRIMINATOR_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastCheckedAsc = 'LAST_CHECKED_ASC',
  LastCheckedDesc = 'LAST_CHECKED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the create `BotStat` mutation. */
export type CreateBotStatInput = {
  /** The `BotStat` to be created by this mutation. */
  botStat: BotStatInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `BotStat` mutation. */
export type CreateBotStatPayload = {
  __typename?: 'CreateBotStatPayload';
  /** The `BotStat` that was created by this mutation. */
  botStat?: Maybe<BotStat>;
  /** An edge for our `BotStat`. May be used by Relay 1. */
  botStatEdge?: Maybe<BotStatsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `BotStat` mutation. */
export type CreateBotStatPayloadBotStatEdgeArgs = {
  orderBy?: InputMaybe<Array<BotStatsOrderBy>>;
};

/** All input for the create `CachedGuild` mutation. */
export type CreateCachedGuildInput = {
  /** The `CachedGuild` to be created by this mutation. */
  cachedGuild: CachedGuildInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CachedGuild` mutation. */
export type CreateCachedGuildPayload = {
  __typename?: 'CreateCachedGuildPayload';
  /** The `CachedGuild` that was created by this mutation. */
  cachedGuild?: Maybe<CachedGuild>;
  /** An edge for our `CachedGuild`. May be used by Relay 1. */
  cachedGuildEdge?: Maybe<CachedGuildsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CachedGuild` mutation. */
export type CreateCachedGuildPayloadCachedGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedGuildsOrderBy>>;
};

/** All input for the create `CachedUser` mutation. */
export type CreateCachedUserInput = {
  /** The `CachedUser` to be created by this mutation. */
  cachedUser: CachedUserInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CachedUser` mutation. */
export type CreateCachedUserPayload = {
  __typename?: 'CreateCachedUserPayload';
  /** The `CachedUser` that was created by this mutation. */
  cachedUser?: Maybe<CachedUser>;
  /** An edge for our `CachedUser`. May be used by Relay 1. */
  cachedUserEdge?: Maybe<CachedUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CachedUser` mutation. */
export type CreateCachedUserPayloadCachedUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedUsersOrderBy>>;
};

/** All input for the create `EmojiStickerStat` mutation. */
export type CreateEmojiStickerStatInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `EmojiStickerStat` to be created by this mutation. */
  emojiStickerStat: EmojiStickerStatInput;
};

/** The output of our create `EmojiStickerStat` mutation. */
export type CreateEmojiStickerStatPayload = {
  __typename?: 'CreateEmojiStickerStatPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EmojiStickerStat` that was created by this mutation. */
  emojiStickerStat?: Maybe<EmojiStickerStat>;
  /** An edge for our `EmojiStickerStat`. May be used by Relay 1. */
  emojiStickerStatEdge?: Maybe<EmojiStickerStatsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `EmojiStickerStat` mutation. */
export type CreateEmojiStickerStatPayloadEmojiStickerStatEdgeArgs = {
  orderBy?: InputMaybe<Array<EmojiStickerStatsOrderBy>>;
};

/** All input for the create `Feed` mutation. */
export type CreateFeedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Feed` to be created by this mutation. */
  feed: FeedInput;
};

/** All input for the create `FeedItem` mutation. */
export type CreateFeedItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `FeedItem` to be created by this mutation. */
  feedItem: FeedItemInput;
};

/** The output of our create `FeedItem` mutation. */
export type CreateFeedItemPayload = {
  __typename?: 'CreateFeedItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FeedItem` that was created by this mutation. */
  feedItem?: Maybe<FeedItem>;
  /** An edge for our `FeedItem`. May be used by Relay 1. */
  feedItemEdge?: Maybe<FeedItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FeedItem` mutation. */
export type CreateFeedItemPayloadFeedItemEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedItemsOrderBy>>;
};

/** The output of our create `Feed` mutation. */
export type CreateFeedPayload = {
  __typename?: 'CreateFeedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feed` that was created by this mutation. */
  feed?: Maybe<Feed>;
  /** An edge for our `Feed`. May be used by Relay 1. */
  feedEdge?: Maybe<FeedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Feed` mutation. */
export type CreateFeedPayloadFeedEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedsOrderBy>>;
};

/** All input for the create `FeedSubscription` mutation. */
export type CreateFeedSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `FeedSubscription` to be created by this mutation. */
  feedSubscription: FeedSubscriptionInput;
};

/** The output of our create `FeedSubscription` mutation. */
export type CreateFeedSubscriptionPayload = {
  __typename?: 'CreateFeedSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Feed` that is related to this `FeedSubscription`. */
  feedByFeedId?: Maybe<Feed>;
  /** The `FeedSubscription` that was created by this mutation. */
  feedSubscription?: Maybe<FeedSubscription>;
  /** An edge for our `FeedSubscription`. May be used by Relay 1. */
  feedSubscriptionEdge?: Maybe<FeedSubscriptionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FeedSubscription` mutation. */
export type CreateFeedSubscriptionPayloadFeedSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};

/** All input for the create `GuildBan` mutation. */
export type CreateGuildBanInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GuildBan` to be created by this mutation. */
  guildBan: GuildBanInput;
};

/** The output of our create `GuildBan` mutation. */
export type CreateGuildBanPayload = {
  __typename?: 'CreateGuildBanPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildBan` that was created by this mutation. */
  guildBan?: Maybe<GuildBan>;
  /** An edge for our `GuildBan`. May be used by Relay 1. */
  guildBanEdge?: Maybe<GuildBansEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `GuildBan` mutation. */
export type CreateGuildBanPayloadGuildBanEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildBansOrderBy>>;
};

/** All input for the create `GuildConfig` mutation. */
export type CreateGuildConfigInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GuildConfig` to be created by this mutation. */
  guildConfig: GuildConfigInput;
};

/** The output of our create `GuildConfig` mutation. */
export type CreateGuildConfigPayload = {
  __typename?: 'CreateGuildConfigPayload';
  /** Reads a single `CachedGuild` that is related to this `GuildConfig`. */
  cachedGuildById?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildConfig` that was created by this mutation. */
  guildConfig?: Maybe<GuildConfig>;
  /** An edge for our `GuildConfig`. May be used by Relay 1. */
  guildConfigEdge?: Maybe<GuildConfigsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `GuildConfig` mutation. */
export type CreateGuildConfigPayloadGuildConfigEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildConfigsOrderBy>>;
};

/** All input for the create `LevelRoleApplyJob` mutation. */
export type CreateLevelRoleApplyJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRoleApplyJob` to be created by this mutation. */
  levelRoleApplyJob: LevelRoleApplyJobInput;
};

/** The output of our create `LevelRoleApplyJob` mutation. */
export type CreateLevelRoleApplyJobPayload = {
  __typename?: 'CreateLevelRoleApplyJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleApplyJob` that was created by this mutation. */
  levelRoleApplyJob?: Maybe<LevelRoleApplyJob>;
  /** An edge for our `LevelRoleApplyJob`. May be used by Relay 1. */
  levelRoleApplyJobEdge?: Maybe<LevelRoleApplyJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LevelRoleApplyJob` mutation. */
export type CreateLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleApplyJobsOrderBy>>;
};

/** All input for the create `LevelRole` mutation. */
export type CreateLevelRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRole` to be created by this mutation. */
  levelRole: LevelRoleInput;
};

/** All input for the create `LevelRoleOverride` mutation. */
export type CreateLevelRoleOverrideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRoleOverride` to be created by this mutation. */
  levelRoleOverride: LevelRoleOverrideInput;
};

/** The output of our create `LevelRoleOverride` mutation. */
export type CreateLevelRoleOverridePayload = {
  __typename?: 'CreateLevelRoleOverridePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleOverride` that was created by this mutation. */
  levelRoleOverride?: Maybe<LevelRoleOverride>;
  /** An edge for our `LevelRoleOverride`. May be used by Relay 1. */
  levelRoleOverrideEdge?: Maybe<LevelRoleOverridesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LevelRoleOverride` mutation. */
export type CreateLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleOverridesOrderBy>>;
};

/** The output of our create `LevelRole` mutation. */
export type CreateLevelRolePayload = {
  __typename?: 'CreateLevelRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRole` that was created by this mutation. */
  levelRole?: Maybe<LevelRole>;
  /** An edge for our `LevelRole`. May be used by Relay 1. */
  levelRoleEdge?: Maybe<LevelRolesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LevelRole` mutation. */
export type CreateLevelRolePayloadLevelRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRolesOrderBy>>;
};

/** All input for the create `Member` mutation. */
export type CreateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Member` to be created by this mutation. */
  member: MemberInput;
};

/** The output of our create `Member` mutation. */
export type CreateMemberPayload = {
  __typename?: 'CreateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` that was created by this mutation. */
  member?: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Member` mutation. */
export type CreateMemberPayloadMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  __typename?: 'CreateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was created by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadMessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the create `ModLog` mutation. */
export type CreateModLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ModLog` to be created by this mutation. */
  modLog: ModLogInput;
};

/** The output of our create `ModLog` mutation. */
export type CreateModLogPayload = {
  __typename?: 'CreateModLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ModLog` that was created by this mutation. */
  modLog?: Maybe<ModLog>;
  /** An edge for our `ModLog`. May be used by Relay 1. */
  modLogEdge?: Maybe<ModLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ModLog` mutation. */
export type CreateModLogPayloadModLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ModLogsOrderBy>>;
};

/** All input for the create `MsgLogBlock` mutation. */
export type CreateMsgLogBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `MsgLogBlock` to be created by this mutation. */
  msgLogBlock: MsgLogBlockInput;
};

/** The output of our create `MsgLogBlock` mutation. */
export type CreateMsgLogBlockPayload = {
  __typename?: 'CreateMsgLogBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MsgLogBlock` that was created by this mutation. */
  msgLogBlock?: Maybe<MsgLogBlock>;
  /** An edge for our `MsgLogBlock`. May be used by Relay 1. */
  msgLogBlockEdge?: Maybe<MsgLogBlocksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MsgLogBlock` mutation. */
export type CreateMsgLogBlockPayloadMsgLogBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<MsgLogBlocksOrderBy>>;
};

/** All input for the create `Mute` mutation. */
export type CreateMuteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Mute` to be created by this mutation. */
  mute: MuteInput;
};

/** The output of our create `Mute` mutation. */
export type CreateMutePayload = {
  __typename?: 'CreateMutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `ModLog` that is related to this `Mute`. */
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** The `Mute` that was created by this mutation. */
  mute?: Maybe<Mute>;
  /** An edge for our `Mute`. May be used by Relay 1. */
  muteEdge?: Maybe<MutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Mute` mutation. */
export type CreateMutePayloadMuteEdgeArgs = {
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};

/** All input for the create `Notification` mutation. */
export type CreateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Notification` to be created by this mutation. */
  notification: NotificationInput;
};

/** The output of our create `Notification` mutation. */
export type CreateNotificationPayload = {
  __typename?: 'CreateNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Notification` mutation. */
export type CreateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the create `Reminder` mutation. */
export type CreateReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Reminder` to be created by this mutation. */
  reminder: ReminderInput;
};

/** The output of our create `Reminder` mutation. */
export type CreateReminderPayload = {
  __typename?: 'CreateReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was created by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our create `Reminder` mutation. */
export type CreateReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** All input for the create `RoleMenu` mutation. */
export type CreateRoleMenuInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoleMenu` to be created by this mutation. */
  roleMenu: RoleMenuInput;
};

/** The output of our create `RoleMenu` mutation. */
export type CreateRoleMenuPayload = {
  __typename?: 'CreateRoleMenuPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RoleMenu` that was created by this mutation. */
  roleMenu?: Maybe<RoleMenu>;
  /** An edge for our `RoleMenu`. May be used by Relay 1. */
  roleMenuEdge?: Maybe<RoleMenusEdge>;
};


/** The output of our create `RoleMenu` mutation. */
export type CreateRoleMenuPayloadRoleMenuEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenusOrderBy>>;
};

/** All input for the create `RoleMenuRole` mutation. */
export type CreateRoleMenuRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoleMenuRole` to be created by this mutation. */
  roleMenuRole: RoleMenuRoleInput;
};

/** The output of our create `RoleMenuRole` mutation. */
export type CreateRoleMenuRolePayload = {
  __typename?: 'CreateRoleMenuRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `RoleMenu` that is related to this `RoleMenuRole`. */
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
  /** The `RoleMenuRole` that was created by this mutation. */
  roleMenuRole?: Maybe<RoleMenuRole>;
  /** An edge for our `RoleMenuRole`. May be used by Relay 1. */
  roleMenuRoleEdge?: Maybe<RoleMenuRolesEdge>;
};


/** The output of our create `RoleMenuRole` mutation. */
export type CreateRoleMenuRolePayloadRoleMenuRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tag` to be created by this mutation. */
  tag: TagInput;
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
  __typename?: 'CreateTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<Tag>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our create `Tag` mutation. */
export type CreateTagPayloadTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserLevel` mutation. */
export type CreateUserLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UserLevel` to be created by this mutation. */
  userLevel: UserLevelInput;
};

/** The output of our create `UserLevel` mutation. */
export type CreateUserLevelPayload = {
  __typename?: 'CreateUserLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserLevel` that was created by this mutation. */
  userLevel?: Maybe<UserLevel>;
  /** An edge for our `UserLevel`. May be used by Relay 1. */
  userLevelEdge?: Maybe<UserLevelsEdge>;
};


/** The output of our create `UserLevel` mutation. */
export type CreateUserLevelPayloadUserLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<UserLevelsOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `WebUserGuild` mutation. */
export type CreateWebUserGuildInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `WebUserGuild` to be created by this mutation. */
  webUserGuild: WebUserGuildInput;
};

/** The output of our create `WebUserGuild` mutation. */
export type CreateWebUserGuildPayload = {
  __typename?: 'CreateWebUserGuildPayload';
  /** Reads a single `CachedGuild` that is related to this `WebUserGuild`. */
  cachedGuildByGuildId?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WebUser` that is related to this `WebUserGuild`. */
  webUserByUserId?: Maybe<WebUser>;
  /** The `WebUserGuild` that was created by this mutation. */
  webUserGuild?: Maybe<WebUserGuild>;
  /** An edge for our `WebUserGuild`. May be used by Relay 1. */
  webUserGuildEdge?: Maybe<WebUserGuildsEdge>;
};


/** The output of our create `WebUserGuild` mutation. */
export type CreateWebUserGuildPayloadWebUserGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

/** All input for the create `WebUser` mutation. */
export type CreateWebUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `WebUser` to be created by this mutation. */
  webUser: WebUserInput;
};

/** The output of our create `WebUser` mutation. */
export type CreateWebUserPayload = {
  __typename?: 'CreateWebUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebUser` that was created by this mutation. */
  webUser?: Maybe<WebUser>;
  /** An edge for our `WebUser`. May be used by Relay 1. */
  webUserEdge?: Maybe<WebUsersEdge>;
};


/** The output of our create `WebUser` mutation. */
export type CreateWebUserPayloadWebUserEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUsersOrderBy>>;
};

/** All input for the create `XpBlock` mutation. */
export type CreateXpBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `XpBlock` to be created by this mutation. */
  xpBlock: XpBlockInput;
};

/** The output of our create `XpBlock` mutation. */
export type CreateXpBlockPayload = {
  __typename?: 'CreateXpBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `XpBlock` that was created by this mutation. */
  xpBlock?: Maybe<XpBlock>;
  /** An edge for our `XpBlock`. May be used by Relay 1. */
  xpBlockEdge?: Maybe<XpBlocksEdge>;
};


/** The output of our create `XpBlock` mutation. */
export type CreateXpBlockPayloadXpBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<XpBlocksOrderBy>>;
};

/** A `BigInt` edge in the connection. */
export type CurrentUserManagedGuildIdEdge = {
  __typename?: 'CurrentUserManagedGuildIdEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `BigInt` at the end of the edge. */
  node?: Maybe<Scalars['BigInt']>;
};

/** A connection to a list of `BigInt` values. */
export type CurrentUserManagedGuildIdsConnection = {
  __typename?: 'CurrentUserManagedGuildIdsConnection';
  /** A list of edges which contains the `BigInt` and cursor to aid in pagination. */
  edges: Array<CurrentUserManagedGuildIdEdge>;
  /** A list of `BigInt` objects. */
  nodes: Array<Maybe<Scalars['BigInt']>>;
  /** The count of *all* `BigInt` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']>>;
};

/** All input for the `deleteBotStatByNameAndCategory` mutation. */
export type DeleteBotStatByNameAndCategoryInput = {
  category: Scalars['String'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteBotStat` mutation. */
export type DeleteBotStatInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BotStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `BotStat` mutation. */
export type DeleteBotStatPayload = {
  __typename?: 'DeleteBotStatPayload';
  /** The `BotStat` that was deleted by this mutation. */
  botStat?: Maybe<BotStat>;
  /** An edge for our `BotStat`. May be used by Relay 1. */
  botStatEdge?: Maybe<BotStatsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedBotStatId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `BotStat` mutation. */
export type DeleteBotStatPayloadBotStatEdgeArgs = {
  orderBy?: InputMaybe<Array<BotStatsOrderBy>>;
};

/** All input for the `deleteCachedGuildById` mutation. */
export type DeleteCachedGuildByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteCachedGuild` mutation. */
export type DeleteCachedGuildInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CachedGuild` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `CachedGuild` mutation. */
export type DeleteCachedGuildPayload = {
  __typename?: 'DeleteCachedGuildPayload';
  /** The `CachedGuild` that was deleted by this mutation. */
  cachedGuild?: Maybe<CachedGuild>;
  /** An edge for our `CachedGuild`. May be used by Relay 1. */
  cachedGuildEdge?: Maybe<CachedGuildsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedCachedGuildId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `CachedGuild` mutation. */
export type DeleteCachedGuildPayloadCachedGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedGuildsOrderBy>>;
};

/** All input for the `deleteCachedUserById` mutation. */
export type DeleteCachedUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteCachedUser` mutation. */
export type DeleteCachedUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CachedUser` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `CachedUser` mutation. */
export type DeleteCachedUserPayload = {
  __typename?: 'DeleteCachedUserPayload';
  /** The `CachedUser` that was deleted by this mutation. */
  cachedUser?: Maybe<CachedUser>;
  /** An edge for our `CachedUser`. May be used by Relay 1. */
  cachedUserEdge?: Maybe<CachedUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedCachedUserId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `CachedUser` mutation. */
export type DeleteCachedUserPayloadCachedUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedUsersOrderBy>>;
};

/** All input for the `deleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType` mutation. */
export type DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput = {
  actionType: EmojiStickerActionType;
  assetId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  time: Scalars['Datetime'];
};

/** All input for the `deleteEmojiStickerStat` mutation. */
export type DeleteEmojiStickerStatInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EmojiStickerStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `EmojiStickerStat` mutation. */
export type DeleteEmojiStickerStatPayload = {
  __typename?: 'DeleteEmojiStickerStatPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedEmojiStickerStatId?: Maybe<Scalars['ID']>;
  /** The `EmojiStickerStat` that was deleted by this mutation. */
  emojiStickerStat?: Maybe<EmojiStickerStat>;
  /** An edge for our `EmojiStickerStat`. May be used by Relay 1. */
  emojiStickerStatEdge?: Maybe<EmojiStickerStatsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `EmojiStickerStat` mutation. */
export type DeleteEmojiStickerStatPayloadEmojiStickerStatEdgeArgs = {
  orderBy?: InputMaybe<Array<EmojiStickerStatsOrderBy>>;
};

/** All input for the `deleteFeedByFeedId` mutation. */
export type DeleteFeedByFeedIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
};

/** All input for the `deleteFeed` mutation. */
export type DeleteFeedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Feed` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFeedItemByFeedIdAndItemId` mutation. */
export type DeleteFeedItemByFeedIdAndItemIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
  itemId: Scalars['String'];
};

/** All input for the `deleteFeedItem` mutation. */
export type DeleteFeedItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FeedItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `FeedItem` mutation. */
export type DeleteFeedItemPayload = {
  __typename?: 'DeleteFeedItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedFeedItemId?: Maybe<Scalars['ID']>;
  /** The `FeedItem` that was deleted by this mutation. */
  feedItem?: Maybe<FeedItem>;
  /** An edge for our `FeedItem`. May be used by Relay 1. */
  feedItemEdge?: Maybe<FeedItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FeedItem` mutation. */
export type DeleteFeedItemPayloadFeedItemEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedItemsOrderBy>>;
};

/** The output of our delete `Feed` mutation. */
export type DeleteFeedPayload = {
  __typename?: 'DeleteFeedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedFeedId?: Maybe<Scalars['ID']>;
  /** The `Feed` that was deleted by this mutation. */
  feed?: Maybe<Feed>;
  /** An edge for our `Feed`. May be used by Relay 1. */
  feedEdge?: Maybe<FeedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Feed` mutation. */
export type DeleteFeedPayloadFeedEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedsOrderBy>>;
};

/** All input for the `deleteFeedSubscriptionByFeedIdAndChannelId` mutation. */
export type DeleteFeedSubscriptionByFeedIdAndChannelIdInput = {
  channelId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
};

/** All input for the `deleteFeedSubscription` mutation. */
export type DeleteFeedSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FeedSubscription` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `FeedSubscription` mutation. */
export type DeleteFeedSubscriptionPayload = {
  __typename?: 'DeleteFeedSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedFeedSubscriptionId?: Maybe<Scalars['ID']>;
  /** Reads a single `Feed` that is related to this `FeedSubscription`. */
  feedByFeedId?: Maybe<Feed>;
  /** The `FeedSubscription` that was deleted by this mutation. */
  feedSubscription?: Maybe<FeedSubscription>;
  /** An edge for our `FeedSubscription`. May be used by Relay 1. */
  feedSubscriptionEdge?: Maybe<FeedSubscriptionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FeedSubscription` mutation. */
export type DeleteFeedSubscriptionPayloadFeedSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};

/** All input for the `deleteGuildBanByGuildIdAndUserId` mutation. */
export type DeleteGuildBanByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteGuildBan` mutation. */
export type DeleteGuildBanInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GuildBan` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `GuildBan` mutation. */
export type DeleteGuildBanPayload = {
  __typename?: 'DeleteGuildBanPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedGuildBanId?: Maybe<Scalars['ID']>;
  /** The `GuildBan` that was deleted by this mutation. */
  guildBan?: Maybe<GuildBan>;
  /** An edge for our `GuildBan`. May be used by Relay 1. */
  guildBanEdge?: Maybe<GuildBansEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `GuildBan` mutation. */
export type DeleteGuildBanPayloadGuildBanEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildBansOrderBy>>;
};

/** All input for the `deleteGuildConfigById` mutation. */
export type DeleteGuildConfigByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteGuildConfig` mutation. */
export type DeleteGuildConfigInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GuildConfig` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `GuildConfig` mutation. */
export type DeleteGuildConfigPayload = {
  __typename?: 'DeleteGuildConfigPayload';
  /** Reads a single `CachedGuild` that is related to this `GuildConfig`. */
  cachedGuildById?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedGuildConfigId?: Maybe<Scalars['ID']>;
  /** The `GuildConfig` that was deleted by this mutation. */
  guildConfig?: Maybe<GuildConfig>;
  /** An edge for our `GuildConfig`. May be used by Relay 1. */
  guildConfigEdge?: Maybe<GuildConfigsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `GuildConfig` mutation. */
export type DeleteGuildConfigPayloadGuildConfigEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildConfigsOrderBy>>;
};

/** All input for the `deleteLevelRoleApplyJobByGuildId` mutation. */
export type DeleteLevelRoleApplyJobByGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
};

/** All input for the `deleteLevelRoleApplyJobByInteractionId` mutation. */
export type DeleteLevelRoleApplyJobByInteractionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  interactionId: Scalars['BigInt'];
};

/** All input for the `deleteLevelRoleApplyJob` mutation. */
export type DeleteLevelRoleApplyJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LevelRoleApplyJob` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `LevelRoleApplyJob` mutation. */
export type DeleteLevelRoleApplyJobPayload = {
  __typename?: 'DeleteLevelRoleApplyJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedLevelRoleApplyJobId?: Maybe<Scalars['ID']>;
  /** The `LevelRoleApplyJob` that was deleted by this mutation. */
  levelRoleApplyJob?: Maybe<LevelRoleApplyJob>;
  /** An edge for our `LevelRoleApplyJob`. May be used by Relay 1. */
  levelRoleApplyJobEdge?: Maybe<LevelRoleApplyJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LevelRoleApplyJob` mutation. */
export type DeleteLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleApplyJobsOrderBy>>;
};

/** All input for the `deleteLevelRoleByGuildIdAndRoleId` mutation. */
export type DeleteLevelRoleByGuildIdAndRoleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
};

/** All input for the `deleteLevelRole` mutation. */
export type DeleteLevelRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LevelRole` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLevelRoleOverrideByGuildIdAndRoleIdAndUserId` mutation. */
export type DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteLevelRoleOverride` mutation. */
export type DeleteLevelRoleOverrideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LevelRoleOverride` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `LevelRoleOverride` mutation. */
export type DeleteLevelRoleOverridePayload = {
  __typename?: 'DeleteLevelRoleOverridePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedLevelRoleOverrideId?: Maybe<Scalars['ID']>;
  /** The `LevelRoleOverride` that was deleted by this mutation. */
  levelRoleOverride?: Maybe<LevelRoleOverride>;
  /** An edge for our `LevelRoleOverride`. May be used by Relay 1. */
  levelRoleOverrideEdge?: Maybe<LevelRoleOverridesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LevelRoleOverride` mutation. */
export type DeleteLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleOverridesOrderBy>>;
};

/** The output of our delete `LevelRole` mutation. */
export type DeleteLevelRolePayload = {
  __typename?: 'DeleteLevelRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedLevelRoleId?: Maybe<Scalars['ID']>;
  /** The `LevelRole` that was deleted by this mutation. */
  levelRole?: Maybe<LevelRole>;
  /** An edge for our `LevelRole`. May be used by Relay 1. */
  levelRoleEdge?: Maybe<LevelRolesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LevelRole` mutation. */
export type DeleteLevelRolePayloadLevelRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRolesOrderBy>>;
};

/** All input for the `deleteMemberByGuildIdAndUserId` mutation. */
export type DeleteMemberByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteMember` mutation. */
export type DeleteMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Member` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Member` mutation. */
export type DeleteMemberPayload = {
  __typename?: 'DeleteMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMemberId?: Maybe<Scalars['ID']>;
  /** The `Member` that was deleted by this mutation. */
  member?: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Member` mutation. */
export type DeleteMemberPayloadMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};

/** All input for the `deleteMessageByMessageId` mutation. */
export type DeleteMessageByMessageIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  messageId: Scalars['BigInt'];
};

/** All input for the `deleteMessage` mutation. */
export type DeleteMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Message` mutation. */
export type DeleteMessagePayload = {
  __typename?: 'DeleteMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMessageId?: Maybe<Scalars['ID']>;
  /** The `Message` that was deleted by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Message` mutation. */
export type DeleteMessagePayloadMessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `deleteMessagesBefore` mutation. */
export type DeleteMessagesBeforeInput = {
  before?: InputMaybe<Scalars['Datetime']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `deleteMessagesBefore` mutation. */
export type DeleteMessagesBeforePayload = {
  __typename?: 'DeleteMessagesBeforePayload';
  bigInt?: Maybe<Scalars['BigInt']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `deleteModLogByGuildIdAndCaseId` mutation. */
export type DeleteModLogByGuildIdAndCaseIdInput = {
  caseId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
};

/** All input for the `deleteModLog` mutation. */
export type DeleteModLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ModLog` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `ModLog` mutation. */
export type DeleteModLogPayload = {
  __typename?: 'DeleteModLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedModLogId?: Maybe<Scalars['ID']>;
  /** The `ModLog` that was deleted by this mutation. */
  modLog?: Maybe<ModLog>;
  /** An edge for our `ModLog`. May be used by Relay 1. */
  modLogEdge?: Maybe<ModLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ModLog` mutation. */
export type DeleteModLogPayloadModLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ModLogsOrderBy>>;
};

/** All input for the `deleteMsgLogBlockByGuildIdAndChannelId` mutation. */
export type DeleteMsgLogBlockByGuildIdAndChannelIdInput = {
  channelId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
};

/** All input for the `deleteMsgLogBlock` mutation. */
export type DeleteMsgLogBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MsgLogBlock` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `MsgLogBlock` mutation. */
export type DeleteMsgLogBlockPayload = {
  __typename?: 'DeleteMsgLogBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMsgLogBlockId?: Maybe<Scalars['ID']>;
  /** The `MsgLogBlock` that was deleted by this mutation. */
  msgLogBlock?: Maybe<MsgLogBlock>;
  /** An edge for our `MsgLogBlock`. May be used by Relay 1. */
  msgLogBlockEdge?: Maybe<MsgLogBlocksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MsgLogBlock` mutation. */
export type DeleteMsgLogBlockPayloadMsgLogBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<MsgLogBlocksOrderBy>>;
};

/** All input for the `deleteMuteByGuildIdAndUserId` mutation. */
export type DeleteMuteByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteMute` mutation. */
export type DeleteMuteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Mute` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Mute` mutation. */
export type DeleteMutePayload = {
  __typename?: 'DeleteMutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedMuteId?: Maybe<Scalars['ID']>;
  /** Reads a single `ModLog` that is related to this `Mute`. */
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** The `Mute` that was deleted by this mutation. */
  mute?: Maybe<Mute>;
  /** An edge for our `Mute`. May be used by Relay 1. */
  muteEdge?: Maybe<MutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Mute` mutation. */
export type DeleteMutePayloadMuteEdgeArgs = {
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};

/** All input for the `deleteNotificationByUserIdAndGuildIdAndKeyword` mutation. */
export type DeleteNotificationByUserIdAndGuildIdAndKeywordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  keyword: Scalars['String'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteNotification` mutation. */
export type DeleteNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedNotificationId?: Maybe<Scalars['ID']>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `deleteReminderByUserIdAndSetAt` mutation. */
export type DeleteReminderByUserIdAndSetAtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  setAt: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteReminder` mutation. */
export type DeleteReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reminder` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayload = {
  __typename?: 'DeleteReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedReminderId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was deleted by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** All input for the `deleteRoleMenuByGuildIdAndMenuName` mutation. */
export type DeleteRoleMenuByGuildIdAndMenuNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
};

/** All input for the `deleteRoleMenu` mutation. */
export type DeleteRoleMenuInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoleMenu` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `RoleMenu` mutation. */
export type DeleteRoleMenuPayload = {
  __typename?: 'DeleteRoleMenuPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRoleMenuId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RoleMenu` that was deleted by this mutation. */
  roleMenu?: Maybe<RoleMenu>;
  /** An edge for our `RoleMenu`. May be used by Relay 1. */
  roleMenuEdge?: Maybe<RoleMenusEdge>;
};


/** The output of our delete `RoleMenu` mutation. */
export type DeleteRoleMenuPayloadRoleMenuEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenusOrderBy>>;
};

/** All input for the `deleteRoleMenuRoleByGuildIdAndMenuNameAndRoleId` mutation. */
export type DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleId: Scalars['BigInt'];
};

/** All input for the `deleteRoleMenuRole` mutation. */
export type DeleteRoleMenuRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoleMenuRole` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `RoleMenuRole` mutation. */
export type DeleteRoleMenuRolePayload = {
  __typename?: 'DeleteRoleMenuRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedRoleMenuRoleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `RoleMenu` that is related to this `RoleMenuRole`. */
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
  /** The `RoleMenuRole` that was deleted by this mutation. */
  roleMenuRole?: Maybe<RoleMenuRole>;
  /** An edge for our `RoleMenuRole`. May be used by Relay 1. */
  roleMenuRoleEdge?: Maybe<RoleMenuRolesEdge>;
};


/** The output of our delete `RoleMenuRole` mutation. */
export type DeleteRoleMenuRolePayloadRoleMenuRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};

/** All input for the `deleteRoleMenuRoles` mutation. */
export type DeleteRoleMenuRolesInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
  roleIds?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
};

/** The output of our `deleteRoleMenuRoles` mutation. */
export type DeleteRoleMenuRolesPayload = {
  __typename?: 'DeleteRoleMenuRolesPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  roleMenuRoles?: Maybe<Array<RoleMenuRole>>;
};

/** All input for the `deleteTagByGuildIdAndTagName` mutation. */
export type DeleteTagByGuildIdAndTagNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
};

/** All input for the `deleteTag` mutation. */
export type DeleteTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Tag` mutation. */
export type DeleteTagPayload = {
  __typename?: 'DeleteTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedTagId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tag` that was deleted by this mutation. */
  tag?: Maybe<Tag>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our delete `Tag` mutation. */
export type DeleteTagPayloadTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `deleteUserById` mutation. */
export type DeleteUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserLevelByUserIdAndGuildId` mutation. */
export type DeleteUserLevelByUserIdAndGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteUserLevel` mutation. */
export type DeleteUserLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserLevel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `UserLevel` mutation. */
export type DeleteUserLevelPayload = {
  __typename?: 'DeleteUserLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserLevelId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserLevel` that was deleted by this mutation. */
  userLevel?: Maybe<UserLevel>;
  /** An edge for our `UserLevel`. May be used by Relay 1. */
  userLevelEdge?: Maybe<UserLevelsEdge>;
};


/** The output of our delete `UserLevel` mutation. */
export type DeleteUserLevelPayloadUserLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<UserLevelsOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedUserId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteWebUserById` mutation. */
export type DeleteWebUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Unique identifier for the user. This should match their Discord ID. */
  id: Scalars['BigInt'];
};

/** All input for the `deleteWebUserGuildByUserIdAndGuildId` mutation. */
export type DeleteWebUserGuildByUserIdAndGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `deleteWebUserGuild` mutation. */
export type DeleteWebUserGuildInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WebUserGuild` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `WebUserGuild` mutation. */
export type DeleteWebUserGuildPayload = {
  __typename?: 'DeleteWebUserGuildPayload';
  /** Reads a single `CachedGuild` that is related to this `WebUserGuild`. */
  cachedGuildByGuildId?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWebUserGuildId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WebUser` that is related to this `WebUserGuild`. */
  webUserByUserId?: Maybe<WebUser>;
  /** The `WebUserGuild` that was deleted by this mutation. */
  webUserGuild?: Maybe<WebUserGuild>;
  /** An edge for our `WebUserGuild`. May be used by Relay 1. */
  webUserGuildEdge?: Maybe<WebUserGuildsEdge>;
};


/** The output of our delete `WebUserGuild` mutation. */
export type DeleteWebUserGuildPayloadWebUserGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

/** All input for the `deleteWebUser` mutation. */
export type DeleteWebUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WebUser` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `WebUser` mutation. */
export type DeleteWebUserPayload = {
  __typename?: 'DeleteWebUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedWebUserId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebUser` that was deleted by this mutation. */
  webUser?: Maybe<WebUser>;
  /** An edge for our `WebUser`. May be used by Relay 1. */
  webUserEdge?: Maybe<WebUsersEdge>;
};


/** The output of our delete `WebUser` mutation. */
export type DeleteWebUserPayloadWebUserEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUsersOrderBy>>;
};

/** All input for the `deleteXpBlockByGuildIdAndBlockId` mutation. */
export type DeleteXpBlockByGuildIdAndBlockIdInput = {
  blockId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
};

/** All input for the `deleteXpBlock` mutation. */
export type DeleteXpBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `XpBlock` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `XpBlock` mutation. */
export type DeleteXpBlockPayload = {
  __typename?: 'DeleteXpBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  deletedXpBlockId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `XpBlock` that was deleted by this mutation. */
  xpBlock?: Maybe<XpBlock>;
  /** An edge for our `XpBlock`. May be used by Relay 1. */
  xpBlockEdge?: Maybe<XpBlocksEdge>;
};


/** The output of our delete `XpBlock` mutation. */
export type DeleteXpBlockPayloadXpBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<XpBlocksOrderBy>>;
};

export type EligibleLevelRole = {
  __typename?: 'EligibleLevelRole';
  roleIds?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EligibleLevelRole` object types. All fields are combined with a logical ‘and.’ */
export type EligibleLevelRoleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EligibleLevelRoleFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<EligibleLevelRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EligibleLevelRoleFilter>>;
  /** Filter by the object’s `roleIds` field. */
  roleIds?: InputMaybe<BigIntListFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** A connection to a list of `EligibleLevelRole` values. */
export type EligibleLevelRolesConnection = {
  __typename?: 'EligibleLevelRolesConnection';
  /** A list of edges which contains the `EligibleLevelRole` and cursor to aid in pagination. */
  edges: Array<EligibleLevelRolesEdge>;
  /** A list of `EligibleLevelRole` objects. */
  nodes: Array<EligibleLevelRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EligibleLevelRole` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `EligibleLevelRole` edge in the connection. */
export type EligibleLevelRolesEdge = {
  __typename?: 'EligibleLevelRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `EligibleLevelRole` at the end of the edge. */
  node: EligibleLevelRole;
};

export enum EmojiStickerActionType {
  Message = 'MESSAGE',
  Reaction = 'REACTION'
}

/** A filter to be used against EmojiStickerActionType fields. All fields are combined with a logical ‘and.’ */
export type EmojiStickerActionTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<EmojiStickerActionType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<EmojiStickerActionType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<EmojiStickerActionType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<EmojiStickerActionType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<EmojiStickerActionType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<EmojiStickerActionType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<EmojiStickerActionType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<EmojiStickerActionType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<EmojiStickerActionType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<EmojiStickerActionType>>;
};

export type EmojiStickerStat = Node & {
  __typename?: 'EmojiStickerStat';
  actionType: EmojiStickerActionType;
  assetId: Scalars['BigInt'];
  assetType: GuildAssetType;
  count: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  time: Scalars['Datetime'];
};

export type EmojiStickerStatAggregates = {
  __typename?: 'EmojiStickerStatAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<EmojiStickerStatAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<EmojiStickerStatDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<EmojiStickerStatMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<EmojiStickerStatMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<EmojiStickerStatStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<EmojiStickerStatStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<EmojiStickerStatSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<EmojiStickerStatVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<EmojiStickerStatVarianceSampleAggregates>;
};

export type EmojiStickerStatAverageAggregates = {
  __typename?: 'EmojiStickerStatAverageAggregates';
  /** Mean average of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `EmojiStickerStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EmojiStickerStatCondition = {
  /** Checks for equality with the object’s `actionType` field. */
  actionType?: InputMaybe<EmojiStickerActionType>;
  /** Checks for equality with the object’s `assetId` field. */
  assetId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `assetType` field. */
  assetType?: InputMaybe<GuildAssetType>;
  /** Checks for equality with the object’s `count` field. */
  count?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `time` field. */
  time?: InputMaybe<Scalars['Datetime']>;
};

export type EmojiStickerStatDistinctCountAggregates = {
  __typename?: 'EmojiStickerStatDistinctCountAggregates';
  /** Distinct count of actionType across the matching connection */
  actionType?: Maybe<Scalars['BigInt']>;
  /** Distinct count of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of assetType across the matching connection */
  assetType?: Maybe<Scalars['BigInt']>;
  /** Distinct count of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of time across the matching connection */
  time?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `EmojiStickerStat` object types. All fields are combined with a logical ‘and.’ */
export type EmojiStickerStatFilter = {
  /** Filter by the object’s `actionType` field. */
  actionType?: InputMaybe<EmojiStickerActionTypeFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EmojiStickerStatFilter>>;
  /** Filter by the object’s `assetId` field. */
  assetId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `assetType` field. */
  assetType?: InputMaybe<GuildAssetTypeFilter>;
  /** Filter by the object’s `count` field. */
  count?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EmojiStickerStatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EmojiStickerStatFilter>>;
  /** Filter by the object’s `time` field. */
  time?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `EmojiStickerStatIncrementDatum` */
export type EmojiStickerStatIncrementDatumInput = {
  assetId?: InputMaybe<Scalars['BigInt']>;
  assetType?: InputMaybe<GuildAssetType>;
};

/** An input for mutations affecting `EmojiStickerStat` */
export type EmojiStickerStatInput = {
  actionType: EmojiStickerActionType;
  assetId: Scalars['BigInt'];
  assetType: GuildAssetType;
  count: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  time: Scalars['Datetime'];
};

export type EmojiStickerStatMaxAggregates = {
  __typename?: 'EmojiStickerStatMaxAggregates';
  /** Maximum of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigInt']>;
  /** Maximum of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

export type EmojiStickerStatMinAggregates = {
  __typename?: 'EmojiStickerStatMinAggregates';
  /** Minimum of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigInt']>;
  /** Minimum of count across the matching connection */
  count?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `EmojiStickerStat`. Fields that are set will be updated. */
export type EmojiStickerStatPatch = {
  actionType?: InputMaybe<EmojiStickerActionType>;
  assetId?: InputMaybe<Scalars['BigInt']>;
  assetType?: InputMaybe<GuildAssetType>;
  count?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<Scalars['Datetime']>;
};

export type EmojiStickerStatStddevPopulationAggregates = {
  __typename?: 'EmojiStickerStatStddevPopulationAggregates';
  /** Population standard deviation of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type EmojiStickerStatStddevSampleAggregates = {
  __typename?: 'EmojiStickerStatStddevSampleAggregates';
  /** Sample standard deviation of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type EmojiStickerStatSumAggregates = {
  __typename?: 'EmojiStickerStatSumAggregates';
  /** Sum of assetId across the matching connection */
  assetId: Scalars['BigFloat'];
  /** Sum of count across the matching connection */
  count: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
};

export type EmojiStickerStatVariancePopulationAggregates = {
  __typename?: 'EmojiStickerStatVariancePopulationAggregates';
  /** Population variance of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type EmojiStickerStatVarianceSampleAggregates = {
  __typename?: 'EmojiStickerStatVarianceSampleAggregates';
  /** Sample variance of assetId across the matching connection */
  assetId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of count across the matching connection */
  count?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `EmojiStickerStat` values. */
export type EmojiStickerStatsConnection = {
  __typename?: 'EmojiStickerStatsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<EmojiStickerStatAggregates>;
  /** A list of edges which contains the `EmojiStickerStat` and cursor to aid in pagination. */
  edges: Array<EmojiStickerStatsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<EmojiStickerStatAggregates>>;
  /** A list of `EmojiStickerStat` objects. */
  nodes: Array<EmojiStickerStat>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EmojiStickerStat` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `EmojiStickerStat` values. */
export type EmojiStickerStatsConnectionGroupedAggregatesArgs = {
  groupBy: Array<EmojiStickerStatsGroupBy>;
  having?: InputMaybe<EmojiStickerStatsHavingInput>;
};

/** A `EmojiStickerStat` edge in the connection. */
export type EmojiStickerStatsEdge = {
  __typename?: 'EmojiStickerStatsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `EmojiStickerStat` at the end of the edge. */
  node: EmojiStickerStat;
};

/** Grouping methods for `EmojiStickerStat` for usage during aggregation. */
export enum EmojiStickerStatsGroupBy {
  ActionType = 'ACTION_TYPE',
  AssetId = 'ASSET_ID',
  AssetType = 'ASSET_TYPE',
  Count = 'COUNT',
  GuildId = 'GUILD_ID',
  Time = 'TIME',
  TimeTruncatedToDay = 'TIME_TRUNCATED_TO_DAY',
  TimeTruncatedToHour = 'TIME_TRUNCATED_TO_HOUR'
}

export type EmojiStickerStatsHavingAverageInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingDistinctCountInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `EmojiStickerStat` aggregates. */
export type EmojiStickerStatsHavingInput = {
  AND?: InputMaybe<Array<EmojiStickerStatsHavingInput>>;
  OR?: InputMaybe<Array<EmojiStickerStatsHavingInput>>;
  average?: InputMaybe<EmojiStickerStatsHavingAverageInput>;
  distinctCount?: InputMaybe<EmojiStickerStatsHavingDistinctCountInput>;
  max?: InputMaybe<EmojiStickerStatsHavingMaxInput>;
  min?: InputMaybe<EmojiStickerStatsHavingMinInput>;
  stddevPopulation?: InputMaybe<EmojiStickerStatsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<EmojiStickerStatsHavingStddevSampleInput>;
  sum?: InputMaybe<EmojiStickerStatsHavingSumInput>;
  variancePopulation?: InputMaybe<EmojiStickerStatsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<EmojiStickerStatsHavingVarianceSampleInput>;
};

export type EmojiStickerStatsHavingMaxInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingMinInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingStddevPopulationInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingStddevSampleInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingSumInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingVariancePopulationInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

export type EmojiStickerStatsHavingVarianceSampleInput = {
  assetId?: InputMaybe<HavingBigintFilter>;
  count?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  time?: InputMaybe<HavingDatetimeFilter>;
};

/** Methods to use when ordering `EmojiStickerStat`. */
export enum EmojiStickerStatsOrderBy {
  ActionTypeAsc = 'ACTION_TYPE_ASC',
  ActionTypeDesc = 'ACTION_TYPE_DESC',
  AssetIdAsc = 'ASSET_ID_ASC',
  AssetIdDesc = 'ASSET_ID_DESC',
  AssetTypeAsc = 'ASSET_TYPE_ASC',
  AssetTypeDesc = 'ASSET_TYPE_DESC',
  CountAsc = 'COUNT_ASC',
  CountDesc = 'COUNT_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimeAsc = 'TIME_ASC',
  TimeDesc = 'TIME_DESC'
}

export type Feed = Node & {
  __typename?: 'Feed';
  feedId: Scalars['String'];
  /** Reads and enables pagination through a set of `FeedSubscription`. */
  feedSubscriptionsByFeedId: FeedSubscriptionsConnection;
  metadata?: Maybe<Scalars['JSON']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


export type FeedFeedSubscriptionsByFeedIdArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<FeedSubscriptionCondition>;
  filter?: InputMaybe<FeedSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};

export type FeedAggregates = {
  __typename?: 'FeedAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FeedDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
};

/** A condition to be used against `Feed` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FeedCondition = {
  /** Checks for equality with the object’s `feedId` field. */
  feedId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `metadata` field. */
  metadata?: InputMaybe<Scalars['JSON']>;
};

export type FeedDistinctCountAggregates = {
  __typename?: 'FeedDistinctCountAggregates';
  /** Distinct count of feedId across the matching connection */
  feedId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of metadata across the matching connection */
  metadata?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Feed` object types. All fields are combined with a logical ‘and.’ */
export type FeedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FeedFilter>>;
  /** Filter by the object’s `feedId` field. */
  feedId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `metadata` field. */
  metadata?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FeedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FeedFilter>>;
};

/** An input for mutations affecting `Feed` */
export type FeedInput = {
  feedId: Scalars['String'];
  metadata?: InputMaybe<Scalars['JSON']>;
};

export type FeedItem = Node & {
  __typename?: 'FeedItem';
  feedId: Scalars['String'];
  itemId: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type FeedItemAggregates = {
  __typename?: 'FeedItemAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FeedItemDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
};

/**
 * A condition to be used against `FeedItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FeedItemCondition = {
  /** Checks for equality with the object’s `feedId` field. */
  feedId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `itemId` field. */
  itemId?: InputMaybe<Scalars['String']>;
};

export type FeedItemDistinctCountAggregates = {
  __typename?: 'FeedItemDistinctCountAggregates';
  /** Distinct count of feedId across the matching connection */
  feedId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of itemId across the matching connection */
  itemId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `FeedItem` object types. All fields are combined with a logical ‘and.’ */
export type FeedItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FeedItemFilter>>;
  /** Filter by the object’s `feedId` field. */
  feedId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `itemId` field. */
  itemId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FeedItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FeedItemFilter>>;
};

/** An input for mutations affecting `FeedItem` */
export type FeedItemInput = {
  feedId: Scalars['String'];
  itemId: Scalars['String'];
};

/** Represents an update to a `FeedItem`. Fields that are set will be updated. */
export type FeedItemPatch = {
  feedId?: InputMaybe<Scalars['String']>;
  itemId?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `FeedItem` values. */
export type FeedItemsConnection = {
  __typename?: 'FeedItemsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FeedItemAggregates>;
  /** A list of edges which contains the `FeedItem` and cursor to aid in pagination. */
  edges: Array<FeedItemsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FeedItemAggregates>>;
  /** A list of `FeedItem` objects. */
  nodes: Array<FeedItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FeedItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `FeedItem` values. */
export type FeedItemsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FeedItemsGroupBy>;
  having?: InputMaybe<FeedItemsHavingInput>;
};

/** A `FeedItem` edge in the connection. */
export type FeedItemsEdge = {
  __typename?: 'FeedItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FeedItem` at the end of the edge. */
  node: FeedItem;
};

/** Grouping methods for `FeedItem` for usage during aggregation. */
export enum FeedItemsGroupBy {
  FeedId = 'FEED_ID',
  ItemId = 'ITEM_ID'
}

/** Conditions for `FeedItem` aggregates. */
export type FeedItemsHavingInput = {
  AND?: InputMaybe<Array<FeedItemsHavingInput>>;
  OR?: InputMaybe<Array<FeedItemsHavingInput>>;
};

/** Methods to use when ordering `FeedItem`. */
export enum FeedItemsOrderBy {
  FeedIdAsc = 'FEED_ID_ASC',
  FeedIdDesc = 'FEED_ID_DESC',
  ItemIdAsc = 'ITEM_ID_ASC',
  ItemIdDesc = 'ITEM_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `Feed`. Fields that are set will be updated. */
export type FeedPatch = {
  feedId?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Scalars['JSON']>;
};

export type FeedSubscription = Node & {
  __typename?: 'FeedSubscription';
  channelId: Scalars['BigInt'];
  /** Reads a single `Feed` that is related to this `FeedSubscription`. */
  feedByFeedId?: Maybe<Feed>;
  feedId: Scalars['String'];
  guildId: Scalars['BigInt'];
  mentionRole?: Maybe<Scalars['BigInt']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type FeedSubscriptionAggregates = {
  __typename?: 'FeedSubscriptionAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<FeedSubscriptionAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FeedSubscriptionDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<FeedSubscriptionMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<FeedSubscriptionMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<FeedSubscriptionStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<FeedSubscriptionStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<FeedSubscriptionSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<FeedSubscriptionVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<FeedSubscriptionVarianceSampleAggregates>;
};

export type FeedSubscriptionAverageAggregates = {
  __typename?: 'FeedSubscriptionAverageAggregates';
  /** Mean average of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `FeedSubscription` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FeedSubscriptionCondition = {
  /** Checks for equality with the object’s `channelId` field. */
  channelId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `feedId` field. */
  feedId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `mentionRole` field. */
  mentionRole?: InputMaybe<Scalars['BigInt']>;
};

export type FeedSubscriptionDistinctCountAggregates = {
  __typename?: 'FeedSubscriptionDistinctCountAggregates';
  /** Distinct count of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of feedId across the matching connection */
  feedId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `FeedSubscription` object types. All fields are combined with a logical ‘and.’ */
export type FeedSubscriptionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FeedSubscriptionFilter>>;
  /** Filter by the object’s `channelId` field. */
  channelId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `feedId` field. */
  feedId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `mentionRole` field. */
  mentionRole?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FeedSubscriptionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FeedSubscriptionFilter>>;
};

/** An input for mutations affecting `FeedSubscription` */
export type FeedSubscriptionInput = {
  channelId: Scalars['BigInt'];
  feedId: Scalars['String'];
  guildId: Scalars['BigInt'];
  mentionRole?: InputMaybe<Scalars['BigInt']>;
};

export type FeedSubscriptionMaxAggregates = {
  __typename?: 'FeedSubscriptionMaxAggregates';
  /** Maximum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigInt']>;
};

export type FeedSubscriptionMinAggregates = {
  __typename?: 'FeedSubscriptionMinAggregates';
  /** Minimum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `FeedSubscription`. Fields that are set will be updated. */
export type FeedSubscriptionPatch = {
  channelId?: InputMaybe<Scalars['BigInt']>;
  feedId?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  mentionRole?: InputMaybe<Scalars['BigInt']>;
};

export type FeedSubscriptionStddevPopulationAggregates = {
  __typename?: 'FeedSubscriptionStddevPopulationAggregates';
  /** Population standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigFloat']>;
};

export type FeedSubscriptionStddevSampleAggregates = {
  __typename?: 'FeedSubscriptionStddevSampleAggregates';
  /** Sample standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigFloat']>;
};

export type FeedSubscriptionSumAggregates = {
  __typename?: 'FeedSubscriptionSumAggregates';
  /** Sum of channelId across the matching connection */
  channelId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of mentionRole across the matching connection */
  mentionRole: Scalars['BigFloat'];
};

export type FeedSubscriptionVariancePopulationAggregates = {
  __typename?: 'FeedSubscriptionVariancePopulationAggregates';
  /** Population variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigFloat']>;
};

export type FeedSubscriptionVarianceSampleAggregates = {
  __typename?: 'FeedSubscriptionVarianceSampleAggregates';
  /** Sample variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of mentionRole across the matching connection */
  mentionRole?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `FeedSubscription` values. */
export type FeedSubscriptionsConnection = {
  __typename?: 'FeedSubscriptionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FeedSubscriptionAggregates>;
  /** A list of edges which contains the `FeedSubscription` and cursor to aid in pagination. */
  edges: Array<FeedSubscriptionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FeedSubscriptionAggregates>>;
  /** A list of `FeedSubscription` objects. */
  nodes: Array<FeedSubscription>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FeedSubscription` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `FeedSubscription` values. */
export type FeedSubscriptionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FeedSubscriptionsGroupBy>;
  having?: InputMaybe<FeedSubscriptionsHavingInput>;
};

/** A `FeedSubscription` edge in the connection. */
export type FeedSubscriptionsEdge = {
  __typename?: 'FeedSubscriptionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FeedSubscription` at the end of the edge. */
  node: FeedSubscription;
};

/** Grouping methods for `FeedSubscription` for usage during aggregation. */
export enum FeedSubscriptionsGroupBy {
  ChannelId = 'CHANNEL_ID',
  FeedId = 'FEED_ID',
  GuildId = 'GUILD_ID',
  MentionRole = 'MENTION_ROLE'
}

export type FeedSubscriptionsHavingAverageInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingDistinctCountInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `FeedSubscription` aggregates. */
export type FeedSubscriptionsHavingInput = {
  AND?: InputMaybe<Array<FeedSubscriptionsHavingInput>>;
  OR?: InputMaybe<Array<FeedSubscriptionsHavingInput>>;
  average?: InputMaybe<FeedSubscriptionsHavingAverageInput>;
  distinctCount?: InputMaybe<FeedSubscriptionsHavingDistinctCountInput>;
  max?: InputMaybe<FeedSubscriptionsHavingMaxInput>;
  min?: InputMaybe<FeedSubscriptionsHavingMinInput>;
  stddevPopulation?: InputMaybe<FeedSubscriptionsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<FeedSubscriptionsHavingStddevSampleInput>;
  sum?: InputMaybe<FeedSubscriptionsHavingSumInput>;
  variancePopulation?: InputMaybe<FeedSubscriptionsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<FeedSubscriptionsHavingVarianceSampleInput>;
};

export type FeedSubscriptionsHavingMaxInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingMinInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingStddevPopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingStddevSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingSumInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingVariancePopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

export type FeedSubscriptionsHavingVarianceSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  mentionRole?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `FeedSubscription`. */
export enum FeedSubscriptionsOrderBy {
  ChannelIdAsc = 'CHANNEL_ID_ASC',
  ChannelIdDesc = 'CHANNEL_ID_DESC',
  FeedIdAsc = 'FEED_ID_ASC',
  FeedIdDesc = 'FEED_ID_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  MentionRoleAsc = 'MENTION_ROLE_ASC',
  MentionRoleDesc = 'MENTION_ROLE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Feed` values. */
export type FeedsConnection = {
  __typename?: 'FeedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FeedAggregates>;
  /** A list of edges which contains the `Feed` and cursor to aid in pagination. */
  edges: Array<FeedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FeedAggregates>>;
  /** A list of `Feed` objects. */
  nodes: Array<Feed>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Feed` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Feed` values. */
export type FeedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FeedsGroupBy>;
  having?: InputMaybe<FeedsHavingInput>;
};

/** A `Feed` edge in the connection. */
export type FeedsEdge = {
  __typename?: 'FeedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Feed` at the end of the edge. */
  node: Feed;
};

/** Grouping methods for `Feed` for usage during aggregation. */
export enum FeedsGroupBy {
  Metadata = 'METADATA'
}

/** Conditions for `Feed` aggregates. */
export type FeedsHavingInput = {
  AND?: InputMaybe<Array<FeedsHavingInput>>;
  OR?: InputMaybe<Array<FeedsHavingInput>>;
};

/** Methods to use when ordering `Feed`. */
export enum FeedsOrderBy {
  FeedIdAsc = 'FEED_ID_ASC',
  FeedIdDesc = 'FEED_ID_DESC',
  FeedSubscriptionsByFeedIdAverageChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdAverageChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdAverageFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdAverageFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdAverageGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdAverageGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdAverageMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdAverageMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_AVERAGE_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdCountAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_COUNT_ASC',
  FeedSubscriptionsByFeedIdCountDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_COUNT_DESC',
  FeedSubscriptionsByFeedIdDistinctCountChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdDistinctCountChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdDistinctCountFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdDistinctCountFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdDistinctCountGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdDistinctCountGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdDistinctCountMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdDistinctCountMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_DISTINCT_COUNT_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdMaxChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdMaxChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdMaxFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdMaxFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdMaxGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdMaxGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdMaxMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdMaxMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MAX_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdMinChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdMinChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdMinFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdMinFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdMinGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdMinGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdMinMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdMinMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_MIN_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdStddevPopulationChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdStddevPopulationChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdStddevPopulationFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdStddevPopulationFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdStddevPopulationGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdStddevPopulationGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdStddevPopulationMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdStddevPopulationMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_POPULATION_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdStddevSampleChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdStddevSampleChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdStddevSampleFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdStddevSampleFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdStddevSampleGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdStddevSampleGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdStddevSampleMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdStddevSampleMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_STDDEV_SAMPLE_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdSumChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdSumChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdSumFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdSumFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdSumGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdSumGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdSumMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdSumMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_SUM_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdVariancePopulationChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdVariancePopulationChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdVariancePopulationFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdVariancePopulationFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdVariancePopulationGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdVariancePopulationGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdVariancePopulationMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdVariancePopulationMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_POPULATION_MENTION_ROLE_DESC',
  FeedSubscriptionsByFeedIdVarianceSampleChannelIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_CHANNEL_ID_ASC',
  FeedSubscriptionsByFeedIdVarianceSampleChannelIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_CHANNEL_ID_DESC',
  FeedSubscriptionsByFeedIdVarianceSampleFeedIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_FEED_ID_ASC',
  FeedSubscriptionsByFeedIdVarianceSampleFeedIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_FEED_ID_DESC',
  FeedSubscriptionsByFeedIdVarianceSampleGuildIdAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_GUILD_ID_ASC',
  FeedSubscriptionsByFeedIdVarianceSampleGuildIdDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_GUILD_ID_DESC',
  FeedSubscriptionsByFeedIdVarianceSampleMentionRoleAsc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_MENTION_ROLE_ASC',
  FeedSubscriptionsByFeedIdVarianceSampleMentionRoleDesc = 'FEED_SUBSCRIPTIONS_BY_FEED_ID_VARIANCE_SAMPLE_MENTION_ROLE_DESC',
  MetadataAsc = 'METADATA_ASC',
  MetadataDesc = 'METADATA_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** All input for the `graphql` mutation. */
export type GraphqlInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  extensions?: InputMaybe<Scalars['JSON']>;
  operationName?: InputMaybe<Scalars['String']>;
  query?: InputMaybe<Scalars['String']>;
  variables?: InputMaybe<Scalars['JSON']>;
};

/** The output of our `graphql` mutation. */
export type GraphqlPayload = {
  __typename?: 'GraphqlPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  json?: Maybe<Scalars['JSON']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export enum GuildAssetType {
  Emoji = 'EMOJI',
  Sticker = 'STICKER'
}

/** A filter to be used against GuildAssetType fields. All fields are combined with a logical ‘and.’ */
export type GuildAssetTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<GuildAssetType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<GuildAssetType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<GuildAssetType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<GuildAssetType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<GuildAssetType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<GuildAssetType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<GuildAssetType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<GuildAssetType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<GuildAssetType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<GuildAssetType>>;
};

export type GuildBan = Node & {
  __typename?: 'GuildBan';
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  userId: Scalars['BigInt'];
};

export type GuildBanAggregates = {
  __typename?: 'GuildBanAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<GuildBanAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<GuildBanDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<GuildBanMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<GuildBanMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<GuildBanStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<GuildBanStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<GuildBanSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<GuildBanVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<GuildBanVarianceSampleAggregates>;
};

export type GuildBanAverageAggregates = {
  __typename?: 'GuildBanAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `GuildBan` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GuildBanCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type GuildBanDistinctCountAggregates = {
  __typename?: 'GuildBanDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `GuildBan` object types. All fields are combined with a logical ‘and.’ */
export type GuildBanFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GuildBanFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GuildBanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GuildBanFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `GuildBan` */
export type GuildBanInput = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

export type GuildBanMaxAggregates = {
  __typename?: 'GuildBanMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type GuildBanMinAggregates = {
  __typename?: 'GuildBanMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `GuildBan`. Fields that are set will be updated. */
export type GuildBanPatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type GuildBanStddevPopulationAggregates = {
  __typename?: 'GuildBanStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type GuildBanStddevSampleAggregates = {
  __typename?: 'GuildBanStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type GuildBanSumAggregates = {
  __typename?: 'GuildBanSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type GuildBanVariancePopulationAggregates = {
  __typename?: 'GuildBanVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type GuildBanVarianceSampleAggregates = {
  __typename?: 'GuildBanVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `GuildBan` values. */
export type GuildBansConnection = {
  __typename?: 'GuildBansConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<GuildBanAggregates>;
  /** A list of edges which contains the `GuildBan` and cursor to aid in pagination. */
  edges: Array<GuildBansEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<GuildBanAggregates>>;
  /** A list of `GuildBan` objects. */
  nodes: Array<GuildBan>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GuildBan` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `GuildBan` values. */
export type GuildBansConnectionGroupedAggregatesArgs = {
  groupBy: Array<GuildBansGroupBy>;
  having?: InputMaybe<GuildBansHavingInput>;
};

/** A `GuildBan` edge in the connection. */
export type GuildBansEdge = {
  __typename?: 'GuildBansEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GuildBan` at the end of the edge. */
  node: GuildBan;
};

/** Grouping methods for `GuildBan` for usage during aggregation. */
export enum GuildBansGroupBy {
  GuildId = 'GUILD_ID',
  UserId = 'USER_ID'
}

export type GuildBansHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `GuildBan` aggregates. */
export type GuildBansHavingInput = {
  AND?: InputMaybe<Array<GuildBansHavingInput>>;
  OR?: InputMaybe<Array<GuildBansHavingInput>>;
  average?: InputMaybe<GuildBansHavingAverageInput>;
  distinctCount?: InputMaybe<GuildBansHavingDistinctCountInput>;
  max?: InputMaybe<GuildBansHavingMaxInput>;
  min?: InputMaybe<GuildBansHavingMinInput>;
  stddevPopulation?: InputMaybe<GuildBansHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<GuildBansHavingStddevSampleInput>;
  sum?: InputMaybe<GuildBansHavingSumInput>;
  variancePopulation?: InputMaybe<GuildBansHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<GuildBansHavingVarianceSampleInput>;
};

export type GuildBansHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type GuildBansHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `GuildBan`. */
export enum GuildBansOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type GuildConfig = Node & {
  __typename?: 'GuildConfig';
  /** Reads a single `CachedGuild` that is related to this `GuildConfig`. */
  cachedGuildById?: Maybe<CachedGuild>;
  data: Scalars['JSON'];
  disabledChannels?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  id: Scalars['BigInt'];
  inviteGuard: Scalars['Boolean'];
  joinMsg?: Maybe<Scalars['String']>;
  joinMsgEnabled: Scalars['Boolean'];
  joinReact?: Maybe<Scalars['String']>;
  leaveMsg?: Maybe<Scalars['String']>;
  leaveMsgEnabled: Scalars['Boolean'];
  logMember?: Maybe<Scalars['BigInt']>;
  logMemberEnabled: Scalars['Boolean'];
  logMod?: Maybe<Scalars['BigInt']>;
  logModEnabled: Scalars['Boolean'];
  logMsg?: Maybe<Scalars['BigInt']>;
  logMsgEnabled: Scalars['Boolean'];
  maxMention?: Maybe<Scalars['Int']>;
  msgChannel?: Maybe<Scalars['BigInt']>;
  muteDmEnabled: Scalars['Boolean'];
  muteDmText?: Maybe<Scalars['String']>;
  muteDuration?: Maybe<Scalars['BigInt']>;
  muteRole?: Maybe<Scalars['BigInt']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  prefix?: Maybe<Scalars['String']>;
  roleChannel?: Maybe<Scalars['BigInt']>;
  roleConfig?: Maybe<Scalars['JSON']>;
  roleEnabled: Scalars['Boolean'];
  warnDmEnabled: Scalars['Boolean'];
  warnDmText?: Maybe<Scalars['String']>;
};

export type GuildConfigAggregates = {
  __typename?: 'GuildConfigAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<GuildConfigAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<GuildConfigDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<GuildConfigMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<GuildConfigMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<GuildConfigStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<GuildConfigStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<GuildConfigSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<GuildConfigVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<GuildConfigVarianceSampleAggregates>;
};

export type GuildConfigAverageAggregates = {
  __typename?: 'GuildConfigAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Mean average of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigFloat']>;
  /** Mean average of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigFloat']>;
  /** Mean average of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigFloat']>;
  /** Mean average of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigFloat']>;
  /** Mean average of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigFloat']>;
  /** Mean average of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigFloat']>;
  /** Mean average of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `GuildConfig` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GuildConfigCondition = {
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `disabledChannels` field. */
  disabledChannels?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `inviteGuard` field. */
  inviteGuard?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `joinMsg` field. */
  joinMsg?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `joinMsgEnabled` field. */
  joinMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `joinReact` field. */
  joinReact?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `leaveMsg` field. */
  leaveMsg?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `leaveMsgEnabled` field. */
  leaveMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `logMember` field. */
  logMember?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `logMemberEnabled` field. */
  logMemberEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `logMod` field. */
  logMod?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `logModEnabled` field. */
  logModEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `logMsg` field. */
  logMsg?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `logMsgEnabled` field. */
  logMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `maxMention` field. */
  maxMention?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `msgChannel` field. */
  msgChannel?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `muteDmEnabled` field. */
  muteDmEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `muteDmText` field. */
  muteDmText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `muteDuration` field. */
  muteDuration?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `muteRole` field. */
  muteRole?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `roleChannel` field. */
  roleChannel?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `roleConfig` field. */
  roleConfig?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `roleEnabled` field. */
  roleEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `warnDmEnabled` field. */
  warnDmEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `warnDmText` field. */
  warnDmText?: InputMaybe<Scalars['String']>;
};

export type GuildConfigDistinctCountAggregates = {
  __typename?: 'GuildConfigDistinctCountAggregates';
  /** Distinct count of data across the matching connection */
  data?: Maybe<Scalars['BigInt']>;
  /** Distinct count of disabledChannels across the matching connection */
  disabledChannels?: Maybe<Scalars['BigInt']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Distinct count of inviteGuard across the matching connection */
  inviteGuard?: Maybe<Scalars['BigInt']>;
  /** Distinct count of joinMsg across the matching connection */
  joinMsg?: Maybe<Scalars['BigInt']>;
  /** Distinct count of joinMsgEnabled across the matching connection */
  joinMsgEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of joinReact across the matching connection */
  joinReact?: Maybe<Scalars['BigInt']>;
  /** Distinct count of leaveMsg across the matching connection */
  leaveMsg?: Maybe<Scalars['BigInt']>;
  /** Distinct count of leaveMsgEnabled across the matching connection */
  leaveMsgEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logMemberEnabled across the matching connection */
  logMemberEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logModEnabled across the matching connection */
  logModEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigInt']>;
  /** Distinct count of logMsgEnabled across the matching connection */
  logMsgEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigInt']>;
  /** Distinct count of muteDmEnabled across the matching connection */
  muteDmEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of muteDmText across the matching connection */
  muteDmText?: Maybe<Scalars['BigInt']>;
  /** Distinct count of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigInt']>;
  /** Distinct count of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigInt']>;
  /** Distinct count of prefix across the matching connection */
  prefix?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleConfig across the matching connection */
  roleConfig?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleEnabled across the matching connection */
  roleEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of warnDmEnabled across the matching connection */
  warnDmEnabled?: Maybe<Scalars['BigInt']>;
  /** Distinct count of warnDmText across the matching connection */
  warnDmText?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `GuildConfig` object types. All fields are combined with a logical ‘and.’ */
export type GuildConfigFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GuildConfigFilter>>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `disabledChannels` field. */
  disabledChannels?: InputMaybe<BigIntListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `inviteGuard` field. */
  inviteGuard?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `joinMsg` field. */
  joinMsg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `joinMsgEnabled` field. */
  joinMsgEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `joinReact` field. */
  joinReact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `leaveMsg` field. */
  leaveMsg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `leaveMsgEnabled` field. */
  leaveMsgEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `logMember` field. */
  logMember?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `logMemberEnabled` field. */
  logMemberEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `logMod` field. */
  logMod?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `logModEnabled` field. */
  logModEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `logMsg` field. */
  logMsg?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `logMsgEnabled` field. */
  logMsgEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `maxMention` field. */
  maxMention?: InputMaybe<IntFilter>;
  /** Filter by the object’s `msgChannel` field. */
  msgChannel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `muteDmEnabled` field. */
  muteDmEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `muteDmText` field. */
  muteDmText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `muteDuration` field. */
  muteDuration?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `muteRole` field. */
  muteRole?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GuildConfigFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GuildConfigFilter>>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `roleChannel` field. */
  roleChannel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `roleConfig` field. */
  roleConfig?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `roleEnabled` field. */
  roleEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `warnDmEnabled` field. */
  warnDmEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `warnDmText` field. */
  warnDmText?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `GuildConfig` */
export type GuildConfigInput = {
  data?: InputMaybe<Scalars['JSON']>;
  disabledChannels?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  id: Scalars['BigInt'];
  inviteGuard?: InputMaybe<Scalars['Boolean']>;
  joinMsg?: InputMaybe<Scalars['String']>;
  joinMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  joinReact?: InputMaybe<Scalars['String']>;
  leaveMsg?: InputMaybe<Scalars['String']>;
  leaveMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  logMember?: InputMaybe<Scalars['BigInt']>;
  logMemberEnabled?: InputMaybe<Scalars['Boolean']>;
  logMod?: InputMaybe<Scalars['BigInt']>;
  logModEnabled?: InputMaybe<Scalars['Boolean']>;
  logMsg?: InputMaybe<Scalars['BigInt']>;
  logMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  maxMention?: InputMaybe<Scalars['Int']>;
  msgChannel?: InputMaybe<Scalars['BigInt']>;
  muteDmEnabled?: InputMaybe<Scalars['Boolean']>;
  muteDmText?: InputMaybe<Scalars['String']>;
  muteDuration?: InputMaybe<Scalars['BigInt']>;
  muteRole?: InputMaybe<Scalars['BigInt']>;
  prefix?: InputMaybe<Scalars['String']>;
  roleChannel?: InputMaybe<Scalars['BigInt']>;
  roleConfig?: InputMaybe<Scalars['JSON']>;
  roleEnabled?: InputMaybe<Scalars['Boolean']>;
  warnDmEnabled?: InputMaybe<Scalars['Boolean']>;
  warnDmText?: InputMaybe<Scalars['String']>;
};

export type GuildConfigMaxAggregates = {
  __typename?: 'GuildConfigMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Maximum of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigInt']>;
  /** Maximum of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigInt']>;
  /** Maximum of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigInt']>;
  /** Maximum of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['Int']>;
  /** Maximum of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigInt']>;
  /** Maximum of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigInt']>;
  /** Maximum of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigInt']>;
  /** Maximum of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigInt']>;
};

export type GuildConfigMinAggregates = {
  __typename?: 'GuildConfigMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Minimum of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigInt']>;
  /** Minimum of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigInt']>;
  /** Minimum of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigInt']>;
  /** Minimum of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['Int']>;
  /** Minimum of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigInt']>;
  /** Minimum of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigInt']>;
  /** Minimum of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigInt']>;
  /** Minimum of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `GuildConfig`. Fields that are set will be updated. */
export type GuildConfigPatch = {
  data?: InputMaybe<Scalars['JSON']>;
  disabledChannels?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  id?: InputMaybe<Scalars['BigInt']>;
  inviteGuard?: InputMaybe<Scalars['Boolean']>;
  joinMsg?: InputMaybe<Scalars['String']>;
  joinMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  joinReact?: InputMaybe<Scalars['String']>;
  leaveMsg?: InputMaybe<Scalars['String']>;
  leaveMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  logMember?: InputMaybe<Scalars['BigInt']>;
  logMemberEnabled?: InputMaybe<Scalars['Boolean']>;
  logMod?: InputMaybe<Scalars['BigInt']>;
  logModEnabled?: InputMaybe<Scalars['Boolean']>;
  logMsg?: InputMaybe<Scalars['BigInt']>;
  logMsgEnabled?: InputMaybe<Scalars['Boolean']>;
  maxMention?: InputMaybe<Scalars['Int']>;
  msgChannel?: InputMaybe<Scalars['BigInt']>;
  muteDmEnabled?: InputMaybe<Scalars['Boolean']>;
  muteDmText?: InputMaybe<Scalars['String']>;
  muteDuration?: InputMaybe<Scalars['BigInt']>;
  muteRole?: InputMaybe<Scalars['BigInt']>;
  prefix?: InputMaybe<Scalars['String']>;
  roleChannel?: InputMaybe<Scalars['BigInt']>;
  roleConfig?: InputMaybe<Scalars['JSON']>;
  roleEnabled?: InputMaybe<Scalars['Boolean']>;
  warnDmEnabled?: InputMaybe<Scalars['Boolean']>;
  warnDmText?: InputMaybe<Scalars['String']>;
};

export type GuildConfigStddevPopulationAggregates = {
  __typename?: 'GuildConfigStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigFloat']>;
};

export type GuildConfigStddevSampleAggregates = {
  __typename?: 'GuildConfigStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigFloat']>;
};

export type GuildConfigSumAggregates = {
  __typename?: 'GuildConfigSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigFloat'];
  /** Sum of logMember across the matching connection */
  logMember: Scalars['BigFloat'];
  /** Sum of logMod across the matching connection */
  logMod: Scalars['BigFloat'];
  /** Sum of logMsg across the matching connection */
  logMsg: Scalars['BigFloat'];
  /** Sum of maxMention across the matching connection */
  maxMention: Scalars['BigInt'];
  /** Sum of msgChannel across the matching connection */
  msgChannel: Scalars['BigFloat'];
  /** Sum of muteDuration across the matching connection */
  muteDuration: Scalars['BigFloat'];
  /** Sum of muteRole across the matching connection */
  muteRole: Scalars['BigFloat'];
  /** Sum of roleChannel across the matching connection */
  roleChannel: Scalars['BigFloat'];
};

export type GuildConfigVariancePopulationAggregates = {
  __typename?: 'GuildConfigVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Population variance of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigFloat']>;
  /** Population variance of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigFloat']>;
  /** Population variance of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigFloat']>;
  /** Population variance of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigFloat']>;
  /** Population variance of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigFloat']>;
  /** Population variance of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigFloat']>;
  /** Population variance of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigFloat']>;
};

export type GuildConfigVarianceSampleAggregates = {
  __typename?: 'GuildConfigVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of logMember across the matching connection */
  logMember?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of logMod across the matching connection */
  logMod?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of logMsg across the matching connection */
  logMsg?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of maxMention across the matching connection */
  maxMention?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgChannel across the matching connection */
  msgChannel?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of muteDuration across the matching connection */
  muteDuration?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of muteRole across the matching connection */
  muteRole?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of roleChannel across the matching connection */
  roleChannel?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `GuildConfig` values. */
export type GuildConfigsConnection = {
  __typename?: 'GuildConfigsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<GuildConfigAggregates>;
  /** A list of edges which contains the `GuildConfig` and cursor to aid in pagination. */
  edges: Array<GuildConfigsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<GuildConfigAggregates>>;
  /** A list of `GuildConfig` objects. */
  nodes: Array<GuildConfig>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GuildConfig` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `GuildConfig` values. */
export type GuildConfigsConnectionGroupedAggregatesArgs = {
  groupBy: Array<GuildConfigsGroupBy>;
  having?: InputMaybe<GuildConfigsHavingInput>;
};

/** A `GuildConfig` edge in the connection. */
export type GuildConfigsEdge = {
  __typename?: 'GuildConfigsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GuildConfig` at the end of the edge. */
  node: GuildConfig;
};

/** Grouping methods for `GuildConfig` for usage during aggregation. */
export enum GuildConfigsGroupBy {
  Data = 'DATA',
  DisabledChannels = 'DISABLED_CHANNELS',
  InviteGuard = 'INVITE_GUARD',
  JoinMsg = 'JOIN_MSG',
  JoinMsgEnabled = 'JOIN_MSG_ENABLED',
  JoinReact = 'JOIN_REACT',
  LeaveMsg = 'LEAVE_MSG',
  LeaveMsgEnabled = 'LEAVE_MSG_ENABLED',
  LogMember = 'LOG_MEMBER',
  LogMemberEnabled = 'LOG_MEMBER_ENABLED',
  LogMod = 'LOG_MOD',
  LogModEnabled = 'LOG_MOD_ENABLED',
  LogMsg = 'LOG_MSG',
  LogMsgEnabled = 'LOG_MSG_ENABLED',
  MaxMention = 'MAX_MENTION',
  MsgChannel = 'MSG_CHANNEL',
  MuteDmEnabled = 'MUTE_DM_ENABLED',
  MuteDmText = 'MUTE_DM_TEXT',
  MuteDuration = 'MUTE_DURATION',
  MuteRole = 'MUTE_ROLE',
  Prefix = 'PREFIX',
  RoleChannel = 'ROLE_CHANNEL',
  RoleConfig = 'ROLE_CONFIG',
  RoleEnabled = 'ROLE_ENABLED',
  WarnDmEnabled = 'WARN_DM_ENABLED',
  WarnDmText = 'WARN_DM_TEXT'
}

export type GuildConfigsHavingAverageInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingDistinctCountInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `GuildConfig` aggregates. */
export type GuildConfigsHavingInput = {
  AND?: InputMaybe<Array<GuildConfigsHavingInput>>;
  OR?: InputMaybe<Array<GuildConfigsHavingInput>>;
  average?: InputMaybe<GuildConfigsHavingAverageInput>;
  distinctCount?: InputMaybe<GuildConfigsHavingDistinctCountInput>;
  max?: InputMaybe<GuildConfigsHavingMaxInput>;
  min?: InputMaybe<GuildConfigsHavingMinInput>;
  stddevPopulation?: InputMaybe<GuildConfigsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<GuildConfigsHavingStddevSampleInput>;
  sum?: InputMaybe<GuildConfigsHavingSumInput>;
  variancePopulation?: InputMaybe<GuildConfigsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<GuildConfigsHavingVarianceSampleInput>;
};

export type GuildConfigsHavingMaxInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingMinInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingStddevPopulationInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingStddevSampleInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingSumInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingVariancePopulationInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

export type GuildConfigsHavingVarianceSampleInput = {
  id?: InputMaybe<HavingBigintFilter>;
  logMember?: InputMaybe<HavingBigintFilter>;
  logMod?: InputMaybe<HavingBigintFilter>;
  logMsg?: InputMaybe<HavingBigintFilter>;
  maxMention?: InputMaybe<HavingIntFilter>;
  msgChannel?: InputMaybe<HavingBigintFilter>;
  muteDuration?: InputMaybe<HavingBigintFilter>;
  muteRole?: InputMaybe<HavingBigintFilter>;
  roleChannel?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `GuildConfig`. */
export enum GuildConfigsOrderBy {
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  DisabledChannelsAsc = 'DISABLED_CHANNELS_ASC',
  DisabledChannelsDesc = 'DISABLED_CHANNELS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InviteGuardAsc = 'INVITE_GUARD_ASC',
  InviteGuardDesc = 'INVITE_GUARD_DESC',
  JoinMsgAsc = 'JOIN_MSG_ASC',
  JoinMsgDesc = 'JOIN_MSG_DESC',
  JoinMsgEnabledAsc = 'JOIN_MSG_ENABLED_ASC',
  JoinMsgEnabledDesc = 'JOIN_MSG_ENABLED_DESC',
  JoinReactAsc = 'JOIN_REACT_ASC',
  JoinReactDesc = 'JOIN_REACT_DESC',
  LeaveMsgAsc = 'LEAVE_MSG_ASC',
  LeaveMsgDesc = 'LEAVE_MSG_DESC',
  LeaveMsgEnabledAsc = 'LEAVE_MSG_ENABLED_ASC',
  LeaveMsgEnabledDesc = 'LEAVE_MSG_ENABLED_DESC',
  LogMemberAsc = 'LOG_MEMBER_ASC',
  LogMemberDesc = 'LOG_MEMBER_DESC',
  LogMemberEnabledAsc = 'LOG_MEMBER_ENABLED_ASC',
  LogMemberEnabledDesc = 'LOG_MEMBER_ENABLED_DESC',
  LogModAsc = 'LOG_MOD_ASC',
  LogModDesc = 'LOG_MOD_DESC',
  LogModEnabledAsc = 'LOG_MOD_ENABLED_ASC',
  LogModEnabledDesc = 'LOG_MOD_ENABLED_DESC',
  LogMsgAsc = 'LOG_MSG_ASC',
  LogMsgDesc = 'LOG_MSG_DESC',
  LogMsgEnabledAsc = 'LOG_MSG_ENABLED_ASC',
  LogMsgEnabledDesc = 'LOG_MSG_ENABLED_DESC',
  MaxMentionAsc = 'MAX_MENTION_ASC',
  MaxMentionDesc = 'MAX_MENTION_DESC',
  MsgChannelAsc = 'MSG_CHANNEL_ASC',
  MsgChannelDesc = 'MSG_CHANNEL_DESC',
  MuteDmEnabledAsc = 'MUTE_DM_ENABLED_ASC',
  MuteDmEnabledDesc = 'MUTE_DM_ENABLED_DESC',
  MuteDmTextAsc = 'MUTE_DM_TEXT_ASC',
  MuteDmTextDesc = 'MUTE_DM_TEXT_DESC',
  MuteDurationAsc = 'MUTE_DURATION_ASC',
  MuteDurationDesc = 'MUTE_DURATION_DESC',
  MuteRoleAsc = 'MUTE_ROLE_ASC',
  MuteRoleDesc = 'MUTE_ROLE_DESC',
  Natural = 'NATURAL',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleChannelAsc = 'ROLE_CHANNEL_ASC',
  RoleChannelDesc = 'ROLE_CHANNEL_DESC',
  RoleConfigAsc = 'ROLE_CONFIG_ASC',
  RoleConfigDesc = 'ROLE_CONFIG_DESC',
  RoleEnabledAsc = 'ROLE_ENABLED_ASC',
  RoleEnabledDesc = 'ROLE_ENABLED_DESC',
  WarnDmEnabledAsc = 'WARN_DM_ENABLED_ASC',
  WarnDmEnabledDesc = 'WARN_DM_ENABLED_DESC',
  WarnDmTextAsc = 'WARN_DM_TEXT_ASC',
  WarnDmTextDesc = 'WARN_DM_TEXT_DESC'
}

export type HavingBigintFilter = {
  equalTo?: InputMaybe<Scalars['BigInt']>;
  greaterThan?: InputMaybe<Scalars['BigInt']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  lessThan?: InputMaybe<Scalars['BigInt']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']>;
  notEqualTo?: InputMaybe<Scalars['BigInt']>;
};

export type HavingDatetimeFilter = {
  equalTo?: InputMaybe<Scalars['Datetime']>;
  greaterThan?: InputMaybe<Scalars['Datetime']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  lessThan?: InputMaybe<Scalars['Datetime']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']>;
  notEqualTo?: InputMaybe<Scalars['Datetime']>;
};

export type HavingIntFilter = {
  equalTo?: InputMaybe<Scalars['Int']>;
  greaterThan?: InputMaybe<Scalars['Int']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  lessThan?: InputMaybe<Scalars['Int']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  notEqualTo?: InputMaybe<Scalars['Int']>;
};

/** All input for the `incrementEmojiStickerStat` mutation. */
export type IncrementEmojiStickerStatInput = {
  actionType: EmojiStickerActionType;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  data: Array<InputMaybe<EmojiStickerStatIncrementDatumInput>>;
  guildId: Scalars['BigInt'];
};

/** The output of our `incrementEmojiStickerStat` mutation. */
export type IncrementEmojiStickerStatPayload = {
  __typename?: 'IncrementEmojiStickerStatPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']>>;
};

export type LevelRole = Node & {
  __typename?: 'LevelRole';
  addLevel?: Maybe<Scalars['BigInt']>;
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  removeLevel?: Maybe<Scalars['BigInt']>;
  roleId: Scalars['BigInt'];
};

export type LevelRoleAggregates = {
  __typename?: 'LevelRoleAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LevelRoleAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LevelRoleDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LevelRoleMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LevelRoleMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LevelRoleStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LevelRoleStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LevelRoleSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LevelRoleVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LevelRoleVarianceSampleAggregates>;
};

export type LevelRoleApplyJob = Node & {
  __typename?: 'LevelRoleApplyJob';
  channelId: Scalars['BigInt'];
  createdAt: Scalars['Datetime'];
  guildId: Scalars['BigInt'];
  interactionId: Scalars['BigInt'];
  membersApplied: Scalars['BigInt'];
  membersNotFound: Scalars['BigInt'];
  membersSkipped: Scalars['BigInt'];
  membersTotal: Scalars['BigInt'];
  membersTotalProcessed: Scalars['BigInt'];
  messageId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  notifyUserId: Scalars['BigInt'];
  requestsProcessed: Scalars['BigInt'];
  requestsTotal?: Maybe<Scalars['BigInt']>;
  updatedAt: Scalars['Datetime'];
};

export type LevelRoleApplyJobAggregates = {
  __typename?: 'LevelRoleApplyJobAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LevelRoleApplyJobAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LevelRoleApplyJobDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LevelRoleApplyJobMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LevelRoleApplyJobMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LevelRoleApplyJobStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LevelRoleApplyJobStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LevelRoleApplyJobSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LevelRoleApplyJobVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LevelRoleApplyJobVarianceSampleAggregates>;
};

export type LevelRoleApplyJobAverageAggregates = {
  __typename?: 'LevelRoleApplyJobAverageAggregates';
  /** Mean average of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigFloat']>;
  /** Mean average of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigFloat']>;
  /** Mean average of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigFloat']>;
  /** Mean average of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigFloat']>;
  /** Mean average of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigFloat']>;
  /** Mean average of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigFloat']>;
  /** Mean average of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `LevelRoleApplyJob` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LevelRoleApplyJobCondition = {
  /** Checks for equality with the object’s `channelId` field. */
  channelId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `interactionId` field. */
  interactionId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `membersApplied` field. */
  membersApplied?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `membersNotFound` field. */
  membersNotFound?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `membersSkipped` field. */
  membersSkipped?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `membersTotal` field. */
  membersTotal?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `membersTotalProcessed` field. */
  membersTotalProcessed?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `notifyUserId` field. */
  notifyUserId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `requestsProcessed` field. */
  requestsProcessed?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `requestsTotal` field. */
  requestsTotal?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type LevelRoleApplyJobDistinctCountAggregates = {
  __typename?: 'LevelRoleApplyJobDistinctCountAggregates';
  /** Distinct count of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigInt']>;
  /** Distinct count of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigInt']>;
  /** Distinct count of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigInt']>;
  /** Distinct count of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigInt']>;
  /** Distinct count of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigInt']>;
  /** Distinct count of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigInt']>;
  /** Distinct count of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigInt']>;
  /** Distinct count of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `LevelRoleApplyJob` object types. All fields are combined with a logical ‘and.’ */
export type LevelRoleApplyJobFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LevelRoleApplyJobFilter>>;
  /** Filter by the object’s `channelId` field. */
  channelId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `interactionId` field. */
  interactionId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `membersApplied` field. */
  membersApplied?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `membersNotFound` field. */
  membersNotFound?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `membersSkipped` field. */
  membersSkipped?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `membersTotal` field. */
  membersTotal?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `membersTotalProcessed` field. */
  membersTotalProcessed?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LevelRoleApplyJobFilter>;
  /** Filter by the object’s `notifyUserId` field. */
  notifyUserId?: InputMaybe<BigIntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LevelRoleApplyJobFilter>>;
  /** Filter by the object’s `requestsProcessed` field. */
  requestsProcessed?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `requestsTotal` field. */
  requestsTotal?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `LevelRoleApplyJob` */
export type LevelRoleApplyJobInput = {
  channelId: Scalars['BigInt'];
  createdAt?: InputMaybe<Scalars['Datetime']>;
  guildId: Scalars['BigInt'];
  interactionId: Scalars['BigInt'];
  membersApplied?: InputMaybe<Scalars['BigInt']>;
  membersNotFound?: InputMaybe<Scalars['BigInt']>;
  membersSkipped?: InputMaybe<Scalars['BigInt']>;
  membersTotal: Scalars['BigInt'];
  membersTotalProcessed?: InputMaybe<Scalars['BigInt']>;
  messageId: Scalars['BigInt'];
  notifyUserId: Scalars['BigInt'];
  requestsProcessed?: InputMaybe<Scalars['BigInt']>;
  requestsTotal?: InputMaybe<Scalars['BigInt']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type LevelRoleApplyJobMaxAggregates = {
  __typename?: 'LevelRoleApplyJobMaxAggregates';
  /** Maximum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigInt']>;
  /** Maximum of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigInt']>;
  /** Maximum of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigInt']>;
  /** Maximum of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigInt']>;
  /** Maximum of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigInt']>;
  /** Maximum of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigInt']>;
  /** Maximum of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Maximum of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigInt']>;
  /** Maximum of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigInt']>;
  /** Maximum of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigInt']>;
};

export type LevelRoleApplyJobMinAggregates = {
  __typename?: 'LevelRoleApplyJobMinAggregates';
  /** Minimum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigInt']>;
  /** Minimum of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigInt']>;
  /** Minimum of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigInt']>;
  /** Minimum of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigInt']>;
  /** Minimum of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigInt']>;
  /** Minimum of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigInt']>;
  /** Minimum of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Minimum of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigInt']>;
  /** Minimum of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigInt']>;
  /** Minimum of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `LevelRoleApplyJob`. Fields that are set will be updated. */
export type LevelRoleApplyJobPatch = {
  channelId?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  interactionId?: InputMaybe<Scalars['BigInt']>;
  membersApplied?: InputMaybe<Scalars['BigInt']>;
  membersNotFound?: InputMaybe<Scalars['BigInt']>;
  membersSkipped?: InputMaybe<Scalars['BigInt']>;
  membersTotal?: InputMaybe<Scalars['BigInt']>;
  membersTotalProcessed?: InputMaybe<Scalars['BigInt']>;
  messageId?: InputMaybe<Scalars['BigInt']>;
  notifyUserId?: InputMaybe<Scalars['BigInt']>;
  requestsProcessed?: InputMaybe<Scalars['BigInt']>;
  requestsTotal?: InputMaybe<Scalars['BigInt']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

export type LevelRoleApplyJobStddevPopulationAggregates = {
  __typename?: 'LevelRoleApplyJobStddevPopulationAggregates';
  /** Population standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleApplyJobStddevSampleAggregates = {
  __typename?: 'LevelRoleApplyJobStddevSampleAggregates';
  /** Sample standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleApplyJobSumAggregates = {
  __typename?: 'LevelRoleApplyJobSumAggregates';
  /** Sum of channelId across the matching connection */
  channelId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of interactionId across the matching connection */
  interactionId: Scalars['BigFloat'];
  /** Sum of membersApplied across the matching connection */
  membersApplied: Scalars['BigFloat'];
  /** Sum of membersNotFound across the matching connection */
  membersNotFound: Scalars['BigFloat'];
  /** Sum of membersSkipped across the matching connection */
  membersSkipped: Scalars['BigFloat'];
  /** Sum of membersTotal across the matching connection */
  membersTotal: Scalars['BigFloat'];
  /** Sum of membersTotalProcessed across the matching connection */
  membersTotalProcessed: Scalars['BigFloat'];
  /** Sum of messageId across the matching connection */
  messageId: Scalars['BigFloat'];
  /** Sum of notifyUserId across the matching connection */
  notifyUserId: Scalars['BigFloat'];
  /** Sum of requestsProcessed across the matching connection */
  requestsProcessed: Scalars['BigFloat'];
  /** Sum of requestsTotal across the matching connection */
  requestsTotal: Scalars['BigFloat'];
};

export type LevelRoleApplyJobVariancePopulationAggregates = {
  __typename?: 'LevelRoleApplyJobVariancePopulationAggregates';
  /** Population variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigFloat']>;
  /** Population variance of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigFloat']>;
  /** Population variance of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigFloat']>;
  /** Population variance of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigFloat']>;
  /** Population variance of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigFloat']>;
  /** Population variance of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigFloat']>;
  /** Population variance of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleApplyJobVarianceSampleAggregates = {
  __typename?: 'LevelRoleApplyJobVarianceSampleAggregates';
  /** Sample variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of interactionId across the matching connection */
  interactionId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of membersApplied across the matching connection */
  membersApplied?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of membersNotFound across the matching connection */
  membersNotFound?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of membersSkipped across the matching connection */
  membersSkipped?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of membersTotal across the matching connection */
  membersTotal?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of membersTotalProcessed across the matching connection */
  membersTotalProcessed?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of notifyUserId across the matching connection */
  notifyUserId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of requestsProcessed across the matching connection */
  requestsProcessed?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of requestsTotal across the matching connection */
  requestsTotal?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `LevelRoleApplyJob` values. */
export type LevelRoleApplyJobsConnection = {
  __typename?: 'LevelRoleApplyJobsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LevelRoleApplyJobAggregates>;
  /** A list of edges which contains the `LevelRoleApplyJob` and cursor to aid in pagination. */
  edges: Array<LevelRoleApplyJobsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LevelRoleApplyJobAggregates>>;
  /** A list of `LevelRoleApplyJob` objects. */
  nodes: Array<LevelRoleApplyJob>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LevelRoleApplyJob` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `LevelRoleApplyJob` values. */
export type LevelRoleApplyJobsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LevelRoleApplyJobsGroupBy>;
  having?: InputMaybe<LevelRoleApplyJobsHavingInput>;
};

/** A `LevelRoleApplyJob` edge in the connection. */
export type LevelRoleApplyJobsEdge = {
  __typename?: 'LevelRoleApplyJobsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LevelRoleApplyJob` at the end of the edge. */
  node: LevelRoleApplyJob;
};

/** Grouping methods for `LevelRoleApplyJob` for usage during aggregation. */
export enum LevelRoleApplyJobsGroupBy {
  ChannelId = 'CHANNEL_ID',
  CreatedAt = 'CREATED_AT',
  CreatedAtTruncatedToDay = 'CREATED_AT_TRUNCATED_TO_DAY',
  CreatedAtTruncatedToHour = 'CREATED_AT_TRUNCATED_TO_HOUR',
  MembersApplied = 'MEMBERS_APPLIED',
  MembersNotFound = 'MEMBERS_NOT_FOUND',
  MembersSkipped = 'MEMBERS_SKIPPED',
  MembersTotal = 'MEMBERS_TOTAL',
  MembersTotalProcessed = 'MEMBERS_TOTAL_PROCESSED',
  MessageId = 'MESSAGE_ID',
  NotifyUserId = 'NOTIFY_USER_ID',
  RequestsProcessed = 'REQUESTS_PROCESSED',
  RequestsTotal = 'REQUESTS_TOTAL',
  UpdatedAt = 'UPDATED_AT',
  UpdatedAtTruncatedToDay = 'UPDATED_AT_TRUNCATED_TO_DAY',
  UpdatedAtTruncatedToHour = 'UPDATED_AT_TRUNCATED_TO_HOUR'
}

export type LevelRoleApplyJobsHavingAverageInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingDistinctCountInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `LevelRoleApplyJob` aggregates. */
export type LevelRoleApplyJobsHavingInput = {
  AND?: InputMaybe<Array<LevelRoleApplyJobsHavingInput>>;
  OR?: InputMaybe<Array<LevelRoleApplyJobsHavingInput>>;
  average?: InputMaybe<LevelRoleApplyJobsHavingAverageInput>;
  distinctCount?: InputMaybe<LevelRoleApplyJobsHavingDistinctCountInput>;
  max?: InputMaybe<LevelRoleApplyJobsHavingMaxInput>;
  min?: InputMaybe<LevelRoleApplyJobsHavingMinInput>;
  stddevPopulation?: InputMaybe<LevelRoleApplyJobsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LevelRoleApplyJobsHavingStddevSampleInput>;
  sum?: InputMaybe<LevelRoleApplyJobsHavingSumInput>;
  variancePopulation?: InputMaybe<LevelRoleApplyJobsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LevelRoleApplyJobsHavingVarianceSampleInput>;
};

export type LevelRoleApplyJobsHavingMaxInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingMinInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingStddevPopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingStddevSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingSumInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingVariancePopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type LevelRoleApplyJobsHavingVarianceSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  interactionId?: InputMaybe<HavingBigintFilter>;
  membersApplied?: InputMaybe<HavingBigintFilter>;
  membersNotFound?: InputMaybe<HavingBigintFilter>;
  membersSkipped?: InputMaybe<HavingBigintFilter>;
  membersTotal?: InputMaybe<HavingBigintFilter>;
  membersTotalProcessed?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
  notifyUserId?: InputMaybe<HavingBigintFilter>;
  requestsProcessed?: InputMaybe<HavingBigintFilter>;
  requestsTotal?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Methods to use when ordering `LevelRoleApplyJob`. */
export enum LevelRoleApplyJobsOrderBy {
  ChannelIdAsc = 'CHANNEL_ID_ASC',
  ChannelIdDesc = 'CHANNEL_ID_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  InteractionIdAsc = 'INTERACTION_ID_ASC',
  InteractionIdDesc = 'INTERACTION_ID_DESC',
  MembersAppliedAsc = 'MEMBERS_APPLIED_ASC',
  MembersAppliedDesc = 'MEMBERS_APPLIED_DESC',
  MembersNotFoundAsc = 'MEMBERS_NOT_FOUND_ASC',
  MembersNotFoundDesc = 'MEMBERS_NOT_FOUND_DESC',
  MembersSkippedAsc = 'MEMBERS_SKIPPED_ASC',
  MembersSkippedDesc = 'MEMBERS_SKIPPED_DESC',
  MembersTotalAsc = 'MEMBERS_TOTAL_ASC',
  MembersTotalDesc = 'MEMBERS_TOTAL_DESC',
  MembersTotalProcessedAsc = 'MEMBERS_TOTAL_PROCESSED_ASC',
  MembersTotalProcessedDesc = 'MEMBERS_TOTAL_PROCESSED_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  Natural = 'NATURAL',
  NotifyUserIdAsc = 'NOTIFY_USER_ID_ASC',
  NotifyUserIdDesc = 'NOTIFY_USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequestsProcessedAsc = 'REQUESTS_PROCESSED_ASC',
  RequestsProcessedDesc = 'REQUESTS_PROCESSED_DESC',
  RequestsTotalAsc = 'REQUESTS_TOTAL_ASC',
  RequestsTotalDesc = 'REQUESTS_TOTAL_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

export type LevelRoleAverageAggregates = {
  __typename?: 'LevelRoleAverageAggregates';
  /** Mean average of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigFloat']>;
  /** Mean average of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `LevelRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LevelRoleCondition = {
  /** Checks for equality with the object’s `addLevel` field. */
  addLevel?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `removeLevel` field. */
  removeLevel?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']>;
};

export type LevelRoleDistinctCountAggregates = {
  __typename?: 'LevelRoleDistinctCountAggregates';
  /** Distinct count of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `LevelRole` object types. All fields are combined with a logical ‘and.’ */
export type LevelRoleFilter = {
  /** Filter by the object’s `addLevel` field. */
  addLevel?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LevelRoleFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LevelRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LevelRoleFilter>>;
  /** Filter by the object’s `removeLevel` field. */
  removeLevel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `LevelRole` */
export type LevelRoleInput = {
  addLevel?: InputMaybe<Scalars['BigInt']>;
  guildId: Scalars['BigInt'];
  removeLevel?: InputMaybe<Scalars['BigInt']>;
  roleId: Scalars['BigInt'];
};

export type LevelRoleMaxAggregates = {
  __typename?: 'LevelRoleMaxAggregates';
  /** Maximum of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigInt']>;
  /** Maximum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

export type LevelRoleMinAggregates = {
  __typename?: 'LevelRoleMinAggregates';
  /** Minimum of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigInt']>;
  /** Minimum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

export type LevelRoleOverride = Node & {
  __typename?: 'LevelRoleOverride';
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  roleId: Scalars['BigInt'];
  type: LevelRoleOverrideType;
  userId: Scalars['BigInt'];
};

export type LevelRoleOverrideAggregates = {
  __typename?: 'LevelRoleOverrideAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LevelRoleOverrideAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LevelRoleOverrideDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LevelRoleOverrideMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LevelRoleOverrideMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LevelRoleOverrideStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LevelRoleOverrideStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LevelRoleOverrideSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LevelRoleOverrideVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LevelRoleOverrideVarianceSampleAggregates>;
};

export type LevelRoleOverrideAverageAggregates = {
  __typename?: 'LevelRoleOverrideAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `LevelRoleOverride` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LevelRoleOverrideCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<LevelRoleOverrideType>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type LevelRoleOverrideDistinctCountAggregates = {
  __typename?: 'LevelRoleOverrideDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of type across the matching connection */
  type?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `LevelRoleOverride` object types. All fields are combined with a logical ‘and.’ */
export type LevelRoleOverrideFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LevelRoleOverrideFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LevelRoleOverrideFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LevelRoleOverrideFilter>>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<LevelRoleOverrideTypeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `LevelRoleOverride` */
export type LevelRoleOverrideInput = {
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
  type: LevelRoleOverrideType;
  userId: Scalars['BigInt'];
};

export type LevelRoleOverrideMaxAggregates = {
  __typename?: 'LevelRoleOverrideMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type LevelRoleOverrideMinAggregates = {
  __typename?: 'LevelRoleOverrideMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `LevelRoleOverride`. Fields that are set will be updated. */
export type LevelRoleOverridePatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
  type?: InputMaybe<LevelRoleOverrideType>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type LevelRoleOverrideStddevPopulationAggregates = {
  __typename?: 'LevelRoleOverrideStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleOverrideStddevSampleAggregates = {
  __typename?: 'LevelRoleOverrideStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleOverrideSumAggregates = {
  __typename?: 'LevelRoleOverrideSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of roleId across the matching connection */
  roleId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export enum LevelRoleOverrideType {
  Block = 'BLOCK',
  Grant = 'GRANT'
}

/** A filter to be used against LevelRoleOverrideType fields. All fields are combined with a logical ‘and.’ */
export type LevelRoleOverrideTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<LevelRoleOverrideType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<LevelRoleOverrideType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<LevelRoleOverrideType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<LevelRoleOverrideType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<LevelRoleOverrideType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<LevelRoleOverrideType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<LevelRoleOverrideType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<LevelRoleOverrideType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<LevelRoleOverrideType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<LevelRoleOverrideType>>;
};

export type LevelRoleOverrideVariancePopulationAggregates = {
  __typename?: 'LevelRoleOverrideVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleOverrideVarianceSampleAggregates = {
  __typename?: 'LevelRoleOverrideVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `LevelRoleOverride` values. */
export type LevelRoleOverridesConnection = {
  __typename?: 'LevelRoleOverridesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LevelRoleOverrideAggregates>;
  /** A list of edges which contains the `LevelRoleOverride` and cursor to aid in pagination. */
  edges: Array<LevelRoleOverridesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LevelRoleOverrideAggregates>>;
  /** A list of `LevelRoleOverride` objects. */
  nodes: Array<LevelRoleOverride>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LevelRoleOverride` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `LevelRoleOverride` values. */
export type LevelRoleOverridesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LevelRoleOverridesGroupBy>;
  having?: InputMaybe<LevelRoleOverridesHavingInput>;
};

/** A `LevelRoleOverride` edge in the connection. */
export type LevelRoleOverridesEdge = {
  __typename?: 'LevelRoleOverridesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LevelRoleOverride` at the end of the edge. */
  node: LevelRoleOverride;
};

/** Grouping methods for `LevelRoleOverride` for usage during aggregation. */
export enum LevelRoleOverridesGroupBy {
  GuildId = 'GUILD_ID',
  RoleId = 'ROLE_ID',
  Type = 'TYPE',
  UserId = 'USER_ID'
}

export type LevelRoleOverridesHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `LevelRoleOverride` aggregates. */
export type LevelRoleOverridesHavingInput = {
  AND?: InputMaybe<Array<LevelRoleOverridesHavingInput>>;
  OR?: InputMaybe<Array<LevelRoleOverridesHavingInput>>;
  average?: InputMaybe<LevelRoleOverridesHavingAverageInput>;
  distinctCount?: InputMaybe<LevelRoleOverridesHavingDistinctCountInput>;
  max?: InputMaybe<LevelRoleOverridesHavingMaxInput>;
  min?: InputMaybe<LevelRoleOverridesHavingMinInput>;
  stddevPopulation?: InputMaybe<LevelRoleOverridesHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LevelRoleOverridesHavingStddevSampleInput>;
  sum?: InputMaybe<LevelRoleOverridesHavingSumInput>;
  variancePopulation?: InputMaybe<LevelRoleOverridesHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LevelRoleOverridesHavingVarianceSampleInput>;
};

export type LevelRoleOverridesHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRoleOverridesHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `LevelRoleOverride`. */
export enum LevelRoleOverridesOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Represents an update to a `LevelRole`. Fields that are set will be updated. */
export type LevelRolePatch = {
  addLevel?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  removeLevel?: InputMaybe<Scalars['BigInt']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
};

export type LevelRoleStddevPopulationAggregates = {
  __typename?: 'LevelRoleStddevPopulationAggregates';
  /** Population standard deviation of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleStddevSampleAggregates = {
  __typename?: 'LevelRoleStddevSampleAggregates';
  /** Sample standard deviation of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleSumAggregates = {
  __typename?: 'LevelRoleSumAggregates';
  /** Sum of addLevel across the matching connection */
  addLevel: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of removeLevel across the matching connection */
  removeLevel: Scalars['BigFloat'];
  /** Sum of roleId across the matching connection */
  roleId: Scalars['BigFloat'];
};

export type LevelRoleVariancePopulationAggregates = {
  __typename?: 'LevelRoleVariancePopulationAggregates';
  /** Population variance of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigFloat']>;
  /** Population variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type LevelRoleVarianceSampleAggregates = {
  __typename?: 'LevelRoleVarianceSampleAggregates';
  /** Sample variance of addLevel across the matching connection */
  addLevel?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of removeLevel across the matching connection */
  removeLevel?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `LevelRole` values. */
export type LevelRolesConnection = {
  __typename?: 'LevelRolesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LevelRoleAggregates>;
  /** A list of edges which contains the `LevelRole` and cursor to aid in pagination. */
  edges: Array<LevelRolesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LevelRoleAggregates>>;
  /** A list of `LevelRole` objects. */
  nodes: Array<LevelRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LevelRole` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `LevelRole` values. */
export type LevelRolesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LevelRolesGroupBy>;
  having?: InputMaybe<LevelRolesHavingInput>;
};

/** A `LevelRole` edge in the connection. */
export type LevelRolesEdge = {
  __typename?: 'LevelRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `LevelRole` at the end of the edge. */
  node: LevelRole;
};

/** Grouping methods for `LevelRole` for usage during aggregation. */
export enum LevelRolesGroupBy {
  AddLevel = 'ADD_LEVEL',
  GuildId = 'GUILD_ID',
  RemoveLevel = 'REMOVE_LEVEL',
  RoleId = 'ROLE_ID'
}

export type LevelRolesHavingAverageInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingDistinctCountInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `LevelRole` aggregates. */
export type LevelRolesHavingInput = {
  AND?: InputMaybe<Array<LevelRolesHavingInput>>;
  OR?: InputMaybe<Array<LevelRolesHavingInput>>;
  average?: InputMaybe<LevelRolesHavingAverageInput>;
  distinctCount?: InputMaybe<LevelRolesHavingDistinctCountInput>;
  max?: InputMaybe<LevelRolesHavingMaxInput>;
  min?: InputMaybe<LevelRolesHavingMinInput>;
  stddevPopulation?: InputMaybe<LevelRolesHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LevelRolesHavingStddevSampleInput>;
  sum?: InputMaybe<LevelRolesHavingSumInput>;
  variancePopulation?: InputMaybe<LevelRolesHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LevelRolesHavingVarianceSampleInput>;
};

export type LevelRolesHavingMaxInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingMinInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingStddevPopulationInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingStddevSampleInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingSumInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingVariancePopulationInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type LevelRolesHavingVarianceSampleInput = {
  addLevel?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  removeLevel?: InputMaybe<HavingBigintFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `LevelRole`. */
export enum LevelRolesOrderBy {
  AddLevelAsc = 'ADD_LEVEL_ASC',
  AddLevelDesc = 'ADD_LEVEL_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemoveLevelAsc = 'REMOVE_LEVEL_ASC',
  RemoveLevelDesc = 'REMOVE_LEVEL_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC'
}

export enum LevelTimeframe {
  AllTime = 'ALL_TIME',
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK'
}

/** All input for the `logout` mutation. */
export type LogoutInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our `logout` mutation. */
export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type Member = Node & {
  __typename?: 'Member';
  guildId: Scalars['BigInt'];
  joinTime: Scalars['Datetime'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  userId: Scalars['BigInt'];
};

export type MemberAggregates = {
  __typename?: 'MemberAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MemberAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MemberDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MemberMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MemberMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MemberStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MemberStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MemberSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MemberVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MemberVarianceSampleAggregates>;
};

export type MemberAverageAggregates = {
  __typename?: 'MemberAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `Member` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MemberCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `joinTime` field. */
  joinTime?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type MemberDistinctCountAggregates = {
  __typename?: 'MemberDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of joinTime across the matching connection */
  joinTime?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Member` object types. All fields are combined with a logical ‘and.’ */
export type MemberFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MemberFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `joinTime` field. */
  joinTime?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MemberFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MemberFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Member` */
export type MemberInput = {
  guildId: Scalars['BigInt'];
  joinTime: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

export type MemberMaxAggregates = {
  __typename?: 'MemberMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type MemberMinAggregates = {
  __typename?: 'MemberMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Member`. Fields that are set will be updated. */
export type MemberPatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  joinTime?: InputMaybe<Scalars['Datetime']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type MemberStddevPopulationAggregates = {
  __typename?: 'MemberStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MemberStddevSampleAggregates = {
  __typename?: 'MemberStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MemberSumAggregates = {
  __typename?: 'MemberSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type MemberVariancePopulationAggregates = {
  __typename?: 'MemberVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MemberVarianceSampleAggregates = {
  __typename?: 'MemberVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Member` values. */
export type MembersConnection = {
  __typename?: 'MembersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MemberAggregates>;
  /** A list of edges which contains the `Member` and cursor to aid in pagination. */
  edges: Array<MembersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MemberAggregates>>;
  /** A list of `Member` objects. */
  nodes: Array<Member>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Member` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Member` values. */
export type MembersConnectionGroupedAggregatesArgs = {
  groupBy: Array<MembersGroupBy>;
  having?: InputMaybe<MembersHavingInput>;
};

/** A `Member` edge in the connection. */
export type MembersEdge = {
  __typename?: 'MembersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Member` at the end of the edge. */
  node: Member;
};

/** Grouping methods for `Member` for usage during aggregation. */
export enum MembersGroupBy {
  GuildId = 'GUILD_ID',
  JoinTime = 'JOIN_TIME',
  JoinTimeTruncatedToDay = 'JOIN_TIME_TRUNCATED_TO_DAY',
  JoinTimeTruncatedToHour = 'JOIN_TIME_TRUNCATED_TO_HOUR',
  UserId = 'USER_ID'
}

export type MembersHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Member` aggregates. */
export type MembersHavingInput = {
  AND?: InputMaybe<Array<MembersHavingInput>>;
  OR?: InputMaybe<Array<MembersHavingInput>>;
  average?: InputMaybe<MembersHavingAverageInput>;
  distinctCount?: InputMaybe<MembersHavingDistinctCountInput>;
  max?: InputMaybe<MembersHavingMaxInput>;
  min?: InputMaybe<MembersHavingMinInput>;
  stddevPopulation?: InputMaybe<MembersHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MembersHavingStddevSampleInput>;
  sum?: InputMaybe<MembersHavingSumInput>;
  variancePopulation?: InputMaybe<MembersHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MembersHavingVarianceSampleInput>;
};

export type MembersHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MembersHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  joinTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Member`. */
export enum MembersOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  JoinTimeAsc = 'JOIN_TIME_ASC',
  JoinTimeDesc = 'JOIN_TIME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Message = Node & {
  __typename?: 'Message';
  authorId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  content: Scalars['String'];
  created: Scalars['Datetime'];
  guildId: Scalars['BigInt'];
  messageId: Scalars['BigInt'];
  msg: Scalars['JSON'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type MessageAggregates = {
  __typename?: 'MessageAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MessageAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MessageDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MessageMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MessageMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MessageStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MessageStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MessageSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MessageVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MessageVarianceSampleAggregates>;
};

export type MessageAverageAggregates = {
  __typename?: 'MessageAverageAggregates';
  /** Mean average of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageCondition = {
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `channelId` field. */
  channelId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msg` field. */
  msg?: InputMaybe<Scalars['JSON']>;
};

export type MessageDistinctCountAggregates = {
  __typename?: 'MessageDistinctCountAggregates';
  /** Distinct count of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of content across the matching connection */
  content?: Maybe<Scalars['BigInt']>;
  /** Distinct count of created across the matching connection */
  created?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msg across the matching connection */
  msg?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Message` object types. All fields are combined with a logical ‘and.’ */
export type MessageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageFilter>>;
  /** Filter by the object’s `authorId` field. */
  authorId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `channelId` field. */
  channelId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msg` field. */
  msg?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageFilter>>;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  authorId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  content: Scalars['String'];
  created: Scalars['Datetime'];
  guildId: Scalars['BigInt'];
  messageId: Scalars['BigInt'];
  msg: Scalars['JSON'];
};

export type MessageMaxAggregates = {
  __typename?: 'MessageMaxAggregates';
  /** Maximum of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigInt']>;
  /** Maximum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
};

export type MessageMinAggregates = {
  __typename?: 'MessageMinAggregates';
  /** Minimum of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigInt']>;
  /** Minimum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  authorId?: InputMaybe<Scalars['BigInt']>;
  channelId?: InputMaybe<Scalars['BigInt']>;
  content?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  messageId?: InputMaybe<Scalars['BigInt']>;
  msg?: InputMaybe<Scalars['JSON']>;
};

export type MessageStddevPopulationAggregates = {
  __typename?: 'MessageStddevPopulationAggregates';
  /** Population standard deviation of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
};

export type MessageStddevSampleAggregates = {
  __typename?: 'MessageStddevSampleAggregates';
  /** Sample standard deviation of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
};

export type MessageSumAggregates = {
  __typename?: 'MessageSumAggregates';
  /** Sum of authorId across the matching connection */
  authorId: Scalars['BigFloat'];
  /** Sum of channelId across the matching connection */
  channelId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of messageId across the matching connection */
  messageId: Scalars['BigFloat'];
};

export type MessageVariancePopulationAggregates = {
  __typename?: 'MessageVariancePopulationAggregates';
  /** Population variance of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
};

export type MessageVarianceSampleAggregates = {
  __typename?: 'MessageVarianceSampleAggregates';
  /** Sample variance of authorId across the matching connection */
  authorId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of messageId across the matching connection */
  messageId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  __typename?: 'MessagesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MessageAggregates>;
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<MessagesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MessageAggregates>>;
  /** A list of `Message` objects. */
  nodes: Array<Message>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Message` values. */
export type MessagesConnectionGroupedAggregatesArgs = {
  groupBy: Array<MessagesGroupBy>;
  having?: InputMaybe<MessagesHavingInput>;
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  __typename?: 'MessagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Message` at the end of the edge. */
  node: Message;
};

/** Grouping methods for `Message` for usage during aggregation. */
export enum MessagesGroupBy {
  AuthorId = 'AUTHOR_ID',
  ChannelId = 'CHANNEL_ID',
  Content = 'CONTENT',
  Created = 'CREATED',
  CreatedTruncatedToDay = 'CREATED_TRUNCATED_TO_DAY',
  CreatedTruncatedToHour = 'CREATED_TRUNCATED_TO_HOUR',
  GuildId = 'GUILD_ID',
  Msg = 'MSG'
}

export type MessagesHavingAverageInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingDistinctCountInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Message` aggregates. */
export type MessagesHavingInput = {
  AND?: InputMaybe<Array<MessagesHavingInput>>;
  OR?: InputMaybe<Array<MessagesHavingInput>>;
  average?: InputMaybe<MessagesHavingAverageInput>;
  distinctCount?: InputMaybe<MessagesHavingDistinctCountInput>;
  max?: InputMaybe<MessagesHavingMaxInput>;
  min?: InputMaybe<MessagesHavingMinInput>;
  stddevPopulation?: InputMaybe<MessagesHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MessagesHavingStddevSampleInput>;
  sum?: InputMaybe<MessagesHavingSumInput>;
  variancePopulation?: InputMaybe<MessagesHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MessagesHavingVarianceSampleInput>;
};

export type MessagesHavingMaxInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingMinInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingStddevPopulationInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingStddevSampleInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingSumInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingVariancePopulationInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

export type MessagesHavingVarianceSampleInput = {
  authorId?: InputMaybe<HavingBigintFilter>;
  channelId?: InputMaybe<HavingBigintFilter>;
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  messageId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Message`. */
export enum MessagesOrderBy {
  AuthorIdAsc = 'AUTHOR_ID_ASC',
  AuthorIdDesc = 'AUTHOR_ID_DESC',
  ChannelIdAsc = 'CHANNEL_ID_ASC',
  ChannelIdDesc = 'CHANNEL_ID_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  MessageIdAsc = 'MESSAGE_ID_ASC',
  MessageIdDesc = 'MESSAGE_ID_DESC',
  MsgAsc = 'MSG_ASC',
  MsgDesc = 'MSG_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ModLog = Node & {
  __typename?: 'ModLog';
  action: Scalars['String'];
  actionTime: Scalars['Datetime'];
  attachments: Array<Maybe<Scalars['String']>>;
  caseId: Scalars['BigInt'];
  executorId?: Maybe<Scalars['BigInt']>;
  guildId: Scalars['BigInt'];
  msgId?: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `Mute`. */
  mutesByGuildIdAndCaseId: MutesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pending: Scalars['Boolean'];
  reason?: Maybe<Scalars['String']>;
  userId: Scalars['BigInt'];
  userTag: Scalars['String'];
};


export type ModLogMutesByGuildIdAndCaseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MuteCondition>;
  filter?: InputMaybe<MuteFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};

export type ModLogAggregates = {
  __typename?: 'ModLogAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<ModLogAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<ModLogDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<ModLogMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<ModLogMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<ModLogStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<ModLogStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<ModLogSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<ModLogVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<ModLogVarianceSampleAggregates>;
};

export type ModLogAverageAggregates = {
  __typename?: 'ModLogAverageAggregates';
  /** Mean average of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `ModLog` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ModLogCondition = {
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `actionTime` field. */
  actionTime?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `attachments` field. */
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `caseId` field. */
  caseId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `executorId` field. */
  executorId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgId` field. */
  msgId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pending` field. */
  pending?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `reason` field. */
  reason?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `userTag` field. */
  userTag?: InputMaybe<Scalars['String']>;
};

export type ModLogDistinctCountAggregates = {
  __typename?: 'ModLogDistinctCountAggregates';
  /** Distinct count of action across the matching connection */
  action?: Maybe<Scalars['BigInt']>;
  /** Distinct count of actionTime across the matching connection */
  actionTime?: Maybe<Scalars['BigInt']>;
  /** Distinct count of attachments across the matching connection */
  attachments?: Maybe<Scalars['BigInt']>;
  /** Distinct count of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of pending across the matching connection */
  pending?: Maybe<Scalars['BigInt']>;
  /** Distinct count of reason across the matching connection */
  reason?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userTag across the matching connection */
  userTag?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `ModLog` object types. All fields are combined with a logical ‘and.’ */
export type ModLogFilter = {
  /** Filter by the object’s `action` field. */
  action?: InputMaybe<StringFilter>;
  /** Filter by the object’s `actionTime` field. */
  actionTime?: InputMaybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ModLogFilter>>;
  /** Filter by the object’s `attachments` field. */
  attachments?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `caseId` field. */
  caseId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `executorId` field. */
  executorId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msgId` field. */
  msgId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ModLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ModLogFilter>>;
  /** Filter by the object’s `pending` field. */
  pending?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `reason` field. */
  reason?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `userTag` field. */
  userTag?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ModLog` */
export type ModLogInput = {
  action: Scalars['String'];
  actionTime: Scalars['Datetime'];
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  caseId: Scalars['BigInt'];
  executorId?: InputMaybe<Scalars['BigInt']>;
  guildId: Scalars['BigInt'];
  msgId?: InputMaybe<Scalars['BigInt']>;
  pending: Scalars['Boolean'];
  reason?: InputMaybe<Scalars['String']>;
  userId: Scalars['BigInt'];
  userTag: Scalars['String'];
};

export type ModLogMaxAggregates = {
  __typename?: 'ModLogMaxAggregates';
  /** Maximum of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Maximum of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type ModLogMinAggregates = {
  __typename?: 'ModLogMinAggregates';
  /** Minimum of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Minimum of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `ModLog`. Fields that are set will be updated. */
export type ModLogPatch = {
  action?: InputMaybe<Scalars['String']>;
  actionTime?: InputMaybe<Scalars['Datetime']>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  caseId?: InputMaybe<Scalars['BigInt']>;
  executorId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  msgId?: InputMaybe<Scalars['BigInt']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  reason?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
  userTag?: InputMaybe<Scalars['String']>;
};

export type ModLogStddevPopulationAggregates = {
  __typename?: 'ModLogStddevPopulationAggregates';
  /** Population standard deviation of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ModLogStddevSampleAggregates = {
  __typename?: 'ModLogStddevSampleAggregates';
  /** Sample standard deviation of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ModLogSumAggregates = {
  __typename?: 'ModLogSumAggregates';
  /** Sum of caseId across the matching connection */
  caseId: Scalars['BigFloat'];
  /** Sum of executorId across the matching connection */
  executorId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of msgId across the matching connection */
  msgId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type ModLogVariancePopulationAggregates = {
  __typename?: 'ModLogVariancePopulationAggregates';
  /** Population variance of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ModLogVarianceSampleAggregates = {
  __typename?: 'ModLogVarianceSampleAggregates';
  /** Sample variance of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of executorId across the matching connection */
  executorId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgId across the matching connection */
  msgId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `ModLog` values. */
export type ModLogsConnection = {
  __typename?: 'ModLogsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ModLogAggregates>;
  /** A list of edges which contains the `ModLog` and cursor to aid in pagination. */
  edges: Array<ModLogsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ModLogAggregates>>;
  /** A list of `ModLog` objects. */
  nodes: Array<ModLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ModLog` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `ModLog` values. */
export type ModLogsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ModLogsGroupBy>;
  having?: InputMaybe<ModLogsHavingInput>;
};

/** A `ModLog` edge in the connection. */
export type ModLogsEdge = {
  __typename?: 'ModLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ModLog` at the end of the edge. */
  node: ModLog;
};

/** Grouping methods for `ModLog` for usage during aggregation. */
export enum ModLogsGroupBy {
  Action = 'ACTION',
  ActionTime = 'ACTION_TIME',
  ActionTimeTruncatedToDay = 'ACTION_TIME_TRUNCATED_TO_DAY',
  ActionTimeTruncatedToHour = 'ACTION_TIME_TRUNCATED_TO_HOUR',
  Attachments = 'ATTACHMENTS',
  CaseId = 'CASE_ID',
  ExecutorId = 'EXECUTOR_ID',
  GuildId = 'GUILD_ID',
  MsgId = 'MSG_ID',
  Pending = 'PENDING',
  Reason = 'REASON',
  UserId = 'USER_ID',
  UserTag = 'USER_TAG'
}

export type ModLogsHavingAverageInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingDistinctCountInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `ModLog` aggregates. */
export type ModLogsHavingInput = {
  AND?: InputMaybe<Array<ModLogsHavingInput>>;
  OR?: InputMaybe<Array<ModLogsHavingInput>>;
  average?: InputMaybe<ModLogsHavingAverageInput>;
  distinctCount?: InputMaybe<ModLogsHavingDistinctCountInput>;
  max?: InputMaybe<ModLogsHavingMaxInput>;
  min?: InputMaybe<ModLogsHavingMinInput>;
  stddevPopulation?: InputMaybe<ModLogsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<ModLogsHavingStddevSampleInput>;
  sum?: InputMaybe<ModLogsHavingSumInput>;
  variancePopulation?: InputMaybe<ModLogsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<ModLogsHavingVarianceSampleInput>;
};

export type ModLogsHavingMaxInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingMinInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingStddevPopulationInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingStddevSampleInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingSumInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingVariancePopulationInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type ModLogsHavingVarianceSampleInput = {
  actionTime?: InputMaybe<HavingDatetimeFilter>;
  caseId?: InputMaybe<HavingBigintFilter>;
  executorId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  msgId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `ModLog`. */
export enum ModLogsOrderBy {
  ActionAsc = 'ACTION_ASC',
  ActionDesc = 'ACTION_DESC',
  ActionTimeAsc = 'ACTION_TIME_ASC',
  ActionTimeDesc = 'ACTION_TIME_DESC',
  AttachmentsAsc = 'ATTACHMENTS_ASC',
  AttachmentsDesc = 'ATTACHMENTS_DESC',
  CaseIdAsc = 'CASE_ID_ASC',
  CaseIdDesc = 'CASE_ID_DESC',
  ExecutorIdAsc = 'EXECUTOR_ID_ASC',
  ExecutorIdDesc = 'EXECUTOR_ID_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  MsgIdAsc = 'MSG_ID_ASC',
  MsgIdDesc = 'MSG_ID_DESC',
  MutesByGuildIdAndCaseIdAverageCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdAverageCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdAverageEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_END_TIME_ASC',
  MutesByGuildIdAndCaseIdAverageEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_END_TIME_DESC',
  MutesByGuildIdAndCaseIdAverageGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdAverageGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdAveragePendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_PENDING_ASC',
  MutesByGuildIdAndCaseIdAveragePendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_PENDING_DESC',
  MutesByGuildIdAndCaseIdAverageStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_START_TIME_ASC',
  MutesByGuildIdAndCaseIdAverageStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_START_TIME_DESC',
  MutesByGuildIdAndCaseIdAverageUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_USER_ID_ASC',
  MutesByGuildIdAndCaseIdAverageUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_AVERAGE_USER_ID_DESC',
  MutesByGuildIdAndCaseIdCountAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_COUNT_ASC',
  MutesByGuildIdAndCaseIdCountDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_COUNT_DESC',
  MutesByGuildIdAndCaseIdDistinctCountCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdDistinctCountCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdDistinctCountEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_END_TIME_ASC',
  MutesByGuildIdAndCaseIdDistinctCountEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_END_TIME_DESC',
  MutesByGuildIdAndCaseIdDistinctCountGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdDistinctCountGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdDistinctCountPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_PENDING_ASC',
  MutesByGuildIdAndCaseIdDistinctCountPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_PENDING_DESC',
  MutesByGuildIdAndCaseIdDistinctCountStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_START_TIME_ASC',
  MutesByGuildIdAndCaseIdDistinctCountStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_START_TIME_DESC',
  MutesByGuildIdAndCaseIdDistinctCountUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_USER_ID_ASC',
  MutesByGuildIdAndCaseIdDistinctCountUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_DISTINCT_COUNT_USER_ID_DESC',
  MutesByGuildIdAndCaseIdMaxCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdMaxCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdMaxEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_END_TIME_ASC',
  MutesByGuildIdAndCaseIdMaxEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_END_TIME_DESC',
  MutesByGuildIdAndCaseIdMaxGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdMaxGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdMaxPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_PENDING_ASC',
  MutesByGuildIdAndCaseIdMaxPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_PENDING_DESC',
  MutesByGuildIdAndCaseIdMaxStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_START_TIME_ASC',
  MutesByGuildIdAndCaseIdMaxStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_START_TIME_DESC',
  MutesByGuildIdAndCaseIdMaxUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_USER_ID_ASC',
  MutesByGuildIdAndCaseIdMaxUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MAX_USER_ID_DESC',
  MutesByGuildIdAndCaseIdMinCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdMinCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdMinEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_END_TIME_ASC',
  MutesByGuildIdAndCaseIdMinEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_END_TIME_DESC',
  MutesByGuildIdAndCaseIdMinGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdMinGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdMinPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_PENDING_ASC',
  MutesByGuildIdAndCaseIdMinPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_PENDING_DESC',
  MutesByGuildIdAndCaseIdMinStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_START_TIME_ASC',
  MutesByGuildIdAndCaseIdMinStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_START_TIME_DESC',
  MutesByGuildIdAndCaseIdMinUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_USER_ID_ASC',
  MutesByGuildIdAndCaseIdMinUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_MIN_USER_ID_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_END_TIME_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_END_TIME_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_PENDING_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_PENDING_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_START_TIME_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_START_TIME_DESC',
  MutesByGuildIdAndCaseIdStddevPopulationUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_USER_ID_ASC',
  MutesByGuildIdAndCaseIdStddevPopulationUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_POPULATION_USER_ID_DESC',
  MutesByGuildIdAndCaseIdStddevSampleCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdStddevSampleCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdStddevSampleEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_END_TIME_ASC',
  MutesByGuildIdAndCaseIdStddevSampleEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_END_TIME_DESC',
  MutesByGuildIdAndCaseIdStddevSampleGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdStddevSampleGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdStddevSamplePendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_PENDING_ASC',
  MutesByGuildIdAndCaseIdStddevSamplePendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_PENDING_DESC',
  MutesByGuildIdAndCaseIdStddevSampleStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_START_TIME_ASC',
  MutesByGuildIdAndCaseIdStddevSampleStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_START_TIME_DESC',
  MutesByGuildIdAndCaseIdStddevSampleUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_USER_ID_ASC',
  MutesByGuildIdAndCaseIdStddevSampleUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_STDDEV_SAMPLE_USER_ID_DESC',
  MutesByGuildIdAndCaseIdSumCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdSumCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdSumEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_END_TIME_ASC',
  MutesByGuildIdAndCaseIdSumEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_END_TIME_DESC',
  MutesByGuildIdAndCaseIdSumGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdSumGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdSumPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_PENDING_ASC',
  MutesByGuildIdAndCaseIdSumPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_PENDING_DESC',
  MutesByGuildIdAndCaseIdSumStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_START_TIME_ASC',
  MutesByGuildIdAndCaseIdSumStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_START_TIME_DESC',
  MutesByGuildIdAndCaseIdSumUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_USER_ID_ASC',
  MutesByGuildIdAndCaseIdSumUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_SUM_USER_ID_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_END_TIME_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_END_TIME_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationPendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_PENDING_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationPendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_PENDING_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_START_TIME_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_START_TIME_DESC',
  MutesByGuildIdAndCaseIdVariancePopulationUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_USER_ID_ASC',
  MutesByGuildIdAndCaseIdVariancePopulationUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_POPULATION_USER_ID_DESC',
  MutesByGuildIdAndCaseIdVarianceSampleCaseIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_CASE_ID_ASC',
  MutesByGuildIdAndCaseIdVarianceSampleCaseIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_CASE_ID_DESC',
  MutesByGuildIdAndCaseIdVarianceSampleEndTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_END_TIME_ASC',
  MutesByGuildIdAndCaseIdVarianceSampleEndTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_END_TIME_DESC',
  MutesByGuildIdAndCaseIdVarianceSampleGuildIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_GUILD_ID_ASC',
  MutesByGuildIdAndCaseIdVarianceSampleGuildIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_GUILD_ID_DESC',
  MutesByGuildIdAndCaseIdVarianceSamplePendingAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_PENDING_ASC',
  MutesByGuildIdAndCaseIdVarianceSamplePendingDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_PENDING_DESC',
  MutesByGuildIdAndCaseIdVarianceSampleStartTimeAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_START_TIME_ASC',
  MutesByGuildIdAndCaseIdVarianceSampleStartTimeDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_START_TIME_DESC',
  MutesByGuildIdAndCaseIdVarianceSampleUserIdAsc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_USER_ID_ASC',
  MutesByGuildIdAndCaseIdVarianceSampleUserIdDesc = 'MUTES_BY_GUILD_ID_AND_CASE_ID_VARIANCE_SAMPLE_USER_ID_DESC',
  Natural = 'NATURAL',
  PendingAsc = 'PENDING_ASC',
  PendingDesc = 'PENDING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReasonAsc = 'REASON_ASC',
  ReasonDesc = 'REASON_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserTagAsc = 'USER_TAG_ASC',
  UserTagDesc = 'USER_TAG_DESC'
}

export type MsgLogBlock = Node & {
  __typename?: 'MsgLogBlock';
  blockType: MsgLogBlockType;
  channelId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type MsgLogBlockAggregates = {
  __typename?: 'MsgLogBlockAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MsgLogBlockAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MsgLogBlockDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MsgLogBlockMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MsgLogBlockMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MsgLogBlockStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MsgLogBlockStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MsgLogBlockSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MsgLogBlockVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MsgLogBlockVarianceSampleAggregates>;
};

export type MsgLogBlockAverageAggregates = {
  __typename?: 'MsgLogBlockAverageAggregates';
  /** Mean average of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `MsgLogBlock` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MsgLogBlockCondition = {
  /** Checks for equality with the object’s `blockType` field. */
  blockType?: InputMaybe<MsgLogBlockType>;
  /** Checks for equality with the object’s `channelId` field. */
  channelId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
};

export type MsgLogBlockDistinctCountAggregates = {
  __typename?: 'MsgLogBlockDistinctCountAggregates';
  /** Distinct count of blockType across the matching connection */
  blockType?: Maybe<Scalars['BigInt']>;
  /** Distinct count of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `MsgLogBlock` object types. All fields are combined with a logical ‘and.’ */
export type MsgLogBlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MsgLogBlockFilter>>;
  /** Filter by the object’s `blockType` field. */
  blockType?: InputMaybe<MsgLogBlockTypeFilter>;
  /** Filter by the object’s `channelId` field. */
  channelId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MsgLogBlockFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MsgLogBlockFilter>>;
};

/** An input for mutations affecting `MsgLogBlock` */
export type MsgLogBlockInput = {
  blockType: MsgLogBlockType;
  channelId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
};

export type MsgLogBlockMaxAggregates = {
  __typename?: 'MsgLogBlockMaxAggregates';
  /** Maximum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

export type MsgLogBlockMinAggregates = {
  __typename?: 'MsgLogBlockMinAggregates';
  /** Minimum of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `MsgLogBlock`. Fields that are set will be updated. */
export type MsgLogBlockPatch = {
  blockType?: InputMaybe<MsgLogBlockType>;
  channelId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
};

export type MsgLogBlockStddevPopulationAggregates = {
  __typename?: 'MsgLogBlockStddevPopulationAggregates';
  /** Population standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type MsgLogBlockStddevSampleAggregates = {
  __typename?: 'MsgLogBlockStddevSampleAggregates';
  /** Sample standard deviation of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type MsgLogBlockSumAggregates = {
  __typename?: 'MsgLogBlockSumAggregates';
  /** Sum of channelId across the matching connection */
  channelId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
};

export enum MsgLogBlockType {
  All = 'ALL',
  Deletes = 'DELETES',
  Edits = 'EDITS'
}

/** A filter to be used against MsgLogBlockType fields. All fields are combined with a logical ‘and.’ */
export type MsgLogBlockTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<MsgLogBlockType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<MsgLogBlockType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<MsgLogBlockType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<MsgLogBlockType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<MsgLogBlockType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<MsgLogBlockType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<MsgLogBlockType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<MsgLogBlockType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<MsgLogBlockType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<MsgLogBlockType>>;
};

export type MsgLogBlockVariancePopulationAggregates = {
  __typename?: 'MsgLogBlockVariancePopulationAggregates';
  /** Population variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type MsgLogBlockVarianceSampleAggregates = {
  __typename?: 'MsgLogBlockVarianceSampleAggregates';
  /** Sample variance of channelId across the matching connection */
  channelId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `MsgLogBlock` values. */
export type MsgLogBlocksConnection = {
  __typename?: 'MsgLogBlocksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MsgLogBlockAggregates>;
  /** A list of edges which contains the `MsgLogBlock` and cursor to aid in pagination. */
  edges: Array<MsgLogBlocksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MsgLogBlockAggregates>>;
  /** A list of `MsgLogBlock` objects. */
  nodes: Array<MsgLogBlock>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MsgLogBlock` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `MsgLogBlock` values. */
export type MsgLogBlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<MsgLogBlocksGroupBy>;
  having?: InputMaybe<MsgLogBlocksHavingInput>;
};

/** A `MsgLogBlock` edge in the connection. */
export type MsgLogBlocksEdge = {
  __typename?: 'MsgLogBlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MsgLogBlock` at the end of the edge. */
  node: MsgLogBlock;
};

/** Grouping methods for `MsgLogBlock` for usage during aggregation. */
export enum MsgLogBlocksGroupBy {
  BlockType = 'BLOCK_TYPE',
  ChannelId = 'CHANNEL_ID',
  GuildId = 'GUILD_ID'
}

export type MsgLogBlocksHavingAverageInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingDistinctCountInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `MsgLogBlock` aggregates. */
export type MsgLogBlocksHavingInput = {
  AND?: InputMaybe<Array<MsgLogBlocksHavingInput>>;
  OR?: InputMaybe<Array<MsgLogBlocksHavingInput>>;
  average?: InputMaybe<MsgLogBlocksHavingAverageInput>;
  distinctCount?: InputMaybe<MsgLogBlocksHavingDistinctCountInput>;
  max?: InputMaybe<MsgLogBlocksHavingMaxInput>;
  min?: InputMaybe<MsgLogBlocksHavingMinInput>;
  stddevPopulation?: InputMaybe<MsgLogBlocksHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MsgLogBlocksHavingStddevSampleInput>;
  sum?: InputMaybe<MsgLogBlocksHavingSumInput>;
  variancePopulation?: InputMaybe<MsgLogBlocksHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MsgLogBlocksHavingVarianceSampleInput>;
};

export type MsgLogBlocksHavingMaxInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingMinInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingStddevPopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingStddevSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingSumInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingVariancePopulationInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type MsgLogBlocksHavingVarianceSampleInput = {
  channelId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `MsgLogBlock`. */
export enum MsgLogBlocksOrderBy {
  BlockTypeAsc = 'BLOCK_TYPE_ASC',
  BlockTypeDesc = 'BLOCK_TYPE_DESC',
  ChannelIdAsc = 'CHANNEL_ID_ASC',
  ChannelIdDesc = 'CHANNEL_ID_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  addRoleMenuRoles?: Maybe<AddRoleMenuRolesPayload>;
  bulkDeleteModLog?: Maybe<BulkDeleteModLogPayload>;
  bulkUpdateModLogReason?: Maybe<BulkUpdateModLogReasonPayload>;
  /** Creates a single `BotStat`. */
  createBotStat?: Maybe<CreateBotStatPayload>;
  /** Creates a single `CachedGuild`. */
  createCachedGuild?: Maybe<CreateCachedGuildPayload>;
  /** Creates a single `CachedUser`. */
  createCachedUser?: Maybe<CreateCachedUserPayload>;
  /** Creates a single `EmojiStickerStat`. */
  createEmojiStickerStat?: Maybe<CreateEmojiStickerStatPayload>;
  /** Creates a single `Feed`. */
  createFeed?: Maybe<CreateFeedPayload>;
  /** Creates a single `FeedItem`. */
  createFeedItem?: Maybe<CreateFeedItemPayload>;
  /** Creates a single `FeedSubscription`. */
  createFeedSubscription?: Maybe<CreateFeedSubscriptionPayload>;
  /** Creates a single `GuildBan`. */
  createGuildBan?: Maybe<CreateGuildBanPayload>;
  /** Creates a single `GuildConfig`. */
  createGuildConfig?: Maybe<CreateGuildConfigPayload>;
  /** Creates a single `LevelRole`. */
  createLevelRole?: Maybe<CreateLevelRolePayload>;
  /** Creates a single `LevelRoleApplyJob`. */
  createLevelRoleApplyJob?: Maybe<CreateLevelRoleApplyJobPayload>;
  /** Creates a single `LevelRoleOverride`. */
  createLevelRoleOverride?: Maybe<CreateLevelRoleOverridePayload>;
  /** Creates a single `Member`. */
  createMember?: Maybe<CreateMemberPayload>;
  /** Creates a single `Message`. */
  createMessage?: Maybe<CreateMessagePayload>;
  /** Creates a single `ModLog`. */
  createModLog?: Maybe<CreateModLogPayload>;
  /** Creates a single `MsgLogBlock`. */
  createMsgLogBlock?: Maybe<CreateMsgLogBlockPayload>;
  /** Creates a single `Mute`. */
  createMute?: Maybe<CreateMutePayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<CreateNotificationPayload>;
  /** Creates a single `Reminder`. */
  createReminder?: Maybe<CreateReminderPayload>;
  /** Creates a single `RoleMenu`. */
  createRoleMenu?: Maybe<CreateRoleMenuPayload>;
  /** Creates a single `RoleMenuRole`. */
  createRoleMenuRole?: Maybe<CreateRoleMenuRolePayload>;
  /** Creates a single `Tag`. */
  createTag?: Maybe<CreateTagPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserLevel`. */
  createUserLevel?: Maybe<CreateUserLevelPayload>;
  /** Creates a single `WebUser`. */
  createWebUser?: Maybe<CreateWebUserPayload>;
  /** Creates a single `WebUserGuild`. */
  createWebUserGuild?: Maybe<CreateWebUserGuildPayload>;
  /** Creates a single `XpBlock`. */
  createXpBlock?: Maybe<CreateXpBlockPayload>;
  /** Deletes a single `BotStat` using its globally unique id. */
  deleteBotStat?: Maybe<DeleteBotStatPayload>;
  /** Deletes a single `BotStat` using a unique key. */
  deleteBotStatByNameAndCategory?: Maybe<DeleteBotStatPayload>;
  /** Deletes a single `CachedGuild` using its globally unique id. */
  deleteCachedGuild?: Maybe<DeleteCachedGuildPayload>;
  /** Deletes a single `CachedGuild` using a unique key. */
  deleteCachedGuildById?: Maybe<DeleteCachedGuildPayload>;
  /** Deletes a single `CachedUser` using its globally unique id. */
  deleteCachedUser?: Maybe<DeleteCachedUserPayload>;
  /** Deletes a single `CachedUser` using a unique key. */
  deleteCachedUserById?: Maybe<DeleteCachedUserPayload>;
  /** Deletes a single `EmojiStickerStat` using its globally unique id. */
  deleteEmojiStickerStat?: Maybe<DeleteEmojiStickerStatPayload>;
  /** Deletes a single `EmojiStickerStat` using a unique key. */
  deleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Maybe<DeleteEmojiStickerStatPayload>;
  /** Deletes a single `Feed` using its globally unique id. */
  deleteFeed?: Maybe<DeleteFeedPayload>;
  /** Deletes a single `Feed` using a unique key. */
  deleteFeedByFeedId?: Maybe<DeleteFeedPayload>;
  /** Deletes a single `FeedItem` using its globally unique id. */
  deleteFeedItem?: Maybe<DeleteFeedItemPayload>;
  /** Deletes a single `FeedItem` using a unique key. */
  deleteFeedItemByFeedIdAndItemId?: Maybe<DeleteFeedItemPayload>;
  /** Deletes a single `FeedSubscription` using its globally unique id. */
  deleteFeedSubscription?: Maybe<DeleteFeedSubscriptionPayload>;
  /** Deletes a single `FeedSubscription` using a unique key. */
  deleteFeedSubscriptionByFeedIdAndChannelId?: Maybe<DeleteFeedSubscriptionPayload>;
  /** Deletes a single `GuildBan` using its globally unique id. */
  deleteGuildBan?: Maybe<DeleteGuildBanPayload>;
  /** Deletes a single `GuildBan` using a unique key. */
  deleteGuildBanByGuildIdAndUserId?: Maybe<DeleteGuildBanPayload>;
  /** Deletes a single `GuildConfig` using its globally unique id. */
  deleteGuildConfig?: Maybe<DeleteGuildConfigPayload>;
  /** Deletes a single `GuildConfig` using a unique key. */
  deleteGuildConfigById?: Maybe<DeleteGuildConfigPayload>;
  /** Deletes a single `LevelRole` using its globally unique id. */
  deleteLevelRole?: Maybe<DeleteLevelRolePayload>;
  /** Deletes a single `LevelRoleApplyJob` using its globally unique id. */
  deleteLevelRoleApplyJob?: Maybe<DeleteLevelRoleApplyJobPayload>;
  /** Deletes a single `LevelRoleApplyJob` using a unique key. */
  deleteLevelRoleApplyJobByGuildId?: Maybe<DeleteLevelRoleApplyJobPayload>;
  /** Deletes a single `LevelRoleApplyJob` using a unique key. */
  deleteLevelRoleApplyJobByInteractionId?: Maybe<DeleteLevelRoleApplyJobPayload>;
  /** Deletes a single `LevelRole` using a unique key. */
  deleteLevelRoleByGuildIdAndRoleId?: Maybe<DeleteLevelRolePayload>;
  /** Deletes a single `LevelRoleOverride` using its globally unique id. */
  deleteLevelRoleOverride?: Maybe<DeleteLevelRoleOverridePayload>;
  /** Deletes a single `LevelRoleOverride` using a unique key. */
  deleteLevelRoleOverrideByGuildIdAndRoleIdAndUserId?: Maybe<DeleteLevelRoleOverridePayload>;
  /** Deletes a single `Member` using its globally unique id. */
  deleteMember?: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Member` using a unique key. */
  deleteMemberByGuildIdAndUserId?: Maybe<DeleteMemberPayload>;
  /** Deletes a single `Message` using its globally unique id. */
  deleteMessage?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessageByMessageId?: Maybe<DeleteMessagePayload>;
  deleteMessagesBefore?: Maybe<DeleteMessagesBeforePayload>;
  /** Deletes a single `ModLog` using its globally unique id. */
  deleteModLog?: Maybe<DeleteModLogPayload>;
  /** Deletes a single `ModLog` using a unique key. */
  deleteModLogByGuildIdAndCaseId?: Maybe<DeleteModLogPayload>;
  /** Deletes a single `MsgLogBlock` using its globally unique id. */
  deleteMsgLogBlock?: Maybe<DeleteMsgLogBlockPayload>;
  /** Deletes a single `MsgLogBlock` using a unique key. */
  deleteMsgLogBlockByGuildIdAndChannelId?: Maybe<DeleteMsgLogBlockPayload>;
  /** Deletes a single `Mute` using its globally unique id. */
  deleteMute?: Maybe<DeleteMutePayload>;
  /** Deletes a single `Mute` using a unique key. */
  deleteMuteByGuildIdAndUserId?: Maybe<DeleteMutePayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotificationByUserIdAndGuildIdAndKeyword?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Reminder` using its globally unique id. */
  deleteReminder?: Maybe<DeleteReminderPayload>;
  /** Deletes a single `Reminder` using a unique key. */
  deleteReminderByUserIdAndSetAt?: Maybe<DeleteReminderPayload>;
  /** Deletes a single `RoleMenu` using its globally unique id. */
  deleteRoleMenu?: Maybe<DeleteRoleMenuPayload>;
  /** Deletes a single `RoleMenu` using a unique key. */
  deleteRoleMenuByGuildIdAndMenuName?: Maybe<DeleteRoleMenuPayload>;
  /** Deletes a single `RoleMenuRole` using its globally unique id. */
  deleteRoleMenuRole?: Maybe<DeleteRoleMenuRolePayload>;
  /** Deletes a single `RoleMenuRole` using a unique key. */
  deleteRoleMenuRoleByGuildIdAndMenuNameAndRoleId?: Maybe<DeleteRoleMenuRolePayload>;
  deleteRoleMenuRoles?: Maybe<DeleteRoleMenuRolesPayload>;
  /** Deletes a single `Tag` using its globally unique id. */
  deleteTag?: Maybe<DeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTagByGuildIdAndTagName?: Maybe<DeleteTagPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserById?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserLevel` using its globally unique id. */
  deleteUserLevel?: Maybe<DeleteUserLevelPayload>;
  /** Deletes a single `UserLevel` using a unique key. */
  deleteUserLevelByUserIdAndGuildId?: Maybe<DeleteUserLevelPayload>;
  /** Deletes a single `WebUser` using its globally unique id. */
  deleteWebUser?: Maybe<DeleteWebUserPayload>;
  /** Deletes a single `WebUser` using a unique key. */
  deleteWebUserById?: Maybe<DeleteWebUserPayload>;
  /** Deletes a single `WebUserGuild` using its globally unique id. */
  deleteWebUserGuild?: Maybe<DeleteWebUserGuildPayload>;
  /** Deletes a single `WebUserGuild` using a unique key. */
  deleteWebUserGuildByUserIdAndGuildId?: Maybe<DeleteWebUserGuildPayload>;
  /** Deletes a single `XpBlock` using its globally unique id. */
  deleteXpBlock?: Maybe<DeleteXpBlockPayload>;
  /** Deletes a single `XpBlock` using a unique key. */
  deleteXpBlockByGuildIdAndBlockId?: Maybe<DeleteXpBlockPayload>;
  graphql?: Maybe<GraphqlPayload>;
  incrementEmojiStickerStat?: Maybe<IncrementEmojiStickerStatPayload>;
  logout?: Maybe<LogoutPayload>;
  setRoleMenuRoleOrder?: Maybe<SetRoleMenuRoleOrderPayload>;
  /** Updates a single `BotStat` using its globally unique id and a patch. */
  updateBotStat?: Maybe<UpdateBotStatPayload>;
  /** Updates a single `BotStat` using a unique key and a patch. */
  updateBotStatByNameAndCategory?: Maybe<UpdateBotStatPayload>;
  /** Updates a single `CachedGuild` using its globally unique id and a patch. */
  updateCachedGuild?: Maybe<UpdateCachedGuildPayload>;
  /** Updates a single `CachedGuild` using a unique key and a patch. */
  updateCachedGuildById?: Maybe<UpdateCachedGuildPayload>;
  /** Updates a single `CachedUser` using its globally unique id and a patch. */
  updateCachedUser?: Maybe<UpdateCachedUserPayload>;
  /** Updates a single `CachedUser` using a unique key and a patch. */
  updateCachedUserById?: Maybe<UpdateCachedUserPayload>;
  /** Updates a single `EmojiStickerStat` using its globally unique id and a patch. */
  updateEmojiStickerStat?: Maybe<UpdateEmojiStickerStatPayload>;
  /** Updates a single `EmojiStickerStat` using a unique key and a patch. */
  updateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Maybe<UpdateEmojiStickerStatPayload>;
  /** Updates a single `Feed` using its globally unique id and a patch. */
  updateFeed?: Maybe<UpdateFeedPayload>;
  /** Updates a single `Feed` using a unique key and a patch. */
  updateFeedByFeedId?: Maybe<UpdateFeedPayload>;
  /** Updates a single `FeedItem` using its globally unique id and a patch. */
  updateFeedItem?: Maybe<UpdateFeedItemPayload>;
  /** Updates a single `FeedItem` using a unique key and a patch. */
  updateFeedItemByFeedIdAndItemId?: Maybe<UpdateFeedItemPayload>;
  /** Updates a single `FeedSubscription` using its globally unique id and a patch. */
  updateFeedSubscription?: Maybe<UpdateFeedSubscriptionPayload>;
  /** Updates a single `FeedSubscription` using a unique key and a patch. */
  updateFeedSubscriptionByFeedIdAndChannelId?: Maybe<UpdateFeedSubscriptionPayload>;
  /** Updates a single `GuildBan` using its globally unique id and a patch. */
  updateGuildBan?: Maybe<UpdateGuildBanPayload>;
  /** Updates a single `GuildBan` using a unique key and a patch. */
  updateGuildBanByGuildIdAndUserId?: Maybe<UpdateGuildBanPayload>;
  /** Updates a single `GuildConfig` using its globally unique id and a patch. */
  updateGuildConfig?: Maybe<UpdateGuildConfigPayload>;
  /** Updates a single `GuildConfig` using a unique key and a patch. */
  updateGuildConfigById?: Maybe<UpdateGuildConfigPayload>;
  /** Updates a single `LevelRole` using its globally unique id and a patch. */
  updateLevelRole?: Maybe<UpdateLevelRolePayload>;
  /** Updates a single `LevelRoleApplyJob` using its globally unique id and a patch. */
  updateLevelRoleApplyJob?: Maybe<UpdateLevelRoleApplyJobPayload>;
  /** Updates a single `LevelRoleApplyJob` using a unique key and a patch. */
  updateLevelRoleApplyJobByGuildId?: Maybe<UpdateLevelRoleApplyJobPayload>;
  /** Updates a single `LevelRoleApplyJob` using a unique key and a patch. */
  updateLevelRoleApplyJobByInteractionId?: Maybe<UpdateLevelRoleApplyJobPayload>;
  /** Updates a single `LevelRole` using a unique key and a patch. */
  updateLevelRoleByGuildIdAndRoleId?: Maybe<UpdateLevelRolePayload>;
  /** Updates a single `LevelRoleOverride` using its globally unique id and a patch. */
  updateLevelRoleOverride?: Maybe<UpdateLevelRoleOverridePayload>;
  /** Updates a single `LevelRoleOverride` using a unique key and a patch. */
  updateLevelRoleOverrideByGuildIdAndRoleIdAndUserId?: Maybe<UpdateLevelRoleOverridePayload>;
  /** Updates a single `Member` using its globally unique id and a patch. */
  updateMember?: Maybe<UpdateMemberPayload>;
  /** Updates a single `Member` using a unique key and a patch. */
  updateMemberByGuildIdAndUserId?: Maybe<UpdateMemberPayload>;
  /** Updates a single `Message` using its globally unique id and a patch. */
  updateMessage?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessageByMessageId?: Maybe<UpdateMessagePayload>;
  /** Updates a single `ModLog` using its globally unique id and a patch. */
  updateModLog?: Maybe<UpdateModLogPayload>;
  /** Updates a single `ModLog` using a unique key and a patch. */
  updateModLogByGuildIdAndCaseId?: Maybe<UpdateModLogPayload>;
  /** Updates a single `MsgLogBlock` using its globally unique id and a patch. */
  updateMsgLogBlock?: Maybe<UpdateMsgLogBlockPayload>;
  /** Updates a single `MsgLogBlock` using a unique key and a patch. */
  updateMsgLogBlockByGuildIdAndChannelId?: Maybe<UpdateMsgLogBlockPayload>;
  /** Updates a single `Mute` using its globally unique id and a patch. */
  updateMute?: Maybe<UpdateMutePayload>;
  /** Updates a single `Mute` using a unique key and a patch. */
  updateMuteByGuildIdAndUserId?: Maybe<UpdateMutePayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotification?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotificationByUserIdAndGuildIdAndKeyword?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Reminder` using its globally unique id and a patch. */
  updateReminder?: Maybe<UpdateReminderPayload>;
  /** Updates a single `Reminder` using a unique key and a patch. */
  updateReminderByUserIdAndSetAt?: Maybe<UpdateReminderPayload>;
  /** Updates a single `RoleMenu` using its globally unique id and a patch. */
  updateRoleMenu?: Maybe<UpdateRoleMenuPayload>;
  /** Updates a single `RoleMenu` using a unique key and a patch. */
  updateRoleMenuByGuildIdAndMenuName?: Maybe<UpdateRoleMenuPayload>;
  /** Updates a single `RoleMenuRole` using its globally unique id and a patch. */
  updateRoleMenuRole?: Maybe<UpdateRoleMenuRolePayload>;
  /** Updates a single `RoleMenuRole` using a unique key and a patch. */
  updateRoleMenuRoleByGuildIdAndMenuNameAndRoleId?: Maybe<UpdateRoleMenuRolePayload>;
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTag?: Maybe<UpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagByGuildIdAndTagName?: Maybe<UpdateTagPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserById?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserLevel` using its globally unique id and a patch. */
  updateUserLevel?: Maybe<UpdateUserLevelPayload>;
  /** Updates a single `UserLevel` using a unique key and a patch. */
  updateUserLevelByUserIdAndGuildId?: Maybe<UpdateUserLevelPayload>;
  updateUserXp?: Maybe<UpdateUserXpPayload>;
  /** Updates a single `WebUser` using its globally unique id and a patch. */
  updateWebUser?: Maybe<UpdateWebUserPayload>;
  /** Updates a single `WebUser` using a unique key and a patch. */
  updateWebUserById?: Maybe<UpdateWebUserPayload>;
  /** Updates a single `WebUserGuild` using its globally unique id and a patch. */
  updateWebUserGuild?: Maybe<UpdateWebUserGuildPayload>;
  /** Updates a single `WebUserGuild` using a unique key and a patch. */
  updateWebUserGuildByUserIdAndGuildId?: Maybe<UpdateWebUserGuildPayload>;
  /** Updates a single `XpBlock` using its globally unique id and a patch. */
  updateXpBlock?: Maybe<UpdateXpBlockPayload>;
  /** Updates a single `XpBlock` using a unique key and a patch. */
  updateXpBlockByGuildIdAndBlockId?: Maybe<UpdateXpBlockPayload>;
  /** Upserts a single `BotStat`. */
  upsertBotStat?: Maybe<UpsertBotStatPayload>;
  /** Upserts a single `CachedGuild`. */
  upsertCachedGuild?: Maybe<UpsertCachedGuildPayload>;
  /** Upserts a single `CachedUser`. */
  upsertCachedUser?: Maybe<UpsertCachedUserPayload>;
  /** Upserts a single `EmojiStickerStat`. */
  upsertEmojiStickerStat?: Maybe<UpsertEmojiStickerStatPayload>;
  /** Upserts a single `Feed`. */
  upsertFeed?: Maybe<UpsertFeedPayload>;
  /** Upserts a single `FeedItem`. */
  upsertFeedItem?: Maybe<UpsertFeedItemPayload>;
  /** Upserts a single `FeedSubscription`. */
  upsertFeedSubscription?: Maybe<UpsertFeedSubscriptionPayload>;
  /** Upserts a single `GuildBan`. */
  upsertGuildBan?: Maybe<UpsertGuildBanPayload>;
  /** Upserts a single `GuildConfig`. */
  upsertGuildConfig?: Maybe<UpsertGuildConfigPayload>;
  /** Upserts a single `LevelRole`. */
  upsertLevelRole?: Maybe<UpsertLevelRolePayload>;
  /** Upserts a single `LevelRoleApplyJob`. */
  upsertLevelRoleApplyJob?: Maybe<UpsertLevelRoleApplyJobPayload>;
  /** Upserts a single `LevelRoleOverride`. */
  upsertLevelRoleOverride?: Maybe<UpsertLevelRoleOverridePayload>;
  /** Upserts a single `Member`. */
  upsertMember?: Maybe<UpsertMemberPayload>;
  /** Upserts a single `Message`. */
  upsertMessage?: Maybe<UpsertMessagePayload>;
  /** Upserts a single `ModLog`. */
  upsertModLog?: Maybe<UpsertModLogPayload>;
  /** Upserts a single `MsgLogBlock`. */
  upsertMsgLogBlock?: Maybe<UpsertMsgLogBlockPayload>;
  /** Upserts a single `Mute`. */
  upsertMute?: Maybe<UpsertMutePayload>;
  /** Upserts a single `Notification`. */
  upsertNotification?: Maybe<UpsertNotificationPayload>;
  /** Upserts a single `Reminder`. */
  upsertReminder?: Maybe<UpsertReminderPayload>;
  /** Upserts a single `RoleMenu`. */
  upsertRoleMenu?: Maybe<UpsertRoleMenuPayload>;
  /** Upserts a single `RoleMenuRole`. */
  upsertRoleMenuRole?: Maybe<UpsertRoleMenuRolePayload>;
  /** Upserts a single `Tag`. */
  upsertTag?: Maybe<UpsertTagPayload>;
  /** Upserts a single `User`. */
  upsertUser?: Maybe<UpsertUserPayload>;
  /** Upserts a single `UserLevel`. */
  upsertUserLevel?: Maybe<UpsertUserLevelPayload>;
  /** Upserts a single `WebUser`. */
  upsertWebUser?: Maybe<UpsertWebUserPayload>;
  /** Upserts a single `WebUserGuild`. */
  upsertWebUserGuild?: Maybe<UpsertWebUserGuildPayload>;
  /** Upserts a single `XpBlock`. */
  upsertXpBlock?: Maybe<UpsertXpBlockPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAddRoleMenuRolesArgs = {
  input: AddRoleMenuRolesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkDeleteModLogArgs = {
  input: BulkDeleteModLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationBulkUpdateModLogReasonArgs = {
  input: BulkUpdateModLogReasonInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBotStatArgs = {
  input: CreateBotStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCachedGuildArgs = {
  input: CreateCachedGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCachedUserArgs = {
  input: CreateCachedUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEmojiStickerStatArgs = {
  input: CreateEmojiStickerStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFeedArgs = {
  input: CreateFeedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFeedItemArgs = {
  input: CreateFeedItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFeedSubscriptionArgs = {
  input: CreateFeedSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGuildBanArgs = {
  input: CreateGuildBanInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGuildConfigArgs = {
  input: CreateGuildConfigInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLevelRoleArgs = {
  input: CreateLevelRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLevelRoleApplyJobArgs = {
  input: CreateLevelRoleApplyJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLevelRoleOverrideArgs = {
  input: CreateLevelRoleOverrideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMemberArgs = {
  input: CreateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateModLogArgs = {
  input: CreateModLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMsgLogBlockArgs = {
  input: CreateMsgLogBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMuteArgs = {
  input: CreateMuteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationArgs = {
  input: CreateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReminderArgs = {
  input: CreateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleMenuArgs = {
  input: CreateRoleMenuInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRoleMenuRoleArgs = {
  input: CreateRoleMenuRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserLevelArgs = {
  input: CreateUserLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWebUserArgs = {
  input: CreateWebUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWebUserGuildArgs = {
  input: CreateWebUserGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateXpBlockArgs = {
  input: CreateXpBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBotStatArgs = {
  input: DeleteBotStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBotStatByNameAndCategoryArgs = {
  input: DeleteBotStatByNameAndCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCachedGuildArgs = {
  input: DeleteCachedGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCachedGuildByIdArgs = {
  input: DeleteCachedGuildByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCachedUserArgs = {
  input: DeleteCachedUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCachedUserByIdArgs = {
  input: DeleteCachedUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEmojiStickerStatArgs = {
  input: DeleteEmojiStickerStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs = {
  input: DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedArgs = {
  input: DeleteFeedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedByFeedIdArgs = {
  input: DeleteFeedByFeedIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedItemArgs = {
  input: DeleteFeedItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedItemByFeedIdAndItemIdArgs = {
  input: DeleteFeedItemByFeedIdAndItemIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedSubscriptionArgs = {
  input: DeleteFeedSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeedSubscriptionByFeedIdAndChannelIdArgs = {
  input: DeleteFeedSubscriptionByFeedIdAndChannelIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGuildBanArgs = {
  input: DeleteGuildBanInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGuildBanByGuildIdAndUserIdArgs = {
  input: DeleteGuildBanByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGuildConfigArgs = {
  input: DeleteGuildConfigInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGuildConfigByIdArgs = {
  input: DeleteGuildConfigByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleArgs = {
  input: DeleteLevelRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleApplyJobArgs = {
  input: DeleteLevelRoleApplyJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleApplyJobByGuildIdArgs = {
  input: DeleteLevelRoleApplyJobByGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleApplyJobByInteractionIdArgs = {
  input: DeleteLevelRoleApplyJobByInteractionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleByGuildIdAndRoleIdArgs = {
  input: DeleteLevelRoleByGuildIdAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleOverrideArgs = {
  input: DeleteLevelRoleOverrideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs = {
  input: DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberArgs = {
  input: DeleteMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMemberByGuildIdAndUserIdArgs = {
  input: DeleteMemberByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageArgs = {
  input: DeleteMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageByMessageIdArgs = {
  input: DeleteMessageByMessageIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessagesBeforeArgs = {
  input: DeleteMessagesBeforeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteModLogArgs = {
  input: DeleteModLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteModLogByGuildIdAndCaseIdArgs = {
  input: DeleteModLogByGuildIdAndCaseIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMsgLogBlockArgs = {
  input: DeleteMsgLogBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMsgLogBlockByGuildIdAndChannelIdArgs = {
  input: DeleteMsgLogBlockByGuildIdAndChannelIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMuteArgs = {
  input: DeleteMuteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMuteByGuildIdAndUserIdArgs = {
  input: DeleteMuteByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByUserIdAndGuildIdAndKeywordArgs = {
  input: DeleteNotificationByUserIdAndGuildIdAndKeywordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReminderArgs = {
  input: DeleteReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReminderByUserIdAndSetAtArgs = {
  input: DeleteReminderByUserIdAndSetAtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleMenuArgs = {
  input: DeleteRoleMenuInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleMenuByGuildIdAndMenuNameArgs = {
  input: DeleteRoleMenuByGuildIdAndMenuNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleMenuRoleArgs = {
  input: DeleteRoleMenuRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs = {
  input: DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRoleMenuRolesArgs = {
  input: DeleteRoleMenuRolesInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTagArgs = {
  input: DeleteTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTagByGuildIdAndTagNameArgs = {
  input: DeleteTagByGuildIdAndTagNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByIdArgs = {
  input: DeleteUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserLevelArgs = {
  input: DeleteUserLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserLevelByUserIdAndGuildIdArgs = {
  input: DeleteUserLevelByUserIdAndGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebUserArgs = {
  input: DeleteWebUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebUserByIdArgs = {
  input: DeleteWebUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebUserGuildArgs = {
  input: DeleteWebUserGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWebUserGuildByUserIdAndGuildIdArgs = {
  input: DeleteWebUserGuildByUserIdAndGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteXpBlockArgs = {
  input: DeleteXpBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteXpBlockByGuildIdAndBlockIdArgs = {
  input: DeleteXpBlockByGuildIdAndBlockIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGraphqlArgs = {
  input: GraphqlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationIncrementEmojiStickerStatArgs = {
  input: IncrementEmojiStickerStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLogoutArgs = {
  input: LogoutInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSetRoleMenuRoleOrderArgs = {
  input: SetRoleMenuRoleOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBotStatArgs = {
  input: UpdateBotStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBotStatByNameAndCategoryArgs = {
  input: UpdateBotStatByNameAndCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCachedGuildArgs = {
  input: UpdateCachedGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCachedGuildByIdArgs = {
  input: UpdateCachedGuildByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCachedUserArgs = {
  input: UpdateCachedUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCachedUserByIdArgs = {
  input: UpdateCachedUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEmojiStickerStatArgs = {
  input: UpdateEmojiStickerStatInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs = {
  input: UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedArgs = {
  input: UpdateFeedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedByFeedIdArgs = {
  input: UpdateFeedByFeedIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedItemArgs = {
  input: UpdateFeedItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedItemByFeedIdAndItemIdArgs = {
  input: UpdateFeedItemByFeedIdAndItemIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedSubscriptionArgs = {
  input: UpdateFeedSubscriptionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeedSubscriptionByFeedIdAndChannelIdArgs = {
  input: UpdateFeedSubscriptionByFeedIdAndChannelIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGuildBanArgs = {
  input: UpdateGuildBanInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGuildBanByGuildIdAndUserIdArgs = {
  input: UpdateGuildBanByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGuildConfigArgs = {
  input: UpdateGuildConfigInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGuildConfigByIdArgs = {
  input: UpdateGuildConfigByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleArgs = {
  input: UpdateLevelRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleApplyJobArgs = {
  input: UpdateLevelRoleApplyJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleApplyJobByGuildIdArgs = {
  input: UpdateLevelRoleApplyJobByGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleApplyJobByInteractionIdArgs = {
  input: UpdateLevelRoleApplyJobByInteractionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleByGuildIdAndRoleIdArgs = {
  input: UpdateLevelRoleByGuildIdAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleOverrideArgs = {
  input: UpdateLevelRoleOverrideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs = {
  input: UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberArgs = {
  input: UpdateMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMemberByGuildIdAndUserIdArgs = {
  input: UpdateMemberByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageArgs = {
  input: UpdateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageByMessageIdArgs = {
  input: UpdateMessageByMessageIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateModLogArgs = {
  input: UpdateModLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateModLogByGuildIdAndCaseIdArgs = {
  input: UpdateModLogByGuildIdAndCaseIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMsgLogBlockArgs = {
  input: UpdateMsgLogBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMsgLogBlockByGuildIdAndChannelIdArgs = {
  input: UpdateMsgLogBlockByGuildIdAndChannelIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMuteArgs = {
  input: UpdateMuteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMuteByGuildIdAndUserIdArgs = {
  input: UpdateMuteByGuildIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationArgs = {
  input: UpdateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByUserIdAndGuildIdAndKeywordArgs = {
  input: UpdateNotificationByUserIdAndGuildIdAndKeywordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReminderArgs = {
  input: UpdateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReminderByUserIdAndSetAtArgs = {
  input: UpdateReminderByUserIdAndSetAtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleMenuArgs = {
  input: UpdateRoleMenuInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleMenuByGuildIdAndMenuNameArgs = {
  input: UpdateRoleMenuByGuildIdAndMenuNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleMenuRoleArgs = {
  input: UpdateRoleMenuRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs = {
  input: UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTagArgs = {
  input: UpdateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTagByGuildIdAndTagNameArgs = {
  input: UpdateTagByGuildIdAndTagNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByIdArgs = {
  input: UpdateUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserLevelArgs = {
  input: UpdateUserLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserLevelByUserIdAndGuildIdArgs = {
  input: UpdateUserLevelByUserIdAndGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserXpArgs = {
  input: UpdateUserXpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebUserArgs = {
  input: UpdateWebUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebUserByIdArgs = {
  input: UpdateWebUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebUserGuildArgs = {
  input: UpdateWebUserGuildInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWebUserGuildByUserIdAndGuildIdArgs = {
  input: UpdateWebUserGuildByUserIdAndGuildIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateXpBlockArgs = {
  input: UpdateXpBlockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateXpBlockByGuildIdAndBlockIdArgs = {
  input: UpdateXpBlockByGuildIdAndBlockIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertBotStatArgs = {
  input: UpsertBotStatInput;
  where?: InputMaybe<UpsertBotStatWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCachedGuildArgs = {
  input: UpsertCachedGuildInput;
  where?: InputMaybe<UpsertCachedGuildWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertCachedUserArgs = {
  input: UpsertCachedUserInput;
  where?: InputMaybe<UpsertCachedUserWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertEmojiStickerStatArgs = {
  input: UpsertEmojiStickerStatInput;
  where?: InputMaybe<UpsertEmojiStickerStatWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFeedArgs = {
  input: UpsertFeedInput;
  where?: InputMaybe<UpsertFeedWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFeedItemArgs = {
  input: UpsertFeedItemInput;
  where?: InputMaybe<UpsertFeedItemWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertFeedSubscriptionArgs = {
  input: UpsertFeedSubscriptionInput;
  where?: InputMaybe<UpsertFeedSubscriptionWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGuildBanArgs = {
  input: UpsertGuildBanInput;
  where?: InputMaybe<UpsertGuildBanWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertGuildConfigArgs = {
  input: UpsertGuildConfigInput;
  where?: InputMaybe<UpsertGuildConfigWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLevelRoleArgs = {
  input: UpsertLevelRoleInput;
  where?: InputMaybe<UpsertLevelRoleWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLevelRoleApplyJobArgs = {
  input: UpsertLevelRoleApplyJobInput;
  where?: InputMaybe<UpsertLevelRoleApplyJobWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertLevelRoleOverrideArgs = {
  input: UpsertLevelRoleOverrideInput;
  where?: InputMaybe<UpsertLevelRoleOverrideWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMemberArgs = {
  input: UpsertMemberInput;
  where?: InputMaybe<UpsertMemberWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMessageArgs = {
  input: UpsertMessageInput;
  where?: InputMaybe<UpsertMessageWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertModLogArgs = {
  input: UpsertModLogInput;
  where?: InputMaybe<UpsertModLogWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMsgLogBlockArgs = {
  input: UpsertMsgLogBlockInput;
  where?: InputMaybe<UpsertMsgLogBlockWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertMuteArgs = {
  input: UpsertMuteInput;
  where?: InputMaybe<UpsertMuteWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertNotificationArgs = {
  input: UpsertNotificationInput;
  where?: InputMaybe<UpsertNotificationWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertReminderArgs = {
  input: UpsertReminderInput;
  where?: InputMaybe<UpsertReminderWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRoleMenuArgs = {
  input: UpsertRoleMenuInput;
  where?: InputMaybe<UpsertRoleMenuWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertRoleMenuRoleArgs = {
  input: UpsertRoleMenuRoleInput;
  where?: InputMaybe<UpsertRoleMenuRoleWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertTagArgs = {
  input: UpsertTagInput;
  where?: InputMaybe<UpsertTagWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserArgs = {
  input: UpsertUserInput;
  where?: InputMaybe<UpsertUserWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertUserLevelArgs = {
  input: UpsertUserLevelInput;
  where?: InputMaybe<UpsertUserLevelWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWebUserArgs = {
  input: UpsertWebUserInput;
  where?: InputMaybe<UpsertWebUserWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertWebUserGuildArgs = {
  input: UpsertWebUserGuildInput;
  where?: InputMaybe<UpsertWebUserGuildWhere>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertXpBlockArgs = {
  input: UpsertXpBlockInput;
  where?: InputMaybe<UpsertXpBlockWhere>;
};

export type Mute = Node & {
  __typename?: 'Mute';
  caseId?: Maybe<Scalars['BigInt']>;
  endTime?: Maybe<Scalars['Datetime']>;
  guildId: Scalars['BigInt'];
  /** Reads a single `ModLog` that is related to this `Mute`. */
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  pending: Scalars['Boolean'];
  startTime: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

export type MuteAggregates = {
  __typename?: 'MuteAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MuteAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MuteDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MuteMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MuteMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MuteStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MuteStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MuteSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MuteVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MuteVarianceSampleAggregates>;
};

export type MuteAverageAggregates = {
  __typename?: 'MuteAverageAggregates';
  /** Mean average of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `Mute` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MuteCondition = {
  /** Checks for equality with the object’s `caseId` field. */
  caseId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `endTime` field. */
  endTime?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `pending` field. */
  pending?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startTime` field. */
  startTime?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type MuteDistinctCountAggregates = {
  __typename?: 'MuteDistinctCountAggregates';
  /** Distinct count of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of endTime across the matching connection */
  endTime?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of pending across the matching connection */
  pending?: Maybe<Scalars['BigInt']>;
  /** Distinct count of startTime across the matching connection */
  startTime?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Mute` object types. All fields are combined with a logical ‘and.’ */
export type MuteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MuteFilter>>;
  /** Filter by the object’s `caseId` field. */
  caseId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `endTime` field. */
  endTime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MuteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MuteFilter>>;
  /** Filter by the object’s `pending` field. */
  pending?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `startTime` field. */
  startTime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Mute` */
export type MuteInput = {
  caseId?: InputMaybe<Scalars['BigInt']>;
  endTime?: InputMaybe<Scalars['Datetime']>;
  guildId: Scalars['BigInt'];
  pending?: InputMaybe<Scalars['Boolean']>;
  startTime: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

export type MuteMaxAggregates = {
  __typename?: 'MuteMaxAggregates';
  /** Maximum of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type MuteMinAggregates = {
  __typename?: 'MuteMinAggregates';
  /** Minimum of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Mute`. Fields that are set will be updated. */
export type MutePatch = {
  caseId?: InputMaybe<Scalars['BigInt']>;
  endTime?: InputMaybe<Scalars['Datetime']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  startTime?: InputMaybe<Scalars['Datetime']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type MuteStddevPopulationAggregates = {
  __typename?: 'MuteStddevPopulationAggregates';
  /** Population standard deviation of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MuteStddevSampleAggregates = {
  __typename?: 'MuteStddevSampleAggregates';
  /** Sample standard deviation of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MuteSumAggregates = {
  __typename?: 'MuteSumAggregates';
  /** Sum of caseId across the matching connection */
  caseId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type MuteVariancePopulationAggregates = {
  __typename?: 'MuteVariancePopulationAggregates';
  /** Population variance of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type MuteVarianceSampleAggregates = {
  __typename?: 'MuteVarianceSampleAggregates';
  /** Sample variance of caseId across the matching connection */
  caseId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Mute` values. */
export type MutesConnection = {
  __typename?: 'MutesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MuteAggregates>;
  /** A list of edges which contains the `Mute` and cursor to aid in pagination. */
  edges: Array<MutesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MuteAggregates>>;
  /** A list of `Mute` objects. */
  nodes: Array<Mute>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Mute` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Mute` values. */
export type MutesConnectionGroupedAggregatesArgs = {
  groupBy: Array<MutesGroupBy>;
  having?: InputMaybe<MutesHavingInput>;
};

/** A `Mute` edge in the connection. */
export type MutesEdge = {
  __typename?: 'MutesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Mute` at the end of the edge. */
  node: Mute;
};

/** Grouping methods for `Mute` for usage during aggregation. */
export enum MutesGroupBy {
  CaseId = 'CASE_ID',
  EndTime = 'END_TIME',
  EndTimeTruncatedToDay = 'END_TIME_TRUNCATED_TO_DAY',
  EndTimeTruncatedToHour = 'END_TIME_TRUNCATED_TO_HOUR',
  GuildId = 'GUILD_ID',
  Pending = 'PENDING',
  StartTime = 'START_TIME',
  StartTimeTruncatedToDay = 'START_TIME_TRUNCATED_TO_DAY',
  StartTimeTruncatedToHour = 'START_TIME_TRUNCATED_TO_HOUR',
  UserId = 'USER_ID'
}

export type MutesHavingAverageInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingDistinctCountInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Mute` aggregates. */
export type MutesHavingInput = {
  AND?: InputMaybe<Array<MutesHavingInput>>;
  OR?: InputMaybe<Array<MutesHavingInput>>;
  average?: InputMaybe<MutesHavingAverageInput>;
  distinctCount?: InputMaybe<MutesHavingDistinctCountInput>;
  max?: InputMaybe<MutesHavingMaxInput>;
  min?: InputMaybe<MutesHavingMinInput>;
  stddevPopulation?: InputMaybe<MutesHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MutesHavingStddevSampleInput>;
  sum?: InputMaybe<MutesHavingSumInput>;
  variancePopulation?: InputMaybe<MutesHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MutesHavingVarianceSampleInput>;
};

export type MutesHavingMaxInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingMinInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingStddevPopulationInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingStddevSampleInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingSumInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingVariancePopulationInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type MutesHavingVarianceSampleInput = {
  caseId?: InputMaybe<HavingBigintFilter>;
  endTime?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  startTime?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Mute`. */
export enum MutesOrderBy {
  CaseIdAsc = 'CASE_ID_ASC',
  CaseIdDesc = 'CASE_ID_DESC',
  EndTimeAsc = 'END_TIME_ASC',
  EndTimeDesc = 'END_TIME_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PendingAsc = 'PENDING_ASC',
  PendingDesc = 'PENDING_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartTimeAsc = 'START_TIME_ASC',
  StartTimeDesc = 'START_TIME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  guildId: Scalars['BigInt'];
  keyword: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  userId: Scalars['BigInt'];
};

export type NotificationAggregates = {
  __typename?: 'NotificationAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<NotificationAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<NotificationDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<NotificationMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<NotificationMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<NotificationStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<NotificationStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<NotificationSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<NotificationVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<NotificationVarianceSampleAggregates>;
};

export type NotificationAverageAggregates = {
  __typename?: 'NotificationAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `Notification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NotificationCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `keyword` field. */
  keyword?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type NotificationDistinctCountAggregates = {
  __typename?: 'NotificationDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of keyword across the matching connection */
  keyword?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’ */
export type NotificationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `keyword` field. */
  keyword?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NotificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Notification` */
export type NotificationInput = {
  guildId: Scalars['BigInt'];
  keyword: Scalars['String'];
  userId: Scalars['BigInt'];
};

export type NotificationMaxAggregates = {
  __typename?: 'NotificationMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type NotificationMinAggregates = {
  __typename?: 'NotificationMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export type NotificationPatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  keyword?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type NotificationStddevPopulationAggregates = {
  __typename?: 'NotificationStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type NotificationStddevSampleAggregates = {
  __typename?: 'NotificationStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type NotificationSumAggregates = {
  __typename?: 'NotificationSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type NotificationVariancePopulationAggregates = {
  __typename?: 'NotificationVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type NotificationVarianceSampleAggregates = {
  __typename?: 'NotificationVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Notification` values. */
export type NotificationsConnection = {
  __typename?: 'NotificationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<NotificationAggregates>;
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: Array<NotificationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<NotificationAggregates>>;
  /** A list of `Notification` objects. */
  nodes: Array<Notification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Notification` values. */
export type NotificationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<NotificationsGroupBy>;
  having?: InputMaybe<NotificationsHavingInput>;
};

/** A `Notification` edge in the connection. */
export type NotificationsEdge = {
  __typename?: 'NotificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Notification` at the end of the edge. */
  node: Notification;
};

/** Grouping methods for `Notification` for usage during aggregation. */
export enum NotificationsGroupBy {
  GuildId = 'GUILD_ID',
  Keyword = 'KEYWORD',
  UserId = 'USER_ID'
}

export type NotificationsHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Notification` aggregates. */
export type NotificationsHavingInput = {
  AND?: InputMaybe<Array<NotificationsHavingInput>>;
  OR?: InputMaybe<Array<NotificationsHavingInput>>;
  average?: InputMaybe<NotificationsHavingAverageInput>;
  distinctCount?: InputMaybe<NotificationsHavingDistinctCountInput>;
  max?: InputMaybe<NotificationsHavingMaxInput>;
  min?: InputMaybe<NotificationsHavingMinInput>;
  stddevPopulation?: InputMaybe<NotificationsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<NotificationsHavingStddevSampleInput>;
  sum?: InputMaybe<NotificationsHavingSumInput>;
  variancePopulation?: InputMaybe<NotificationsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<NotificationsHavingVarianceSampleInput>;
};

export type NotificationsHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type NotificationsHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Notification`. */
export enum NotificationsOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  KeywordAsc = 'KEYWORD_ASC',
  KeywordDesc = 'KEYWORD_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `String` values. */
export type NotificationsStartingWithConnection = {
  __typename?: 'NotificationsStartingWithConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<NotificationsStartingWithEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `String` edge in the connection. */
export type NotificationsStartingWithEdge = {
  __typename?: 'NotificationsStartingWithEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads and enables pagination through a set of `BotStat`. */
  allBotStats?: Maybe<BotStatsConnection>;
  /** Reads and enables pagination through a set of `EmojiStickerStat`. */
  allEmojiStickerStats?: Maybe<EmojiStickerStatsConnection>;
  /** Reads and enables pagination through a set of `FeedItem`. */
  allFeedItems?: Maybe<FeedItemsConnection>;
  /** Reads and enables pagination through a set of `FeedSubscription`. */
  allFeedSubscriptions?: Maybe<FeedSubscriptionsConnection>;
  /** Reads and enables pagination through a set of `Feed`. */
  allFeeds?: Maybe<FeedsConnection>;
  /** Reads and enables pagination through a set of `GuildBan`. */
  allGuildBans?: Maybe<GuildBansConnection>;
  /** Reads and enables pagination through a set of `GuildConfig`. */
  allGuildConfigs?: Maybe<GuildConfigsConnection>;
  /** Reads and enables pagination through a set of `LevelRoleApplyJob`. */
  allLevelRoleApplyJobs?: Maybe<LevelRoleApplyJobsConnection>;
  /** Reads and enables pagination through a set of `LevelRoleOverride`. */
  allLevelRoleOverrides?: Maybe<LevelRoleOverridesConnection>;
  /** Reads and enables pagination through a set of `LevelRole`. */
  allLevelRoles?: Maybe<LevelRolesConnection>;
  /** Reads and enables pagination through a set of `Member`. */
  allMembers?: Maybe<MembersConnection>;
  /** Reads and enables pagination through a set of `Message`. */
  allMessages?: Maybe<MessagesConnection>;
  /** Reads and enables pagination through a set of `ModLog`. */
  allModLogs?: Maybe<ModLogsConnection>;
  /** Reads and enables pagination through a set of `MsgLogBlock`. */
  allMsgLogBlocks?: Maybe<MsgLogBlocksConnection>;
  /** Reads and enables pagination through a set of `Mute`. */
  allMutes?: Maybe<MutesConnection>;
  /** Reads and enables pagination through a set of `Notification`. */
  allNotifications?: Maybe<NotificationsConnection>;
  allRedisGuildIds: Array<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `Reminder`. */
  allReminders?: Maybe<RemindersConnection>;
  /** Reads and enables pagination through a set of `RoleMenuRole`. */
  allRoleMenuRoles?: Maybe<RoleMenuRolesConnection>;
  /** Reads and enables pagination through a set of `RoleMenu`. */
  allRoleMenus?: Maybe<RoleMenusConnection>;
  /** Reads and enables pagination through a set of `Tag`. */
  allTags?: Maybe<TagsConnection>;
  /** Reads and enables pagination through a set of `UserLevel`. */
  allUserLevels?: Maybe<UserLevelsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  allUsers?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `WebUserGuild`. */
  allWebUserGuilds?: Maybe<WebUserGuildsConnection>;
  /** Reads and enables pagination through a set of `WebUser`. */
  allWebUsers?: Maybe<WebUsersConnection>;
  /** Reads and enables pagination through a set of `XpBlock`. */
  allXpBlocks?: Maybe<XpBlocksConnection>;
  /** Reads a single `BotStat` using its globally unique `ID`. */
  botStat?: Maybe<BotStat>;
  botStatByNameAndCategory?: Maybe<BotStat>;
  /** Reads a single `CachedGuild` using its globally unique `ID`. */
  cachedGuild?: Maybe<CachedGuild>;
  cachedGuildById?: Maybe<CachedGuild>;
  /** Reads a single `CachedUser` using its globally unique `ID`. */
  cachedUser?: Maybe<CachedUser>;
  cachedUserById?: Maybe<CachedUser>;
  /** Handy method to get the current session ID. */
  currentSessionId?: Maybe<Scalars['UUID']>;
  /** The currently logged in user (or null if not logged in). */
  currentUser?: Maybe<WebUser>;
  currentUserDiscordId?: Maybe<Scalars['BigInt']>;
  /** Handy method to get the current user ID for use in RLS policies, etc; in GraphQL, use `currentUser{id}` instead. */
  currentUserId?: Maybe<Scalars['BigInt']>;
  currentUserManagedGuildIds?: Maybe<CurrentUserManagedGuildIdsConnection>;
  /** Reads a single `EmojiStickerStat` using its globally unique `ID`. */
  emojiStickerStat?: Maybe<EmojiStickerStat>;
  emojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Maybe<EmojiStickerStat>;
  /** Reads a single `Feed` using its globally unique `ID`. */
  feed?: Maybe<Feed>;
  feedByFeedId?: Maybe<Feed>;
  /** Reads a single `FeedItem` using its globally unique `ID`. */
  feedItem?: Maybe<FeedItem>;
  feedItemByFeedIdAndItemId?: Maybe<FeedItem>;
  /** Reads a single `FeedSubscription` using its globally unique `ID`. */
  feedSubscription?: Maybe<FeedSubscription>;
  feedSubscriptionByFeedIdAndChannelId?: Maybe<FeedSubscription>;
  /** Reads and enables pagination through a set of `EligibleLevelRole`. */
  getEligibleLevelRoles?: Maybe<EligibleLevelRolesConnection>;
  /** Reads a single `GuildBan` using its globally unique `ID`. */
  guildBan?: Maybe<GuildBan>;
  guildBanByGuildIdAndUserId?: Maybe<GuildBan>;
  /** Reads a single `GuildConfig` using its globally unique `ID`. */
  guildConfig?: Maybe<GuildConfig>;
  guildConfigById?: Maybe<GuildConfig>;
  /** Reads a single `LevelRole` using its globally unique `ID`. */
  levelRole?: Maybe<LevelRole>;
  /** Reads a single `LevelRoleApplyJob` using its globally unique `ID`. */
  levelRoleApplyJob?: Maybe<LevelRoleApplyJob>;
  levelRoleApplyJobByGuildId?: Maybe<LevelRoleApplyJob>;
  levelRoleApplyJobByInteractionId?: Maybe<LevelRoleApplyJob>;
  levelRoleByGuildIdAndRoleId?: Maybe<LevelRole>;
  /** Reads a single `LevelRoleOverride` using its globally unique `ID`. */
  levelRoleOverride?: Maybe<LevelRoleOverride>;
  levelRoleOverrideByGuildIdAndRoleIdAndUserId?: Maybe<LevelRoleOverride>;
  /** Reads a single `Member` using its globally unique `ID`. */
  member?: Maybe<Member>;
  memberByGuildIdAndUserId?: Maybe<Member>;
  /** Reads a single `Message` using its globally unique `ID`. */
  message?: Maybe<Message>;
  messageByMessageId?: Maybe<Message>;
  /** Reads a single `ModLog` using its globally unique `ID`. */
  modLog?: Maybe<ModLog>;
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** Reads a single `MsgLogBlock` using its globally unique `ID`. */
  msgLogBlock?: Maybe<MsgLogBlock>;
  msgLogBlockByGuildIdAndChannelId?: Maybe<MsgLogBlock>;
  /** Reads a single `Mute` using its globally unique `ID`. */
  mute?: Maybe<Mute>;
  muteByGuildIdAndUserId?: Maybe<Mute>;
  nextCaseId?: Maybe<Scalars['BigInt']>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Reads a single `Notification` using its globally unique `ID`. */
  notification?: Maybe<Notification>;
  notificationByUserIdAndGuildIdAndKeyword?: Maybe<Notification>;
  notificationsStartingWith?: Maybe<NotificationsStartingWithConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  randomTag?: Maybe<Tag>;
  redisGuildByGuildId?: Maybe<RedisGuild>;
  /** Reads a single `Reminder` using its globally unique `ID`. */
  reminder?: Maybe<Reminder>;
  reminderByUserIdAndSetAt?: Maybe<Reminder>;
  /** Reads a single `RoleMenu` using its globally unique `ID`. */
  roleMenu?: Maybe<RoleMenu>;
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
  /** Reads a single `RoleMenuRole` using its globally unique `ID`. */
  roleMenuRole?: Maybe<RoleMenuRole>;
  roleMenuRoleByGuildIdAndMenuNameAndRoleId?: Maybe<RoleMenuRole>;
  /** Reads and enables pagination through a set of `ModLog`. */
  searchModLogs?: Maybe<ModLogsConnection>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tag?: Maybe<Tag>;
  tagByGuildIdAndTagName?: Maybe<Tag>;
  /** Leaderboard for given timeframe and optional guild. If guild is null, it is the global leaderboard */
  timeframeUserLevels?: Maybe<TimeframeUserLevelsConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  user?: Maybe<User>;
  userById?: Maybe<User>;
  userGuildRank?: Maybe<UserGuildRankResult>;
  /** Reads a single `UserLevel` using its globally unique `ID`. */
  userLevel?: Maybe<UserLevel>;
  userLevelByUserIdAndGuildId?: Maybe<UserLevel>;
  /** Reads a single `WebUser` using its globally unique `ID`. */
  webUser?: Maybe<WebUser>;
  webUserById?: Maybe<WebUser>;
  /** Reads a single `WebUserGuild` using its globally unique `ID`. */
  webUserGuild?: Maybe<WebUserGuild>;
  webUserGuildByUserIdAndGuildId?: Maybe<WebUserGuild>;
  /** Reads a single `XpBlock` using its globally unique `ID`. */
  xpBlock?: Maybe<XpBlock>;
  xpBlockByGuildIdAndBlockId?: Maybe<XpBlock>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBotStatsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<BotStatCondition>;
  filter?: InputMaybe<BotStatFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BotStatsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllEmojiStickerStatsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<EmojiStickerStatCondition>;
  filter?: InputMaybe<EmojiStickerStatFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EmojiStickerStatsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFeedItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<FeedItemCondition>;
  filter?: InputMaybe<FeedItemFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FeedItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFeedSubscriptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<FeedSubscriptionCondition>;
  filter?: InputMaybe<FeedSubscriptionFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFeedsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<FeedCondition>;
  filter?: InputMaybe<FeedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FeedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGuildBansArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GuildBanCondition>;
  filter?: InputMaybe<GuildBanFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GuildBansOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGuildConfigsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<GuildConfigCondition>;
  filter?: InputMaybe<GuildConfigFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GuildConfigsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLevelRoleApplyJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LevelRoleApplyJobCondition>;
  filter?: InputMaybe<LevelRoleApplyJobFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LevelRoleApplyJobsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLevelRoleOverridesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LevelRoleOverrideCondition>;
  filter?: InputMaybe<LevelRoleOverrideFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LevelRoleOverridesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLevelRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<LevelRoleCondition>;
  filter?: InputMaybe<LevelRoleFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LevelRolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MemberCondition>;
  filter?: InputMaybe<MemberFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllModLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ModLogCondition>;
  filter?: InputMaybe<ModLogFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ModLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMsgLogBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MsgLogBlockCondition>;
  filter?: InputMaybe<MsgLogBlockFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MsgLogBlocksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMutesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<MuteCondition>;
  filter?: InputMaybe<MuteFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRemindersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<ReminderCondition>;
  filter?: InputMaybe<ReminderFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRoleMenuRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoleMenuRoleCondition>;
  filter?: InputMaybe<RoleMenuRoleFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRoleMenusArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoleMenuCondition>;
  filter?: InputMaybe<RoleMenuFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoleMenusOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<TagCondition>;
  filter?: InputMaybe<TagFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUserLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserLevelCondition>;
  filter?: InputMaybe<UserLevelFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWebUserGuildsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<WebUserGuildCondition>;
  filter?: InputMaybe<WebUserGuildFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWebUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<WebUserCondition>;
  filter?: InputMaybe<WebUserFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllXpBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<XpBlockCondition>;
  filter?: InputMaybe<XpBlockFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<XpBlocksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBotStatArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBotStatByNameAndCategoryArgs = {
  category: Scalars['String'];
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCachedGuildArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCachedGuildByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCachedUserArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCachedUserByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserManagedGuildIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<BigIntFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEmojiStickerStatArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs = {
  actionType: EmojiStickerActionType;
  assetId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  time: Scalars['Datetime'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedByFeedIdArgs = {
  feedId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedItemArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedItemByFeedIdAndItemIdArgs = {
  feedId: Scalars['String'];
  itemId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedSubscriptionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeedSubscriptionByFeedIdAndChannelIdArgs = {
  channelId: Scalars['BigInt'];
  feedId: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGetEligibleLevelRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<EligibleLevelRoleFilter>;
  first?: InputMaybe<Scalars['Int']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGuildBanArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGuildBanByGuildIdAndUserIdArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGuildConfigArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGuildConfigByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleApplyJobArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleApplyJobByGuildIdArgs = {
  guildId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleApplyJobByInteractionIdArgs = {
  interactionId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleByGuildIdAndRoleIdArgs = {
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleOverrideArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs = {
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMemberByGuildIdAndUserIdArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByMessageIdArgs = {
  messageId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryModLogArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryModLogByGuildIdAndCaseIdArgs = {
  caseId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMsgLogBlockArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMsgLogBlockByGuildIdAndChannelIdArgs = {
  channelId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMuteArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMuteByGuildIdAndUserIdArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNextCaseIdArgs = {
  guildId?: InputMaybe<Scalars['BigInt']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByUserIdAndGuildIdAndKeywordArgs = {
  guildId: Scalars['BigInt'];
  keyword: Scalars['String'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationsStartingWithArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRandomTagArgs = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  ownerId?: InputMaybe<Scalars['BigInt']>;
  query?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['Boolean']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRedisGuildByGuildIdArgs = {
  guild_id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReminderArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReminderByUserIdAndSetAtArgs = {
  setAt: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleMenuArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleMenuByGuildIdAndMenuNameArgs = {
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleMenuRoleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs = {
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySearchModLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<ModLogFilter>;
  first?: InputMaybe<Scalars['Int']>;
  guildId: Scalars['BigInt'];
  last?: InputMaybe<Scalars['Int']>;
  maxResults?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  searchCaseId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagByGuildIdAndTagNameArgs = {
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTimeframeUserLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  filter?: InputMaybe<TimeframeUserLevelsRecordFilter>;
  first?: InputMaybe<Scalars['Int']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  timeframe?: InputMaybe<LevelTimeframe>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserGuildRankArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserLevelArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserLevelByUserIdAndGuildIdArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebUserArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebUserByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebUserGuildArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWebUserGuildByUserIdAndGuildIdArgs = {
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXpBlockArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryXpBlockByGuildIdAndBlockIdArgs = {
  blockId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
};

export type RedisGuild = {
  __typename?: 'RedisGuild';
  afkChannelId?: Maybe<Scalars['String']>;
  afkTimeout: Scalars['Int'];
  applicationId?: Maybe<Scalars['String']>;
  banner?: Maybe<Scalars['String']>;
  channels?: Maybe<Array<Maybe<Scalars['String']>>>;
  defaultMessageNotifications?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  discoverySplash?: Maybe<Scalars['String']>;
  emojis?: Maybe<Array<Maybe<Scalars['String']>>>;
  explicitContentFilter?: Maybe<Scalars['Int']>;
  features?: Maybe<Array<Maybe<Scalars['String']>>>;
  icon?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  joinedAt?: Maybe<Scalars['String']>;
  large?: Maybe<Scalars['Boolean']>;
  maxMembers?: Maybe<Scalars['Int']>;
  maxVideoChannelUsers?: Maybe<Scalars['Int']>;
  memberCount?: Maybe<Scalars['Int']>;
  members?: Maybe<Array<Maybe<Scalars['String']>>>;
  mfaLevel?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  nsfwLevel: Scalars['Int'];
  ownerId: Scalars['String'];
  preferredLocale?: Maybe<Scalars['String']>;
  premiumSubscriptionCount?: Maybe<Scalars['Int']>;
  premiumTier: Scalars['Int'];
  presences?: Maybe<Array<Maybe<Scalars['String']>>>;
  roles: Array<RedisGuildRole>;
  rulesChannelId?: Maybe<Scalars['String']>;
  splash?: Maybe<Scalars['String']>;
  systemChannelFlags?: Maybe<Scalars['Int']>;
  systemChannelId?: Maybe<Scalars['String']>;
  unavailable?: Maybe<Scalars['Boolean']>;
  vanityUrlCode?: Maybe<Scalars['String']>;
  verificationLevel?: Maybe<Scalars['Int']>;
  voiceStates?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type RedisGuildRole = {
  __typename?: 'RedisGuildRole';
  color: Scalars['Int'];
  hoist: Scalars['Boolean'];
  icon?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  managed: Scalars['Boolean'];
  mentionable: Scalars['Boolean'];
  name: Scalars['String'];
  permissions: Scalars['String'];
  position: Scalars['Int'];
  tags?: Maybe<RedisRoleTags>;
  unicode_emoji?: Maybe<Scalars['String']>;
};

export type RedisRoleTags = {
  __typename?: 'RedisRoleTags';
  bot_id?: Maybe<Scalars['String']>;
  integration_id?: Maybe<Scalars['String']>;
};

export type Reminder = Node & {
  __typename?: 'Reminder';
  description: Scalars['String'];
  expireAt: Scalars['Datetime'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  setAt: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

export type ReminderAggregates = {
  __typename?: 'ReminderAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<ReminderAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<ReminderDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<ReminderMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<ReminderMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<ReminderStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<ReminderStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<ReminderSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<ReminderVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<ReminderVarianceSampleAggregates>;
};

export type ReminderAverageAggregates = {
  __typename?: 'ReminderAverageAggregates';
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `Reminder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReminderCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `expireAt` field. */
  expireAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `setAt` field. */
  setAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type ReminderDistinctCountAggregates = {
  __typename?: 'ReminderDistinctCountAggregates';
  /** Distinct count of description across the matching connection */
  description?: Maybe<Scalars['BigInt']>;
  /** Distinct count of expireAt across the matching connection */
  expireAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of setAt across the matching connection */
  setAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Reminder` object types. All fields are combined with a logical ‘and.’ */
export type ReminderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReminderFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expireAt` field. */
  expireAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReminderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReminderFilter>>;
  /** Filter by the object’s `setAt` field. */
  setAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Reminder` */
export type ReminderInput = {
  description: Scalars['String'];
  expireAt: Scalars['Datetime'];
  setAt: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

export type ReminderMaxAggregates = {
  __typename?: 'ReminderMaxAggregates';
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type ReminderMinAggregates = {
  __typename?: 'ReminderMinAggregates';
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Reminder`. Fields that are set will be updated. */
export type ReminderPatch = {
  description?: InputMaybe<Scalars['String']>;
  expireAt?: InputMaybe<Scalars['Datetime']>;
  setAt?: InputMaybe<Scalars['Datetime']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type ReminderStddevPopulationAggregates = {
  __typename?: 'ReminderStddevPopulationAggregates';
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ReminderStddevSampleAggregates = {
  __typename?: 'ReminderStddevSampleAggregates';
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ReminderSumAggregates = {
  __typename?: 'ReminderSumAggregates';
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type ReminderVariancePopulationAggregates = {
  __typename?: 'ReminderVariancePopulationAggregates';
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type ReminderVarianceSampleAggregates = {
  __typename?: 'ReminderVarianceSampleAggregates';
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Reminder` values. */
export type RemindersConnection = {
  __typename?: 'RemindersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ReminderAggregates>;
  /** A list of edges which contains the `Reminder` and cursor to aid in pagination. */
  edges: Array<RemindersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ReminderAggregates>>;
  /** A list of `Reminder` objects. */
  nodes: Array<Reminder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Reminder` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Reminder` values. */
export type RemindersConnectionGroupedAggregatesArgs = {
  groupBy: Array<RemindersGroupBy>;
  having?: InputMaybe<RemindersHavingInput>;
};

/** A `Reminder` edge in the connection. */
export type RemindersEdge = {
  __typename?: 'RemindersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Reminder` at the end of the edge. */
  node: Reminder;
};

/** Grouping methods for `Reminder` for usage during aggregation. */
export enum RemindersGroupBy {
  Description = 'DESCRIPTION',
  ExpireAt = 'EXPIRE_AT',
  ExpireAtTruncatedToDay = 'EXPIRE_AT_TRUNCATED_TO_DAY',
  ExpireAtTruncatedToHour = 'EXPIRE_AT_TRUNCATED_TO_HOUR',
  SetAt = 'SET_AT',
  SetAtTruncatedToDay = 'SET_AT_TRUNCATED_TO_DAY',
  SetAtTruncatedToHour = 'SET_AT_TRUNCATED_TO_HOUR',
  UserId = 'USER_ID'
}

export type RemindersHavingAverageInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingDistinctCountInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Reminder` aggregates. */
export type RemindersHavingInput = {
  AND?: InputMaybe<Array<RemindersHavingInput>>;
  OR?: InputMaybe<Array<RemindersHavingInput>>;
  average?: InputMaybe<RemindersHavingAverageInput>;
  distinctCount?: InputMaybe<RemindersHavingDistinctCountInput>;
  max?: InputMaybe<RemindersHavingMaxInput>;
  min?: InputMaybe<RemindersHavingMinInput>;
  stddevPopulation?: InputMaybe<RemindersHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<RemindersHavingStddevSampleInput>;
  sum?: InputMaybe<RemindersHavingSumInput>;
  variancePopulation?: InputMaybe<RemindersHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<RemindersHavingVarianceSampleInput>;
};

export type RemindersHavingMaxInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingMinInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingStddevPopulationInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingStddevSampleInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingSumInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingVariancePopulationInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type RemindersHavingVarianceSampleInput = {
  expireAt?: InputMaybe<HavingDatetimeFilter>;
  setAt?: InputMaybe<HavingDatetimeFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Reminder`. */
export enum RemindersOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  ExpireAtAsc = 'EXPIRE_AT_ASC',
  ExpireAtDesc = 'EXPIRE_AT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SetAtAsc = 'SET_AT_ASC',
  SetAtDesc = 'SET_AT_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type RoleMenu = Node & {
  __typename?: 'RoleMenu';
  description?: Maybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  maxCount?: Maybe<Scalars['Int']>;
  menuName: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  requiredRole?: Maybe<Scalars['BigInt']>;
  /** Reads and enables pagination through a set of `RoleMenuRole`. */
  roleMenuRolesByGuildIdAndMenuName: RoleMenuRolesConnection;
};


export type RoleMenuRoleMenuRolesByGuildIdAndMenuNameArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<RoleMenuRoleCondition>;
  filter?: InputMaybe<RoleMenuRoleFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};

export type RoleMenuAggregates = {
  __typename?: 'RoleMenuAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<RoleMenuAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<RoleMenuDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<RoleMenuMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<RoleMenuMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<RoleMenuStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<RoleMenuStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<RoleMenuSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<RoleMenuVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<RoleMenuVarianceSampleAggregates>;
};

export type RoleMenuAverageAggregates = {
  __typename?: 'RoleMenuAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigFloat']>;
  /** Mean average of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `RoleMenu` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RoleMenuCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `maxCount` field. */
  maxCount?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `menuName` field. */
  menuName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `requiredRole` field. */
  requiredRole?: InputMaybe<Scalars['BigInt']>;
};

export type RoleMenuDistinctCountAggregates = {
  __typename?: 'RoleMenuDistinctCountAggregates';
  /** Distinct count of description across the matching connection */
  description?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigInt']>;
  /** Distinct count of menuName across the matching connection */
  menuName?: Maybe<Scalars['BigInt']>;
  /** Distinct count of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `RoleMenu` object types. All fields are combined with a logical ‘and.’ */
export type RoleMenuFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleMenuFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `maxCount` field. */
  maxCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `menuName` field. */
  menuName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleMenuFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleMenuFilter>>;
  /** Filter by the object’s `requiredRole` field. */
  requiredRole?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `RoleMenu` */
export type RoleMenuInput = {
  description?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  maxCount?: InputMaybe<Scalars['Int']>;
  menuName: Scalars['String'];
  requiredRole?: InputMaybe<Scalars['BigInt']>;
};

export type RoleMenuMaxAggregates = {
  __typename?: 'RoleMenuMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['Int']>;
  /** Maximum of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigInt']>;
};

export type RoleMenuMinAggregates = {
  __typename?: 'RoleMenuMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['Int']>;
  /** Minimum of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `RoleMenu`. Fields that are set will be updated. */
export type RoleMenuPatch = {
  description?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  maxCount?: InputMaybe<Scalars['Int']>;
  menuName?: InputMaybe<Scalars['String']>;
  requiredRole?: InputMaybe<Scalars['BigInt']>;
};

export type RoleMenuRole = Node & {
  __typename?: 'RoleMenuRole';
  description?: Maybe<Scalars['String']>;
  emoji?: Maybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  position?: Maybe<Scalars['Int']>;
  roleId: Scalars['BigInt'];
  /** Reads a single `RoleMenu` that is related to this `RoleMenuRole`. */
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
};

export type RoleMenuRoleAggregates = {
  __typename?: 'RoleMenuRoleAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<RoleMenuRoleAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<RoleMenuRoleDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<RoleMenuRoleMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<RoleMenuRoleMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<RoleMenuRoleStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<RoleMenuRoleStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<RoleMenuRoleSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<RoleMenuRoleVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<RoleMenuRoleVarianceSampleAggregates>;
};

export type RoleMenuRoleAverageAggregates = {
  __typename?: 'RoleMenuRoleAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of position across the matching connection */
  position?: Maybe<Scalars['BigFloat']>;
  /** Mean average of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `RoleMenuRole` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RoleMenuRoleCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `emoji` field. */
  emoji?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `menuName` field. */
  menuName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `position` field. */
  position?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['BigInt']>;
};

export type RoleMenuRoleDistinctCountAggregates = {
  __typename?: 'RoleMenuRoleDistinctCountAggregates';
  /** Distinct count of description across the matching connection */
  description?: Maybe<Scalars['BigInt']>;
  /** Distinct count of emoji across the matching connection */
  emoji?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of menuName across the matching connection */
  menuName?: Maybe<Scalars['BigInt']>;
  /** Distinct count of position across the matching connection */
  position?: Maybe<Scalars['BigInt']>;
  /** Distinct count of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `RoleMenuRole` object types. All fields are combined with a logical ‘and.’ */
export type RoleMenuRoleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RoleMenuRoleFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emoji` field. */
  emoji?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `menuName` field. */
  menuName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RoleMenuRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RoleMenuRoleFilter>>;
  /** Filter by the object’s `position` field. */
  position?: InputMaybe<IntFilter>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `RoleMenuRole` */
export type RoleMenuRoleInput = {
  description?: InputMaybe<Scalars['String']>;
  emoji?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  position?: InputMaybe<Scalars['Int']>;
  roleId: Scalars['BigInt'];
};

export type RoleMenuRoleMaxAggregates = {
  __typename?: 'RoleMenuRoleMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of position across the matching connection */
  position?: Maybe<Scalars['Int']>;
  /** Maximum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

export type RoleMenuRoleMinAggregates = {
  __typename?: 'RoleMenuRoleMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of position across the matching connection */
  position?: Maybe<Scalars['Int']>;
  /** Minimum of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `RoleMenuRole`. Fields that are set will be updated. */
export type RoleMenuRolePatch = {
  description?: InputMaybe<Scalars['String']>;
  emoji?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['Int']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
};

export type RoleMenuRoleStddevPopulationAggregates = {
  __typename?: 'RoleMenuRoleStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of position across the matching connection */
  position?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuRoleStddevSampleAggregates = {
  __typename?: 'RoleMenuRoleStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of position across the matching connection */
  position?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuRoleSumAggregates = {
  __typename?: 'RoleMenuRoleSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of position across the matching connection */
  position: Scalars['BigInt'];
  /** Sum of roleId across the matching connection */
  roleId: Scalars['BigFloat'];
};

export type RoleMenuRoleVariancePopulationAggregates = {
  __typename?: 'RoleMenuRoleVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of position across the matching connection */
  position?: Maybe<Scalars['BigFloat']>;
  /** Population variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuRoleVarianceSampleAggregates = {
  __typename?: 'RoleMenuRoleVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of position across the matching connection */
  position?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of roleId across the matching connection */
  roleId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `RoleMenuRole` values. */
export type RoleMenuRolesConnection = {
  __typename?: 'RoleMenuRolesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<RoleMenuRoleAggregates>;
  /** A list of edges which contains the `RoleMenuRole` and cursor to aid in pagination. */
  edges: Array<RoleMenuRolesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<RoleMenuRoleAggregates>>;
  /** A list of `RoleMenuRole` objects. */
  nodes: Array<RoleMenuRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoleMenuRole` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `RoleMenuRole` values. */
export type RoleMenuRolesConnectionGroupedAggregatesArgs = {
  groupBy: Array<RoleMenuRolesGroupBy>;
  having?: InputMaybe<RoleMenuRolesHavingInput>;
};

/** A `RoleMenuRole` edge in the connection. */
export type RoleMenuRolesEdge = {
  __typename?: 'RoleMenuRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RoleMenuRole` at the end of the edge. */
  node: RoleMenuRole;
};

/** Grouping methods for `RoleMenuRole` for usage during aggregation. */
export enum RoleMenuRolesGroupBy {
  Description = 'DESCRIPTION',
  Emoji = 'EMOJI',
  GuildId = 'GUILD_ID',
  MenuName = 'MENU_NAME',
  Position = 'POSITION',
  RoleId = 'ROLE_ID'
}

export type RoleMenuRolesHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `RoleMenuRole` aggregates. */
export type RoleMenuRolesHavingInput = {
  AND?: InputMaybe<Array<RoleMenuRolesHavingInput>>;
  OR?: InputMaybe<Array<RoleMenuRolesHavingInput>>;
  average?: InputMaybe<RoleMenuRolesHavingAverageInput>;
  distinctCount?: InputMaybe<RoleMenuRolesHavingDistinctCountInput>;
  max?: InputMaybe<RoleMenuRolesHavingMaxInput>;
  min?: InputMaybe<RoleMenuRolesHavingMinInput>;
  stddevPopulation?: InputMaybe<RoleMenuRolesHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<RoleMenuRolesHavingStddevSampleInput>;
  sum?: InputMaybe<RoleMenuRolesHavingSumInput>;
  variancePopulation?: InputMaybe<RoleMenuRolesHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<RoleMenuRolesHavingVarianceSampleInput>;
};

export type RoleMenuRolesHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenuRolesHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  position?: InputMaybe<HavingIntFilter>;
  roleId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `RoleMenuRole`. */
export enum RoleMenuRolesOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EmojiAsc = 'EMOJI_ASC',
  EmojiDesc = 'EMOJI_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  MenuNameAsc = 'MENU_NAME_ASC',
  MenuNameDesc = 'MENU_NAME_DESC',
  Natural = 'NATURAL',
  PositionAsc = 'POSITION_ASC',
  PositionDesc = 'POSITION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC'
}

export type RoleMenuStddevPopulationAggregates = {
  __typename?: 'RoleMenuStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuStddevSampleAggregates = {
  __typename?: 'RoleMenuStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuSumAggregates = {
  __typename?: 'RoleMenuSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of maxCount across the matching connection */
  maxCount: Scalars['BigInt'];
  /** Sum of requiredRole across the matching connection */
  requiredRole: Scalars['BigFloat'];
};

export type RoleMenuVariancePopulationAggregates = {
  __typename?: 'RoleMenuVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigFloat']>;
  /** Population variance of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigFloat']>;
};

export type RoleMenuVarianceSampleAggregates = {
  __typename?: 'RoleMenuVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of maxCount across the matching connection */
  maxCount?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of requiredRole across the matching connection */
  requiredRole?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `RoleMenu` values. */
export type RoleMenusConnection = {
  __typename?: 'RoleMenusConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<RoleMenuAggregates>;
  /** A list of edges which contains the `RoleMenu` and cursor to aid in pagination. */
  edges: Array<RoleMenusEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<RoleMenuAggregates>>;
  /** A list of `RoleMenu` objects. */
  nodes: Array<RoleMenu>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RoleMenu` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `RoleMenu` values. */
export type RoleMenusConnectionGroupedAggregatesArgs = {
  groupBy: Array<RoleMenusGroupBy>;
  having?: InputMaybe<RoleMenusHavingInput>;
};

/** A `RoleMenu` edge in the connection. */
export type RoleMenusEdge = {
  __typename?: 'RoleMenusEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `RoleMenu` at the end of the edge. */
  node: RoleMenu;
};

/** Grouping methods for `RoleMenu` for usage during aggregation. */
export enum RoleMenusGroupBy {
  Description = 'DESCRIPTION',
  GuildId = 'GUILD_ID',
  MaxCount = 'MAX_COUNT',
  MenuName = 'MENU_NAME',
  RequiredRole = 'REQUIRED_ROLE'
}

export type RoleMenusHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `RoleMenu` aggregates. */
export type RoleMenusHavingInput = {
  AND?: InputMaybe<Array<RoleMenusHavingInput>>;
  OR?: InputMaybe<Array<RoleMenusHavingInput>>;
  average?: InputMaybe<RoleMenusHavingAverageInput>;
  distinctCount?: InputMaybe<RoleMenusHavingDistinctCountInput>;
  max?: InputMaybe<RoleMenusHavingMaxInput>;
  min?: InputMaybe<RoleMenusHavingMinInput>;
  stddevPopulation?: InputMaybe<RoleMenusHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<RoleMenusHavingStddevSampleInput>;
  sum?: InputMaybe<RoleMenusHavingSumInput>;
  variancePopulation?: InputMaybe<RoleMenusHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<RoleMenusHavingVarianceSampleInput>;
};

export type RoleMenusHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

export type RoleMenusHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  maxCount?: InputMaybe<HavingIntFilter>;
  requiredRole?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `RoleMenu`. */
export enum RoleMenusOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  MaxCountAsc = 'MAX_COUNT_ASC',
  MaxCountDesc = 'MAX_COUNT_DESC',
  MenuNameAsc = 'MENU_NAME_ASC',
  MenuNameDesc = 'MENU_NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequiredRoleAsc = 'REQUIRED_ROLE_ASC',
  RequiredRoleDesc = 'REQUIRED_ROLE_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAverageDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAverageDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAverageEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAverageEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAverageGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAverageGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAverageMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAverageMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAveragePositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAveragePositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameAverageRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameAverageRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_AVERAGE_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameCountAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_COUNT_ASC',
  RoleMenuRolesByGuildIdAndMenuNameCountDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_COUNT_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameDistinctCountRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_DISTINCT_COUNT_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMaxRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMaxRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MAX_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameMinRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameMinRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_MIN_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevPopulationRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_POPULATION_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSamplePositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSamplePositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameStddevSampleRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_STDDEV_SAMPLE_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameSumRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameSumRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_SUM_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationPositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationPositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVariancePopulationRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_POPULATION_ROLE_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleDescriptionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_DESCRIPTION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleDescriptionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_DESCRIPTION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleEmojiAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_EMOJI_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleEmojiDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_EMOJI_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleGuildIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_GUILD_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleGuildIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_GUILD_ID_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleMenuNameAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_MENU_NAME_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleMenuNameDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_MENU_NAME_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSamplePositionAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_POSITION_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSamplePositionDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_POSITION_DESC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleRoleIdAsc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_ROLE_ID_ASC',
  RoleMenuRolesByGuildIdAndMenuNameVarianceSampleRoleIdDesc = 'ROLE_MENU_ROLES_BY_GUILD_ID_AND_MENU_NAME_VARIANCE_SAMPLE_ROLE_ID_DESC'
}

/** All input for the `setRoleMenuRoleOrder` mutation. */
export type SetRoleMenuRoleOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
  roleIds?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
};

/** The output of our `setRoleMenuRoleOrder` mutation. */
export type SetRoleMenuRoleOrderPayload = {
  __typename?: 'SetRoleMenuRoleOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  roleMenuRoles?: Maybe<Array<RoleMenuRole>>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type Tag = Node & {
  __typename?: 'Tag';
  attachment?: Maybe<Scalars['String']>;
  content: Scalars['String'];
  created: Scalars['Datetime'];
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  ownerId: Scalars['BigInt'];
  tagName: Scalars['String'];
  useCount: Scalars['BigInt'];
};

export type TagAggregates = {
  __typename?: 'TagAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<TagAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<TagDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<TagMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<TagMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<TagStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<TagStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<TagSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<TagVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<TagVarianceSampleAggregates>;
};

export type TagAverageAggregates = {
  __typename?: 'TagAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TagCondition = {
  /** Checks for equality with the object’s `attachment` field. */
  attachment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `tagName` field. */
  tagName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `useCount` field. */
  useCount?: InputMaybe<Scalars['BigInt']>;
};

export type TagDistinctCountAggregates = {
  __typename?: 'TagDistinctCountAggregates';
  /** Distinct count of attachment across the matching connection */
  attachment?: Maybe<Scalars['BigInt']>;
  /** Distinct count of content across the matching connection */
  content?: Maybe<Scalars['BigInt']>;
  /** Distinct count of created across the matching connection */
  created?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of tagName across the matching connection */
  tagName?: Maybe<Scalars['BigInt']>;
  /** Distinct count of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’ */
export type TagFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TagFilter>>;
  /** Filter by the object’s `attachment` field. */
  attachment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TagFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TagFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `tagName` field. */
  tagName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `useCount` field. */
  useCount?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  attachment?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  created: Scalars['Datetime'];
  guildId: Scalars['BigInt'];
  ownerId: Scalars['BigInt'];
  tagName: Scalars['String'];
  useCount: Scalars['BigInt'];
};

export type TagMaxAggregates = {
  __typename?: 'TagMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigInt']>;
  /** Maximum of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigInt']>;
};

export type TagMinAggregates = {
  __typename?: 'TagMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigInt']>;
  /** Minimum of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  attachment?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  ownerId?: InputMaybe<Scalars['BigInt']>;
  tagName?: InputMaybe<Scalars['String']>;
  useCount?: InputMaybe<Scalars['BigInt']>;
};

export type TagStddevPopulationAggregates = {
  __typename?: 'TagStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigFloat']>;
};

export type TagStddevSampleAggregates = {
  __typename?: 'TagStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigFloat']>;
};

export type TagSumAggregates = {
  __typename?: 'TagSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of ownerId across the matching connection */
  ownerId: Scalars['BigFloat'];
  /** Sum of useCount across the matching connection */
  useCount: Scalars['BigFloat'];
};

export type TagVariancePopulationAggregates = {
  __typename?: 'TagVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigFloat']>;
};

export type TagVarianceSampleAggregates = {
  __typename?: 'TagVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of ownerId across the matching connection */
  ownerId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of useCount across the matching connection */
  useCount?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `Tag` values. */
export type TagsConnection = {
  __typename?: 'TagsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TagAggregates>;
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: Array<TagsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TagAggregates>>;
  /** A list of `Tag` objects. */
  nodes: Array<Tag>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `Tag` values. */
export type TagsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TagsGroupBy>;
  having?: InputMaybe<TagsHavingInput>;
};

/** A `Tag` edge in the connection. */
export type TagsEdge = {
  __typename?: 'TagsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Tag` at the end of the edge. */
  node: Tag;
};

/** Grouping methods for `Tag` for usage during aggregation. */
export enum TagsGroupBy {
  Attachment = 'ATTACHMENT',
  Content = 'CONTENT',
  Created = 'CREATED',
  CreatedTruncatedToDay = 'CREATED_TRUNCATED_TO_DAY',
  CreatedTruncatedToHour = 'CREATED_TRUNCATED_TO_HOUR',
  GuildId = 'GUILD_ID',
  OwnerId = 'OWNER_ID',
  TagName = 'TAG_NAME',
  UseCount = 'USE_COUNT'
}

export type TagsHavingAverageInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingDistinctCountInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `Tag` aggregates. */
export type TagsHavingInput = {
  AND?: InputMaybe<Array<TagsHavingInput>>;
  OR?: InputMaybe<Array<TagsHavingInput>>;
  average?: InputMaybe<TagsHavingAverageInput>;
  distinctCount?: InputMaybe<TagsHavingDistinctCountInput>;
  max?: InputMaybe<TagsHavingMaxInput>;
  min?: InputMaybe<TagsHavingMinInput>;
  stddevPopulation?: InputMaybe<TagsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<TagsHavingStddevSampleInput>;
  sum?: InputMaybe<TagsHavingSumInput>;
  variancePopulation?: InputMaybe<TagsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<TagsHavingVarianceSampleInput>;
};

export type TagsHavingMaxInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingMinInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingStddevPopulationInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingStddevSampleInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingSumInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingVariancePopulationInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

export type TagsHavingVarianceSampleInput = {
  created?: InputMaybe<HavingDatetimeFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
  ownerId?: InputMaybe<HavingBigintFilter>;
  useCount?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `Tag`. */
export enum TagsOrderBy {
  AttachmentAsc = 'ATTACHMENT_ASC',
  AttachmentDesc = 'ATTACHMENT_DESC',
  ContentAsc = 'CONTENT_ASC',
  ContentDesc = 'CONTENT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TagNameAsc = 'TAG_NAME_ASC',
  TagNameDesc = 'TAG_NAME_DESC',
  UseCountAsc = 'USE_COUNT_ASC',
  UseCountDesc = 'USE_COUNT_DESC'
}

/** A `TimeframeUserLevelsRecord` edge in the connection. */
export type TimeframeUserLevelEdge = {
  __typename?: 'TimeframeUserLevelEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TimeframeUserLevelsRecord` at the end of the edge. */
  node: TimeframeUserLevelsRecord;
};

/** A connection to a list of `TimeframeUserLevelsRecord` values. */
export type TimeframeUserLevelsConnection = {
  __typename?: 'TimeframeUserLevelsConnection';
  /** A list of edges which contains the `TimeframeUserLevelsRecord` and cursor to aid in pagination. */
  edges: Array<TimeframeUserLevelEdge>;
  /** A list of `TimeframeUserLevelsRecord` objects. */
  nodes: Array<TimeframeUserLevelsRecord>;
  /** The count of *all* `TimeframeUserLevelsRecord` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** The return type of our `timeframeUserLevels` query. */
export type TimeframeUserLevelsRecord = {
  __typename?: 'TimeframeUserLevelsRecord';
  avatarUrl?: Maybe<Scalars['String']>;
  currentLevel?: Maybe<Scalars['BigInt']>;
  discriminator?: Maybe<Scalars['Int']>;
  gainedLevels?: Maybe<Scalars['BigInt']>;
  nextLevelXpProgress?: Maybe<Scalars['BigInt']>;
  nextLevelXpRequired?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['BigInt']>;
  username?: Maybe<Scalars['String']>;
  xp?: Maybe<Scalars['BigInt']>;
  xpDiff?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `TimeframeUserLevelsRecord` object types. All fields are combined with a logical ‘and.’ */
export type TimeframeUserLevelsRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TimeframeUserLevelsRecordFilter>>;
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `currentLevel` field. */
  currentLevel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `discriminator` field. */
  discriminator?: InputMaybe<IntFilter>;
  /** Filter by the object’s `gainedLevels` field. */
  gainedLevels?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `nextLevelXpProgress` field. */
  nextLevelXpProgress?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `nextLevelXpRequired` field. */
  nextLevelXpRequired?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TimeframeUserLevelsRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TimeframeUserLevelsRecordFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
  /** Filter by the object’s `xp` field. */
  xp?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `xpDiff` field. */
  xpDiff?: InputMaybe<BigIntFilter>;
};

/** All input for the `updateBotStatByNameAndCategory` mutation. */
export type UpdateBotStatByNameAndCategoryInput = {
  /** An object where the defined keys will be set on the `BotStat` being updated. */
  botStatPatch: BotStatPatch;
  category: Scalars['String'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `updateBotStat` mutation. */
export type UpdateBotStatInput = {
  /** An object where the defined keys will be set on the `BotStat` being updated. */
  botStatPatch: BotStatPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BotStat` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `BotStat` mutation. */
export type UpdateBotStatPayload = {
  __typename?: 'UpdateBotStatPayload';
  /** The `BotStat` that was updated by this mutation. */
  botStat?: Maybe<BotStat>;
  /** An edge for our `BotStat`. May be used by Relay 1. */
  botStatEdge?: Maybe<BotStatsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `BotStat` mutation. */
export type UpdateBotStatPayloadBotStatEdgeArgs = {
  orderBy?: InputMaybe<Array<BotStatsOrderBy>>;
};

/** All input for the `updateCachedGuildById` mutation. */
export type UpdateCachedGuildByIdInput = {
  /** An object where the defined keys will be set on the `CachedGuild` being updated. */
  cachedGuildPatch: CachedGuildPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `updateCachedGuild` mutation. */
export type UpdateCachedGuildInput = {
  /** An object where the defined keys will be set on the `CachedGuild` being updated. */
  cachedGuildPatch: CachedGuildPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CachedGuild` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `CachedGuild` mutation. */
export type UpdateCachedGuildPayload = {
  __typename?: 'UpdateCachedGuildPayload';
  /** The `CachedGuild` that was updated by this mutation. */
  cachedGuild?: Maybe<CachedGuild>;
  /** An edge for our `CachedGuild`. May be used by Relay 1. */
  cachedGuildEdge?: Maybe<CachedGuildsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `CachedGuild` mutation. */
export type UpdateCachedGuildPayloadCachedGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedGuildsOrderBy>>;
};

/** All input for the `updateCachedUserById` mutation. */
export type UpdateCachedUserByIdInput = {
  /** An object where the defined keys will be set on the `CachedUser` being updated. */
  cachedUserPatch: CachedUserPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** All input for the `updateCachedUser` mutation. */
export type UpdateCachedUserInput = {
  /** An object where the defined keys will be set on the `CachedUser` being updated. */
  cachedUserPatch: CachedUserPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CachedUser` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `CachedUser` mutation. */
export type UpdateCachedUserPayload = {
  __typename?: 'UpdateCachedUserPayload';
  /** The `CachedUser` that was updated by this mutation. */
  cachedUser?: Maybe<CachedUser>;
  /** An edge for our `CachedUser`. May be used by Relay 1. */
  cachedUserEdge?: Maybe<CachedUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `CachedUser` mutation. */
export type UpdateCachedUserPayloadCachedUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedUsersOrderBy>>;
};

/** All input for the `updateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType` mutation. */
export type UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput = {
  actionType: EmojiStickerActionType;
  assetId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EmojiStickerStat` being updated. */
  emojiStickerStatPatch: EmojiStickerStatPatch;
  guildId: Scalars['BigInt'];
  time: Scalars['Datetime'];
};

/** All input for the `updateEmojiStickerStat` mutation. */
export type UpdateEmojiStickerStatInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EmojiStickerStat` being updated. */
  emojiStickerStatPatch: EmojiStickerStatPatch;
  /** The globally unique `ID` which will identify a single `EmojiStickerStat` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `EmojiStickerStat` mutation. */
export type UpdateEmojiStickerStatPayload = {
  __typename?: 'UpdateEmojiStickerStatPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EmojiStickerStat` that was updated by this mutation. */
  emojiStickerStat?: Maybe<EmojiStickerStat>;
  /** An edge for our `EmojiStickerStat`. May be used by Relay 1. */
  emojiStickerStatEdge?: Maybe<EmojiStickerStatsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `EmojiStickerStat` mutation. */
export type UpdateEmojiStickerStatPayloadEmojiStickerStatEdgeArgs = {
  orderBy?: InputMaybe<Array<EmojiStickerStatsOrderBy>>;
};

/** All input for the `updateFeedByFeedId` mutation. */
export type UpdateFeedByFeedIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
  /** An object where the defined keys will be set on the `Feed` being updated. */
  feedPatch: FeedPatch;
};

/** All input for the `updateFeed` mutation. */
export type UpdateFeedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Feed` being updated. */
  feedPatch: FeedPatch;
  /** The globally unique `ID` which will identify a single `Feed` to be updated. */
  nodeId: Scalars['ID'];
};

/** All input for the `updateFeedItemByFeedIdAndItemId` mutation. */
export type UpdateFeedItemByFeedIdAndItemIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
  /** An object where the defined keys will be set on the `FeedItem` being updated. */
  feedItemPatch: FeedItemPatch;
  itemId: Scalars['String'];
};

/** All input for the `updateFeedItem` mutation. */
export type UpdateFeedItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FeedItem` being updated. */
  feedItemPatch: FeedItemPatch;
  /** The globally unique `ID` which will identify a single `FeedItem` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `FeedItem` mutation. */
export type UpdateFeedItemPayload = {
  __typename?: 'UpdateFeedItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FeedItem` that was updated by this mutation. */
  feedItem?: Maybe<FeedItem>;
  /** An edge for our `FeedItem`. May be used by Relay 1. */
  feedItemEdge?: Maybe<FeedItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FeedItem` mutation. */
export type UpdateFeedItemPayloadFeedItemEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedItemsOrderBy>>;
};

/** The output of our update `Feed` mutation. */
export type UpdateFeedPayload = {
  __typename?: 'UpdateFeedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feed` that was updated by this mutation. */
  feed?: Maybe<Feed>;
  /** An edge for our `Feed`. May be used by Relay 1. */
  feedEdge?: Maybe<FeedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Feed` mutation. */
export type UpdateFeedPayloadFeedEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedsOrderBy>>;
};

/** All input for the `updateFeedSubscriptionByFeedIdAndChannelId` mutation. */
export type UpdateFeedSubscriptionByFeedIdAndChannelIdInput = {
  channelId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  feedId: Scalars['String'];
  /** An object where the defined keys will be set on the `FeedSubscription` being updated. */
  feedSubscriptionPatch: FeedSubscriptionPatch;
};

/** All input for the `updateFeedSubscription` mutation. */
export type UpdateFeedSubscriptionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FeedSubscription` being updated. */
  feedSubscriptionPatch: FeedSubscriptionPatch;
  /** The globally unique `ID` which will identify a single `FeedSubscription` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `FeedSubscription` mutation. */
export type UpdateFeedSubscriptionPayload = {
  __typename?: 'UpdateFeedSubscriptionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Feed` that is related to this `FeedSubscription`. */
  feedByFeedId?: Maybe<Feed>;
  /** The `FeedSubscription` that was updated by this mutation. */
  feedSubscription?: Maybe<FeedSubscription>;
  /** An edge for our `FeedSubscription`. May be used by Relay 1. */
  feedSubscriptionEdge?: Maybe<FeedSubscriptionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FeedSubscription` mutation. */
export type UpdateFeedSubscriptionPayloadFeedSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};

/** All input for the `updateGuildBanByGuildIdAndUserId` mutation. */
export type UpdateGuildBanByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GuildBan` being updated. */
  guildBanPatch: GuildBanPatch;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `updateGuildBan` mutation. */
export type UpdateGuildBanInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GuildBan` being updated. */
  guildBanPatch: GuildBanPatch;
  /** The globally unique `ID` which will identify a single `GuildBan` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `GuildBan` mutation. */
export type UpdateGuildBanPayload = {
  __typename?: 'UpdateGuildBanPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildBan` that was updated by this mutation. */
  guildBan?: Maybe<GuildBan>;
  /** An edge for our `GuildBan`. May be used by Relay 1. */
  guildBanEdge?: Maybe<GuildBansEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `GuildBan` mutation. */
export type UpdateGuildBanPayloadGuildBanEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildBansOrderBy>>;
};

/** All input for the `updateGuildConfigById` mutation. */
export type UpdateGuildConfigByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GuildConfig` being updated. */
  guildConfigPatch: GuildConfigPatch;
  id: Scalars['BigInt'];
};

/** All input for the `updateGuildConfig` mutation. */
export type UpdateGuildConfigInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GuildConfig` being updated. */
  guildConfigPatch: GuildConfigPatch;
  /** The globally unique `ID` which will identify a single `GuildConfig` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `GuildConfig` mutation. */
export type UpdateGuildConfigPayload = {
  __typename?: 'UpdateGuildConfigPayload';
  /** Reads a single `CachedGuild` that is related to this `GuildConfig`. */
  cachedGuildById?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildConfig` that was updated by this mutation. */
  guildConfig?: Maybe<GuildConfig>;
  /** An edge for our `GuildConfig`. May be used by Relay 1. */
  guildConfigEdge?: Maybe<GuildConfigsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `GuildConfig` mutation. */
export type UpdateGuildConfigPayloadGuildConfigEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildConfigsOrderBy>>;
};

/** All input for the `updateLevelRoleApplyJobByGuildId` mutation. */
export type UpdateLevelRoleApplyJobByGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `LevelRoleApplyJob` being updated. */
  levelRoleApplyJobPatch: LevelRoleApplyJobPatch;
};

/** All input for the `updateLevelRoleApplyJobByInteractionId` mutation. */
export type UpdateLevelRoleApplyJobByInteractionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  interactionId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `LevelRoleApplyJob` being updated. */
  levelRoleApplyJobPatch: LevelRoleApplyJobPatch;
};

/** All input for the `updateLevelRoleApplyJob` mutation. */
export type UpdateLevelRoleApplyJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LevelRoleApplyJob` being updated. */
  levelRoleApplyJobPatch: LevelRoleApplyJobPatch;
  /** The globally unique `ID` which will identify a single `LevelRoleApplyJob` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `LevelRoleApplyJob` mutation. */
export type UpdateLevelRoleApplyJobPayload = {
  __typename?: 'UpdateLevelRoleApplyJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleApplyJob` that was updated by this mutation. */
  levelRoleApplyJob?: Maybe<LevelRoleApplyJob>;
  /** An edge for our `LevelRoleApplyJob`. May be used by Relay 1. */
  levelRoleApplyJobEdge?: Maybe<LevelRoleApplyJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LevelRoleApplyJob` mutation. */
export type UpdateLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleApplyJobsOrderBy>>;
};

/** All input for the `updateLevelRoleByGuildIdAndRoleId` mutation. */
export type UpdateLevelRoleByGuildIdAndRoleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `LevelRole` being updated. */
  levelRolePatch: LevelRolePatch;
  roleId: Scalars['BigInt'];
};

/** All input for the `updateLevelRole` mutation. */
export type UpdateLevelRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LevelRole` being updated. */
  levelRolePatch: LevelRolePatch;
  /** The globally unique `ID` which will identify a single `LevelRole` to be updated. */
  nodeId: Scalars['ID'];
};

/** All input for the `updateLevelRoleOverrideByGuildIdAndRoleIdAndUserId` mutation. */
export type UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `LevelRoleOverride` being updated. */
  levelRoleOverridePatch: LevelRoleOverridePatch;
  roleId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

/** All input for the `updateLevelRoleOverride` mutation. */
export type UpdateLevelRoleOverrideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LevelRoleOverride` being updated. */
  levelRoleOverridePatch: LevelRoleOverridePatch;
  /** The globally unique `ID` which will identify a single `LevelRoleOverride` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `LevelRoleOverride` mutation. */
export type UpdateLevelRoleOverridePayload = {
  __typename?: 'UpdateLevelRoleOverridePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleOverride` that was updated by this mutation. */
  levelRoleOverride?: Maybe<LevelRoleOverride>;
  /** An edge for our `LevelRoleOverride`. May be used by Relay 1. */
  levelRoleOverrideEdge?: Maybe<LevelRoleOverridesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LevelRoleOverride` mutation. */
export type UpdateLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleOverridesOrderBy>>;
};

/** The output of our update `LevelRole` mutation. */
export type UpdateLevelRolePayload = {
  __typename?: 'UpdateLevelRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRole` that was updated by this mutation. */
  levelRole?: Maybe<LevelRole>;
  /** An edge for our `LevelRole`. May be used by Relay 1. */
  levelRoleEdge?: Maybe<LevelRolesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LevelRole` mutation. */
export type UpdateLevelRolePayloadLevelRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRolesOrderBy>>;
};

/** All input for the `updateMemberByGuildIdAndUserId` mutation. */
export type UpdateMemberByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Member` being updated. */
  memberPatch: MemberPatch;
  userId: Scalars['BigInt'];
};

/** All input for the `updateMember` mutation. */
export type UpdateMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Member` being updated. */
  memberPatch: MemberPatch;
  /** The globally unique `ID` which will identify a single `Member` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `Member` mutation. */
export type UpdateMemberPayload = {
  __typename?: 'UpdateMemberPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` that was updated by this mutation. */
  member?: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Member` mutation. */
export type UpdateMemberPayloadMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};

/** All input for the `updateMessageByMessageId` mutation. */
export type UpdateMessageByMessageIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  messageId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
};

/** All input for the `updateMessage` mutation. */
export type UpdateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
  /** The globally unique `ID` which will identify a single `Message` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `Message` mutation. */
export type UpdateMessagePayload = {
  __typename?: 'UpdateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was updated by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Message` mutation. */
export type UpdateMessagePayloadMessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `updateModLogByGuildIdAndCaseId` mutation. */
export type UpdateModLogByGuildIdAndCaseIdInput = {
  caseId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `ModLog` being updated. */
  modLogPatch: ModLogPatch;
};

/** All input for the `updateModLog` mutation. */
export type UpdateModLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ModLog` being updated. */
  modLogPatch: ModLogPatch;
  /** The globally unique `ID` which will identify a single `ModLog` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `ModLog` mutation. */
export type UpdateModLogPayload = {
  __typename?: 'UpdateModLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ModLog` that was updated by this mutation. */
  modLog?: Maybe<ModLog>;
  /** An edge for our `ModLog`. May be used by Relay 1. */
  modLogEdge?: Maybe<ModLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ModLog` mutation. */
export type UpdateModLogPayloadModLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ModLogsOrderBy>>;
};

/** All input for the `updateMsgLogBlockByGuildIdAndChannelId` mutation. */
export type UpdateMsgLogBlockByGuildIdAndChannelIdInput = {
  channelId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `MsgLogBlock` being updated. */
  msgLogBlockPatch: MsgLogBlockPatch;
};

/** All input for the `updateMsgLogBlock` mutation. */
export type UpdateMsgLogBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MsgLogBlock` being updated. */
  msgLogBlockPatch: MsgLogBlockPatch;
  /** The globally unique `ID` which will identify a single `MsgLogBlock` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `MsgLogBlock` mutation. */
export type UpdateMsgLogBlockPayload = {
  __typename?: 'UpdateMsgLogBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MsgLogBlock` that was updated by this mutation. */
  msgLogBlock?: Maybe<MsgLogBlock>;
  /** An edge for our `MsgLogBlock`. May be used by Relay 1. */
  msgLogBlockEdge?: Maybe<MsgLogBlocksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MsgLogBlock` mutation. */
export type UpdateMsgLogBlockPayloadMsgLogBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<MsgLogBlocksOrderBy>>;
};

/** All input for the `updateMuteByGuildIdAndUserId` mutation. */
export type UpdateMuteByGuildIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `Mute` being updated. */
  mutePatch: MutePatch;
  userId: Scalars['BigInt'];
};

/** All input for the `updateMute` mutation. */
export type UpdateMuteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Mute` being updated. */
  mutePatch: MutePatch;
  /** The globally unique `ID` which will identify a single `Mute` to be updated. */
  nodeId: Scalars['ID'];
};

/** The output of our update `Mute` mutation. */
export type UpdateMutePayload = {
  __typename?: 'UpdateMutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `ModLog` that is related to this `Mute`. */
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** The `Mute` that was updated by this mutation. */
  mute?: Maybe<Mute>;
  /** An edge for our `Mute`. May be used by Relay 1. */
  muteEdge?: Maybe<MutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Mute` mutation. */
export type UpdateMutePayloadMuteEdgeArgs = {
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};

/** All input for the `updateNotificationByUserIdAndGuildIdAndKeyword` mutation. */
export type UpdateNotificationByUserIdAndGuildIdAndKeywordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  keyword: Scalars['String'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  notificationPatch: NotificationPatch;
  userId: Scalars['BigInt'];
};

/** All input for the `updateNotification` mutation. */
export type UpdateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  notificationPatch: NotificationPatch;
};

/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayload = {
  __typename?: 'UpdateNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `updateReminderByUserIdAndSetAt` mutation. */
export type UpdateReminderByUserIdAndSetAtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Reminder` being updated. */
  reminderPatch: ReminderPatch;
  setAt: Scalars['Datetime'];
  userId: Scalars['BigInt'];
};

/** All input for the `updateReminder` mutation. */
export type UpdateReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reminder` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Reminder` being updated. */
  reminderPatch: ReminderPatch;
};

/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayload = {
  __typename?: 'UpdateReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was updated by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** All input for the `updateRoleMenuByGuildIdAndMenuName` mutation. */
export type UpdateRoleMenuByGuildIdAndMenuNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  /** An object where the defined keys will be set on the `RoleMenu` being updated. */
  roleMenuPatch: RoleMenuPatch;
};

/** All input for the `updateRoleMenu` mutation. */
export type UpdateRoleMenuInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoleMenu` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RoleMenu` being updated. */
  roleMenuPatch: RoleMenuPatch;
};

/** The output of our update `RoleMenu` mutation. */
export type UpdateRoleMenuPayload = {
  __typename?: 'UpdateRoleMenuPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RoleMenu` that was updated by this mutation. */
  roleMenu?: Maybe<RoleMenu>;
  /** An edge for our `RoleMenu`. May be used by Relay 1. */
  roleMenuEdge?: Maybe<RoleMenusEdge>;
};


/** The output of our update `RoleMenu` mutation. */
export type UpdateRoleMenuPayloadRoleMenuEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenusOrderBy>>;
};

/** All input for the `updateRoleMenuRoleByGuildIdAndMenuNameAndRoleId` mutation. */
export type UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `RoleMenuRole` being updated. */
  roleMenuRolePatch: RoleMenuRolePatch;
};

/** All input for the `updateRoleMenuRole` mutation. */
export type UpdateRoleMenuRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `RoleMenuRole` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `RoleMenuRole` being updated. */
  roleMenuRolePatch: RoleMenuRolePatch;
};

/** The output of our update `RoleMenuRole` mutation. */
export type UpdateRoleMenuRolePayload = {
  __typename?: 'UpdateRoleMenuRolePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `RoleMenu` that is related to this `RoleMenuRole`. */
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
  /** The `RoleMenuRole` that was updated by this mutation. */
  roleMenuRole?: Maybe<RoleMenuRole>;
  /** An edge for our `RoleMenuRole`. May be used by Relay 1. */
  roleMenuRoleEdge?: Maybe<RoleMenuRolesEdge>;
};


/** The output of our update `RoleMenuRole` mutation. */
export type UpdateRoleMenuRolePayloadRoleMenuRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};

/** All input for the `updateTagByGuildIdAndTagName` mutation. */
export type UpdateTagByGuildIdAndTagNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
};

/** All input for the `updateTag` mutation. */
export type UpdateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
};

/** The output of our update `Tag` mutation. */
export type UpdateTagPayload = {
  __typename?: 'UpdateTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tag` that was updated by this mutation. */
  tag?: Maybe<Tag>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our update `Tag` mutation. */
export type UpdateTagPayloadTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `updateUserById` mutation. */
export type UpdateUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** All input for the `updateUserLevelByUserIdAndGuildId` mutation. */
export type UpdateUserLevelByUserIdAndGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `UserLevel` being updated. */
  userLevelPatch: UserLevelPatch;
};

/** All input for the `updateUserLevel` mutation. */
export type UpdateUserLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserLevel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserLevel` being updated. */
  userLevelPatch: UserLevelPatch;
};

/** The output of our update `UserLevel` mutation. */
export type UpdateUserLevelPayload = {
  __typename?: 'UpdateUserLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserLevel` that was updated by this mutation. */
  userLevel?: Maybe<UserLevel>;
  /** An edge for our `UserLevel`. May be used by Relay 1. */
  userLevelEdge?: Maybe<UserLevelsEdge>;
};


/** The output of our update `UserLevel` mutation. */
export type UpdateUserLevelPayloadUserLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<UserLevelsOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserXp` mutation. */
export type UpdateUserXpInput = {
  channelId?: InputMaybe<Scalars['BigInt']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  roleIds?: InputMaybe<Array<InputMaybe<Scalars['BigInt']>>>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our `updateUserXp` mutation. */
export type UpdateUserXpPayload = {
  __typename?: 'UpdateUserXpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  userXpUpdateResult?: Maybe<UserXpUpdateResult>;
};

/** All input for the `updateWebUserById` mutation. */
export type UpdateWebUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Unique identifier for the user. This should match their Discord ID. */
  id: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `WebUser` being updated. */
  webUserPatch: WebUserPatch;
};

/** All input for the `updateWebUserGuildByUserIdAndGuildId` mutation. */
export type UpdateWebUserGuildByUserIdAndGuildIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `WebUserGuild` being updated. */
  webUserGuildPatch: WebUserGuildPatch;
};

/** All input for the `updateWebUserGuild` mutation. */
export type UpdateWebUserGuildInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WebUserGuild` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WebUserGuild` being updated. */
  webUserGuildPatch: WebUserGuildPatch;
};

/** The output of our update `WebUserGuild` mutation. */
export type UpdateWebUserGuildPayload = {
  __typename?: 'UpdateWebUserGuildPayload';
  /** Reads a single `CachedGuild` that is related to this `WebUserGuild`. */
  cachedGuildByGuildId?: Maybe<CachedGuild>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WebUser` that is related to this `WebUserGuild`. */
  webUserByUserId?: Maybe<WebUser>;
  /** The `WebUserGuild` that was updated by this mutation. */
  webUserGuild?: Maybe<WebUserGuild>;
  /** An edge for our `WebUserGuild`. May be used by Relay 1. */
  webUserGuildEdge?: Maybe<WebUserGuildsEdge>;
};


/** The output of our update `WebUserGuild` mutation. */
export type UpdateWebUserGuildPayloadWebUserGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

/** All input for the `updateWebUser` mutation. */
export type UpdateWebUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `WebUser` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `WebUser` being updated. */
  webUserPatch: WebUserPatch;
};

/** The output of our update `WebUser` mutation. */
export type UpdateWebUserPayload = {
  __typename?: 'UpdateWebUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebUser` that was updated by this mutation. */
  webUser?: Maybe<WebUser>;
  /** An edge for our `WebUser`. May be used by Relay 1. */
  webUserEdge?: Maybe<WebUsersEdge>;
};


/** The output of our update `WebUser` mutation. */
export type UpdateWebUserPayloadWebUserEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUsersOrderBy>>;
};

/** All input for the `updateXpBlockByGuildIdAndBlockId` mutation. */
export type UpdateXpBlockByGuildIdAndBlockIdInput = {
  blockId: Scalars['BigInt'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  guildId: Scalars['BigInt'];
  /** An object where the defined keys will be set on the `XpBlock` being updated. */
  xpBlockPatch: XpBlockPatch;
};

/** All input for the `updateXpBlock` mutation. */
export type UpdateXpBlockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `XpBlock` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `XpBlock` being updated. */
  xpBlockPatch: XpBlockPatch;
};

/** The output of our update `XpBlock` mutation. */
export type UpdateXpBlockPayload = {
  __typename?: 'UpdateXpBlockPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `XpBlock` that was updated by this mutation. */
  xpBlock?: Maybe<XpBlock>;
  /** An edge for our `XpBlock`. May be used by Relay 1. */
  xpBlockEdge?: Maybe<XpBlocksEdge>;
};


/** The output of our update `XpBlock` mutation. */
export type UpdateXpBlockPayloadXpBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<XpBlocksOrderBy>>;
};

/** All input for the upsert `BotStat` mutation. */
export type UpsertBotStatInput = {
  /** The `BotStat` to be upserted by this mutation. */
  botStat: BotStatInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our upsert `BotStat` mutation. */
export type UpsertBotStatPayload = {
  __typename?: 'UpsertBotStatPayload';
  /** The `BotStat` that was upserted by this mutation. */
  botStat?: Maybe<BotStat>;
  /** An edge for our `BotStat`. May be used by Relay 1. */
  botStatEdge?: Maybe<BotStatsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `BotStat` mutation. */
export type UpsertBotStatPayloadBotStatEdgeArgs = {
  orderBy?: InputMaybe<Array<BotStatsOrderBy>>;
};

/** Where conditions for the upsert `BotStat` mutation. */
export type UpsertBotStatWhere = {
  category?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

/** All input for the upsert `CachedGuild` mutation. */
export type UpsertCachedGuildInput = {
  /** The `CachedGuild` to be upserted by this mutation. */
  cachedGuild: CachedGuildInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our upsert `CachedGuild` mutation. */
export type UpsertCachedGuildPayload = {
  __typename?: 'UpsertCachedGuildPayload';
  /** The `CachedGuild` that was upserted by this mutation. */
  cachedGuild?: Maybe<CachedGuild>;
  /** An edge for our `CachedGuild`. May be used by Relay 1. */
  cachedGuildEdge?: Maybe<CachedGuildsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `CachedGuild` mutation. */
export type UpsertCachedGuildPayloadCachedGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedGuildsOrderBy>>;
};

/** Where conditions for the upsert `CachedGuild` mutation. */
export type UpsertCachedGuildWhere = {
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `CachedUser` mutation. */
export type UpsertCachedUserInput = {
  /** The `CachedUser` to be upserted by this mutation. */
  cachedUser: CachedUserInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** The output of our upsert `CachedUser` mutation. */
export type UpsertCachedUserPayload = {
  __typename?: 'UpsertCachedUserPayload';
  /** The `CachedUser` that was upserted by this mutation. */
  cachedUser?: Maybe<CachedUser>;
  /** An edge for our `CachedUser`. May be used by Relay 1. */
  cachedUserEdge?: Maybe<CachedUsersEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `CachedUser` mutation. */
export type UpsertCachedUserPayloadCachedUserEdgeArgs = {
  orderBy?: InputMaybe<Array<CachedUsersOrderBy>>;
};

/** Where conditions for the upsert `CachedUser` mutation. */
export type UpsertCachedUserWhere = {
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `EmojiStickerStat` mutation. */
export type UpsertEmojiStickerStatInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `EmojiStickerStat` to be upserted by this mutation. */
  emojiStickerStat: EmojiStickerStatInput;
};

/** The output of our upsert `EmojiStickerStat` mutation. */
export type UpsertEmojiStickerStatPayload = {
  __typename?: 'UpsertEmojiStickerStatPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EmojiStickerStat` that was upserted by this mutation. */
  emojiStickerStat?: Maybe<EmojiStickerStat>;
  /** An edge for our `EmojiStickerStat`. May be used by Relay 1. */
  emojiStickerStatEdge?: Maybe<EmojiStickerStatsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `EmojiStickerStat` mutation. */
export type UpsertEmojiStickerStatPayloadEmojiStickerStatEdgeArgs = {
  orderBy?: InputMaybe<Array<EmojiStickerStatsOrderBy>>;
};

/** Where conditions for the upsert `EmojiStickerStat` mutation. */
export type UpsertEmojiStickerStatWhere = {
  actionType?: InputMaybe<EmojiStickerActionType>;
  assetId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
  time?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the upsert `Feed` mutation. */
export type UpsertFeedInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Feed` to be upserted by this mutation. */
  feed: FeedInput;
};

/** All input for the upsert `FeedItem` mutation. */
export type UpsertFeedItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `FeedItem` to be upserted by this mutation. */
  feedItem: FeedItemInput;
};

/** The output of our upsert `FeedItem` mutation. */
export type UpsertFeedItemPayload = {
  __typename?: 'UpsertFeedItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FeedItem` that was upserted by this mutation. */
  feedItem?: Maybe<FeedItem>;
  /** An edge for our `FeedItem`. May be used by Relay 1. */
  feedItemEdge?: Maybe<FeedItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `FeedItem` mutation. */
export type UpsertFeedItemPayloadFeedItemEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedItemsOrderBy>>;
};

/** Where conditions for the upsert `FeedItem` mutation. */
export type UpsertFeedItemWhere = {
  feedId?: InputMaybe<Scalars['String']>;
  itemId?: InputMaybe<Scalars['String']>;
};

/** The output of our upsert `Feed` mutation. */
export type UpsertFeedPayload = {
  __typename?: 'UpsertFeedPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feed` that was upserted by this mutation. */
  feed?: Maybe<Feed>;
  /** An edge for our `Feed`. May be used by Relay 1. */
  feedEdge?: Maybe<FeedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Feed` mutation. */
export type UpsertFeedPayloadFeedEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedsOrderBy>>;
};

/** All input for the upsert `FeedSubscription` mutation. */
export type UpsertFeedSubscriptionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `FeedSubscription` to be upserted by this mutation. */
  feedSubscription: FeedSubscriptionInput;
};

/** The output of our upsert `FeedSubscription` mutation. */
export type UpsertFeedSubscriptionPayload = {
  __typename?: 'UpsertFeedSubscriptionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `Feed` that is related to this `FeedSubscription`. */
  feedByFeedId?: Maybe<Feed>;
  /** The `FeedSubscription` that was upserted by this mutation. */
  feedSubscription?: Maybe<FeedSubscription>;
  /** An edge for our `FeedSubscription`. May be used by Relay 1. */
  feedSubscriptionEdge?: Maybe<FeedSubscriptionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `FeedSubscription` mutation. */
export type UpsertFeedSubscriptionPayloadFeedSubscriptionEdgeArgs = {
  orderBy?: InputMaybe<Array<FeedSubscriptionsOrderBy>>;
};

/** Where conditions for the upsert `FeedSubscription` mutation. */
export type UpsertFeedSubscriptionWhere = {
  channelId?: InputMaybe<Scalars['BigInt']>;
  feedId?: InputMaybe<Scalars['String']>;
};

/** Where conditions for the upsert `Feed` mutation. */
export type UpsertFeedWhere = {
  feedId?: InputMaybe<Scalars['String']>;
};

/** All input for the upsert `GuildBan` mutation. */
export type UpsertGuildBanInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GuildBan` to be upserted by this mutation. */
  guildBan: GuildBanInput;
};

/** The output of our upsert `GuildBan` mutation. */
export type UpsertGuildBanPayload = {
  __typename?: 'UpsertGuildBanPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildBan` that was upserted by this mutation. */
  guildBan?: Maybe<GuildBan>;
  /** An edge for our `GuildBan`. May be used by Relay 1. */
  guildBanEdge?: Maybe<GuildBansEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `GuildBan` mutation. */
export type UpsertGuildBanPayloadGuildBanEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildBansOrderBy>>;
};

/** Where conditions for the upsert `GuildBan` mutation. */
export type UpsertGuildBanWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `GuildConfig` mutation. */
export type UpsertGuildConfigInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GuildConfig` to be upserted by this mutation. */
  guildConfig: GuildConfigInput;
};

/** The output of our upsert `GuildConfig` mutation. */
export type UpsertGuildConfigPayload = {
  __typename?: 'UpsertGuildConfigPayload';
  /** Reads a single `CachedGuild` that is related to this `GuildConfig`. */
  cachedGuildById?: Maybe<CachedGuild>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GuildConfig` that was upserted by this mutation. */
  guildConfig?: Maybe<GuildConfig>;
  /** An edge for our `GuildConfig`. May be used by Relay 1. */
  guildConfigEdge?: Maybe<GuildConfigsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `GuildConfig` mutation. */
export type UpsertGuildConfigPayloadGuildConfigEdgeArgs = {
  orderBy?: InputMaybe<Array<GuildConfigsOrderBy>>;
};

/** Where conditions for the upsert `GuildConfig` mutation. */
export type UpsertGuildConfigWhere = {
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `LevelRoleApplyJob` mutation. */
export type UpsertLevelRoleApplyJobInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRoleApplyJob` to be upserted by this mutation. */
  levelRoleApplyJob: LevelRoleApplyJobInput;
};

/** The output of our upsert `LevelRoleApplyJob` mutation. */
export type UpsertLevelRoleApplyJobPayload = {
  __typename?: 'UpsertLevelRoleApplyJobPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleApplyJob` that was upserted by this mutation. */
  levelRoleApplyJob?: Maybe<LevelRoleApplyJob>;
  /** An edge for our `LevelRoleApplyJob`. May be used by Relay 1. */
  levelRoleApplyJobEdge?: Maybe<LevelRoleApplyJobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `LevelRoleApplyJob` mutation. */
export type UpsertLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleApplyJobsOrderBy>>;
};

/** Where conditions for the upsert `LevelRoleApplyJob` mutation. */
export type UpsertLevelRoleApplyJobWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  interactionId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `LevelRole` mutation. */
export type UpsertLevelRoleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRole` to be upserted by this mutation. */
  levelRole: LevelRoleInput;
};

/** All input for the upsert `LevelRoleOverride` mutation. */
export type UpsertLevelRoleOverrideInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `LevelRoleOverride` to be upserted by this mutation. */
  levelRoleOverride: LevelRoleOverrideInput;
};

/** The output of our upsert `LevelRoleOverride` mutation. */
export type UpsertLevelRoleOverridePayload = {
  __typename?: 'UpsertLevelRoleOverridePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRoleOverride` that was upserted by this mutation. */
  levelRoleOverride?: Maybe<LevelRoleOverride>;
  /** An edge for our `LevelRoleOverride`. May be used by Relay 1. */
  levelRoleOverrideEdge?: Maybe<LevelRoleOverridesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `LevelRoleOverride` mutation. */
export type UpsertLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRoleOverridesOrderBy>>;
};

/** Where conditions for the upsert `LevelRoleOverride` mutation. */
export type UpsertLevelRoleOverrideWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our upsert `LevelRole` mutation. */
export type UpsertLevelRolePayload = {
  __typename?: 'UpsertLevelRolePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LevelRole` that was upserted by this mutation. */
  levelRole?: Maybe<LevelRole>;
  /** An edge for our `LevelRole`. May be used by Relay 1. */
  levelRoleEdge?: Maybe<LevelRolesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `LevelRole` mutation. */
export type UpsertLevelRolePayloadLevelRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<LevelRolesOrderBy>>;
};

/** Where conditions for the upsert `LevelRole` mutation. */
export type UpsertLevelRoleWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `Member` mutation. */
export type UpsertMemberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Member` to be upserted by this mutation. */
  member: MemberInput;
};

/** The output of our upsert `Member` mutation. */
export type UpsertMemberPayload = {
  __typename?: 'UpsertMemberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Member` that was upserted by this mutation. */
  member?: Maybe<Member>;
  /** An edge for our `Member`. May be used by Relay 1. */
  memberEdge?: Maybe<MembersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Member` mutation. */
export type UpsertMemberPayloadMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<MembersOrderBy>>;
};

/** Where conditions for the upsert `Member` mutation. */
export type UpsertMemberWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `Message` mutation. */
export type UpsertMessageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Message` to be upserted by this mutation. */
  message: MessageInput;
};

/** The output of our upsert `Message` mutation. */
export type UpsertMessagePayload = {
  __typename?: 'UpsertMessagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was upserted by this mutation. */
  message?: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Message` mutation. */
export type UpsertMessagePayloadMessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** Where conditions for the upsert `Message` mutation. */
export type UpsertMessageWhere = {
  messageId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `ModLog` mutation. */
export type UpsertModLogInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ModLog` to be upserted by this mutation. */
  modLog: ModLogInput;
};

/** The output of our upsert `ModLog` mutation. */
export type UpsertModLogPayload = {
  __typename?: 'UpsertModLogPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ModLog` that was upserted by this mutation. */
  modLog?: Maybe<ModLog>;
  /** An edge for our `ModLog`. May be used by Relay 1. */
  modLogEdge?: Maybe<ModLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `ModLog` mutation. */
export type UpsertModLogPayloadModLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ModLogsOrderBy>>;
};

/** Where conditions for the upsert `ModLog` mutation. */
export type UpsertModLogWhere = {
  caseId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `MsgLogBlock` mutation. */
export type UpsertMsgLogBlockInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `MsgLogBlock` to be upserted by this mutation. */
  msgLogBlock: MsgLogBlockInput;
};

/** The output of our upsert `MsgLogBlock` mutation. */
export type UpsertMsgLogBlockPayload = {
  __typename?: 'UpsertMsgLogBlockPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MsgLogBlock` that was upserted by this mutation. */
  msgLogBlock?: Maybe<MsgLogBlock>;
  /** An edge for our `MsgLogBlock`. May be used by Relay 1. */
  msgLogBlockEdge?: Maybe<MsgLogBlocksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `MsgLogBlock` mutation. */
export type UpsertMsgLogBlockPayloadMsgLogBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<MsgLogBlocksOrderBy>>;
};

/** Where conditions for the upsert `MsgLogBlock` mutation. */
export type UpsertMsgLogBlockWhere = {
  channelId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `Mute` mutation. */
export type UpsertMuteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Mute` to be upserted by this mutation. */
  mute: MuteInput;
};

/** The output of our upsert `Mute` mutation. */
export type UpsertMutePayload = {
  __typename?: 'UpsertMutePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Reads a single `ModLog` that is related to this `Mute`. */
  modLogByGuildIdAndCaseId?: Maybe<ModLog>;
  /** The `Mute` that was upserted by this mutation. */
  mute?: Maybe<Mute>;
  /** An edge for our `Mute`. May be used by Relay 1. */
  muteEdge?: Maybe<MutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Mute` mutation. */
export type UpsertMutePayloadMuteEdgeArgs = {
  orderBy?: InputMaybe<Array<MutesOrderBy>>;
};

/** Where conditions for the upsert `Mute` mutation. */
export type UpsertMuteWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `Notification` mutation. */
export type UpsertNotificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Notification` to be upserted by this mutation. */
  notification: NotificationInput;
};

/** The output of our upsert `Notification` mutation. */
export type UpsertNotificationPayload = {
  __typename?: 'UpsertNotificationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was upserted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our upsert `Notification` mutation. */
export type UpsertNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** Where conditions for the upsert `Notification` mutation. */
export type UpsertNotificationWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  keyword?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `Reminder` mutation. */
export type UpsertReminderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Reminder` to be upserted by this mutation. */
  reminder: ReminderInput;
};

/** The output of our upsert `Reminder` mutation. */
export type UpsertReminderPayload = {
  __typename?: 'UpsertReminderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was upserted by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our upsert `Reminder` mutation. */
export type UpsertReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** Where conditions for the upsert `Reminder` mutation. */
export type UpsertReminderWhere = {
  setAt?: InputMaybe<Scalars['Datetime']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `RoleMenu` mutation. */
export type UpsertRoleMenuInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoleMenu` to be upserted by this mutation. */
  roleMenu: RoleMenuInput;
};

/** The output of our upsert `RoleMenu` mutation. */
export type UpsertRoleMenuPayload = {
  __typename?: 'UpsertRoleMenuPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RoleMenu` that was upserted by this mutation. */
  roleMenu?: Maybe<RoleMenu>;
  /** An edge for our `RoleMenu`. May be used by Relay 1. */
  roleMenuEdge?: Maybe<RoleMenusEdge>;
};


/** The output of our upsert `RoleMenu` mutation. */
export type UpsertRoleMenuPayloadRoleMenuEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenusOrderBy>>;
};

/** All input for the upsert `RoleMenuRole` mutation. */
export type UpsertRoleMenuRoleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `RoleMenuRole` to be upserted by this mutation. */
  roleMenuRole: RoleMenuRoleInput;
};

/** The output of our upsert `RoleMenuRole` mutation. */
export type UpsertRoleMenuRolePayload = {
  __typename?: 'UpsertRoleMenuRolePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `RoleMenu` that is related to this `RoleMenuRole`. */
  roleMenuByGuildIdAndMenuName?: Maybe<RoleMenu>;
  /** The `RoleMenuRole` that was upserted by this mutation. */
  roleMenuRole?: Maybe<RoleMenuRole>;
  /** An edge for our `RoleMenuRole`. May be used by Relay 1. */
  roleMenuRoleEdge?: Maybe<RoleMenuRolesEdge>;
};


/** The output of our upsert `RoleMenuRole` mutation. */
export type UpsertRoleMenuRolePayloadRoleMenuRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<RoleMenuRolesOrderBy>>;
};

/** Where conditions for the upsert `RoleMenuRole` mutation. */
export type UpsertRoleMenuRoleWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
  roleId?: InputMaybe<Scalars['BigInt']>;
};

/** Where conditions for the upsert `RoleMenu` mutation. */
export type UpsertRoleMenuWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  menuName?: InputMaybe<Scalars['String']>;
};

/** All input for the upsert `Tag` mutation. */
export type UpsertTagInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tag` to be upserted by this mutation. */
  tag: TagInput;
};

/** The output of our upsert `Tag` mutation. */
export type UpsertTagPayload = {
  __typename?: 'UpsertTagPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Tag` that was upserted by this mutation. */
  tag?: Maybe<Tag>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our upsert `Tag` mutation. */
export type UpsertTagPayloadTagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** Where conditions for the upsert `Tag` mutation. */
export type UpsertTagWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  tagName?: InputMaybe<Scalars['String']>;
};

/** All input for the upsert `User` mutation. */
export type UpsertUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be upserted by this mutation. */
  user: UserInput;
};

/** All input for the upsert `UserLevel` mutation. */
export type UpsertUserLevelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UserLevel` to be upserted by this mutation. */
  userLevel: UserLevelInput;
};

/** The output of our upsert `UserLevel` mutation. */
export type UpsertUserLevelPayload = {
  __typename?: 'UpsertUserLevelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserLevel` that was upserted by this mutation. */
  userLevel?: Maybe<UserLevel>;
  /** An edge for our `UserLevel`. May be used by Relay 1. */
  userLevelEdge?: Maybe<UserLevelsEdge>;
};


/** The output of our upsert `UserLevel` mutation. */
export type UpsertUserLevelPayloadUserLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<UserLevelsOrderBy>>;
};

/** Where conditions for the upsert `UserLevel` mutation. */
export type UpsertUserLevelWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our upsert `User` mutation. */
export type UpsertUserPayload = {
  __typename?: 'UpsertUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was upserted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our upsert `User` mutation. */
export type UpsertUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** Where conditions for the upsert `User` mutation. */
export type UpsertUserWhere = {
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `WebUserGuild` mutation. */
export type UpsertWebUserGuildInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `WebUserGuild` to be upserted by this mutation. */
  webUserGuild: WebUserGuildInput;
};

/** The output of our upsert `WebUserGuild` mutation. */
export type UpsertWebUserGuildPayload = {
  __typename?: 'UpsertWebUserGuildPayload';
  /** Reads a single `CachedGuild` that is related to this `WebUserGuild`. */
  cachedGuildByGuildId?: Maybe<CachedGuild>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `WebUser` that is related to this `WebUserGuild`. */
  webUserByUserId?: Maybe<WebUser>;
  /** The `WebUserGuild` that was upserted by this mutation. */
  webUserGuild?: Maybe<WebUserGuild>;
  /** An edge for our `WebUserGuild`. May be used by Relay 1. */
  webUserGuildEdge?: Maybe<WebUserGuildsEdge>;
};


/** The output of our upsert `WebUserGuild` mutation. */
export type UpsertWebUserGuildPayloadWebUserGuildEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

/** Where conditions for the upsert `WebUserGuild` mutation. */
export type UpsertWebUserGuildWhere = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `WebUser` mutation. */
export type UpsertWebUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `WebUser` to be upserted by this mutation. */
  webUser: WebUserInput;
};

/** The output of our upsert `WebUser` mutation. */
export type UpsertWebUserPayload = {
  __typename?: 'UpsertWebUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `WebUser` that was upserted by this mutation. */
  webUser?: Maybe<WebUser>;
  /** An edge for our `WebUser`. May be used by Relay 1. */
  webUserEdge?: Maybe<WebUsersEdge>;
};


/** The output of our upsert `WebUser` mutation. */
export type UpsertWebUserPayloadWebUserEdgeArgs = {
  orderBy?: InputMaybe<Array<WebUsersOrderBy>>;
};

/** Where conditions for the upsert `WebUser` mutation. */
export type UpsertWebUserWhere = {
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the upsert `XpBlock` mutation. */
export type UpsertXpBlockInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `XpBlock` to be upserted by this mutation. */
  xpBlock: XpBlockInput;
};

/** The output of our upsert `XpBlock` mutation. */
export type UpsertXpBlockPayload = {
  __typename?: 'UpsertXpBlockPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `XpBlock` that was upserted by this mutation. */
  xpBlock?: Maybe<XpBlock>;
  /** An edge for our `XpBlock`. May be used by Relay 1. */
  xpBlockEdge?: Maybe<XpBlocksEdge>;
};


/** The output of our upsert `XpBlock` mutation. */
export type UpsertXpBlockPayloadXpBlockEdgeArgs = {
  orderBy?: InputMaybe<Array<XpBlocksOrderBy>>;
};

/** Where conditions for the upsert `XpBlock` mutation. */
export type UpsertXpBlockWhere = {
  blockId?: InputMaybe<Scalars['BigInt']>;
  guildId?: InputMaybe<Scalars['BigInt']>;
};

export type User = Node & {
  __typename?: 'User';
  fishies: Scalars['BigInt'];
  id: Scalars['BigInt'];
  isPatron: Scalars['Boolean'];
  lastFishies?: Maybe<Scalars['Datetime']>;
  lastRep?: Maybe<Scalars['Datetime']>;
  lastfmUsername?: Maybe<Scalars['String']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  patronEmoji?: Maybe<Scalars['String']>;
  profileData?: Maybe<Scalars['JSON']>;
  rep: Scalars['BigInt'];
};

export type UserAggregates = {
  __typename?: 'UserAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<UserAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<UserDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<UserMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<UserMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<UserStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<UserStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<UserSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<UserVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<UserVarianceSampleAggregates>;
};

export type UserAverageAggregates = {
  __typename?: 'UserAverageAggregates';
  /** Mean average of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigFloat']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Mean average of rep across the matching connection */
  rep?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `fishies` field. */
  fishies?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isPatron` field. */
  isPatron?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `lastFishies` field. */
  lastFishies?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `lastRep` field. */
  lastRep?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `lastfmUsername` field. */
  lastfmUsername?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `patronEmoji` field. */
  patronEmoji?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `profileData` field. */
  profileData?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `rep` field. */
  rep?: InputMaybe<Scalars['BigInt']>;
};

export type UserDistinctCountAggregates = {
  __typename?: 'UserDistinctCountAggregates';
  /** Distinct count of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigInt']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Distinct count of isPatron across the matching connection */
  isPatron?: Maybe<Scalars['BigInt']>;
  /** Distinct count of lastFishies across the matching connection */
  lastFishies?: Maybe<Scalars['BigInt']>;
  /** Distinct count of lastRep across the matching connection */
  lastRep?: Maybe<Scalars['BigInt']>;
  /** Distinct count of lastfmUsername across the matching connection */
  lastfmUsername?: Maybe<Scalars['BigInt']>;
  /** Distinct count of patronEmoji across the matching connection */
  patronEmoji?: Maybe<Scalars['BigInt']>;
  /** Distinct count of profileData across the matching connection */
  profileData?: Maybe<Scalars['BigInt']>;
  /** Distinct count of rep across the matching connection */
  rep?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `fishies` field. */
  fishies?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isPatron` field. */
  isPatron?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastFishies` field. */
  lastFishies?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lastRep` field. */
  lastRep?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lastfmUsername` field. */
  lastfmUsername?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `patronEmoji` field. */
  patronEmoji?: InputMaybe<StringFilter>;
  /** Filter by the object’s `profileData` field. */
  profileData?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `rep` field. */
  rep?: InputMaybe<BigIntFilter>;
};

export type UserGuildRankResult = {
  __typename?: 'UserGuildRankResult';
  guildId?: Maybe<Scalars['BigInt']>;
  lastMsg?: Maybe<Scalars['Datetime']>;
  msgAllTime?: Maybe<Scalars['BigInt']>;
  msgAllTimeRank?: Maybe<Scalars['BigInt']>;
  msgAllTimeTotal?: Maybe<Scalars['BigInt']>;
  msgDay?: Maybe<Scalars['BigInt']>;
  msgDayRank?: Maybe<Scalars['BigInt']>;
  msgDayTotal?: Maybe<Scalars['BigInt']>;
  msgMonth?: Maybe<Scalars['BigInt']>;
  msgMonthRank?: Maybe<Scalars['BigInt']>;
  msgMonthTotal?: Maybe<Scalars['BigInt']>;
  msgWeek?: Maybe<Scalars['BigInt']>;
  msgWeekRank?: Maybe<Scalars['BigInt']>;
  msgWeekTotal?: Maybe<Scalars['BigInt']>;
  userId?: Maybe<Scalars['BigInt']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  fishies: Scalars['BigInt'];
  id: Scalars['BigInt'];
  isPatron: Scalars['Boolean'];
  lastFishies?: InputMaybe<Scalars['Datetime']>;
  lastRep?: InputMaybe<Scalars['Datetime']>;
  lastfmUsername?: InputMaybe<Scalars['String']>;
  patronEmoji?: InputMaybe<Scalars['String']>;
  profileData?: InputMaybe<Scalars['JSON']>;
  rep: Scalars['BigInt'];
};

export type UserLevel = Node & {
  __typename?: 'UserLevel';
  guildId: Scalars['BigInt'];
  lastMsg: Scalars['Datetime'];
  level: Scalars['BigInt'];
  msgAllTime: Scalars['BigInt'];
  msgDay: Scalars['BigInt'];
  msgMonth: Scalars['BigInt'];
  msgWeek: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  userId: Scalars['BigInt'];
};

export type UserLevelAggregates = {
  __typename?: 'UserLevelAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<UserLevelAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<UserLevelDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<UserLevelMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<UserLevelMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<UserLevelStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<UserLevelStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<UserLevelSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<UserLevelVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<UserLevelVarianceSampleAggregates>;
};

export type UserLevelAverageAggregates = {
  __typename?: 'UserLevelAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of level across the matching connection */
  level?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigFloat']>;
  /** Mean average of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `UserLevel` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserLevelCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `lastMsg` field. */
  lastMsg?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `level` field. */
  level?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgAllTime` field. */
  msgAllTime?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgDay` field. */
  msgDay?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgMonth` field. */
  msgMonth?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `msgWeek` field. */
  msgWeek?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type UserLevelDistinctCountAggregates = {
  __typename?: 'UserLevelDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of lastMsg across the matching connection */
  lastMsg?: Maybe<Scalars['BigInt']>;
  /** Distinct count of level across the matching connection */
  level?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigInt']>;
  /** Distinct count of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `UserLevel` object types. All fields are combined with a logical ‘and.’ */
export type UserLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserLevelFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `lastMsg` field. */
  lastMsg?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `level` field. */
  level?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msgAllTime` field. */
  msgAllTime?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msgDay` field. */
  msgDay?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msgMonth` field. */
  msgMonth?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `msgWeek` field. */
  msgWeek?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserLevelFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `UserLevel` */
export type UserLevelInput = {
  guildId: Scalars['BigInt'];
  lastMsg: Scalars['Datetime'];
  level?: InputMaybe<Scalars['BigInt']>;
  msgAllTime: Scalars['BigInt'];
  msgDay: Scalars['BigInt'];
  msgMonth: Scalars['BigInt'];
  msgWeek: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

export type UserLevelMaxAggregates = {
  __typename?: 'UserLevelMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of level across the matching connection */
  level?: Maybe<Scalars['BigInt']>;
  /** Maximum of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigInt']>;
  /** Maximum of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigInt']>;
  /** Maximum of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigInt']>;
  /** Maximum of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type UserLevelMinAggregates = {
  __typename?: 'UserLevelMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of level across the matching connection */
  level?: Maybe<Scalars['BigInt']>;
  /** Minimum of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigInt']>;
  /** Minimum of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigInt']>;
  /** Minimum of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigInt']>;
  /** Minimum of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `UserLevel`. Fields that are set will be updated. */
export type UserLevelPatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  lastMsg?: InputMaybe<Scalars['Datetime']>;
  level?: InputMaybe<Scalars['BigInt']>;
  msgAllTime?: InputMaybe<Scalars['BigInt']>;
  msgDay?: InputMaybe<Scalars['BigInt']>;
  msgMonth?: InputMaybe<Scalars['BigInt']>;
  msgWeek?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type UserLevelStddevPopulationAggregates = {
  __typename?: 'UserLevelStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of level across the matching connection */
  level?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type UserLevelStddevSampleAggregates = {
  __typename?: 'UserLevelStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of level across the matching connection */
  level?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type UserLevelSumAggregates = {
  __typename?: 'UserLevelSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of level across the matching connection */
  level: Scalars['BigFloat'];
  /** Sum of msgAllTime across the matching connection */
  msgAllTime: Scalars['BigFloat'];
  /** Sum of msgDay across the matching connection */
  msgDay: Scalars['BigFloat'];
  /** Sum of msgMonth across the matching connection */
  msgMonth: Scalars['BigFloat'];
  /** Sum of msgWeek across the matching connection */
  msgWeek: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type UserLevelVariancePopulationAggregates = {
  __typename?: 'UserLevelVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of level across the matching connection */
  level?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigFloat']>;
  /** Population variance of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type UserLevelVarianceSampleAggregates = {
  __typename?: 'UserLevelVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of level across the matching connection */
  level?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgAllTime across the matching connection */
  msgAllTime?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgDay across the matching connection */
  msgDay?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgMonth across the matching connection */
  msgMonth?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of msgWeek across the matching connection */
  msgWeek?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `UserLevel` values. */
export type UserLevelsConnection = {
  __typename?: 'UserLevelsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<UserLevelAggregates>;
  /** A list of edges which contains the `UserLevel` and cursor to aid in pagination. */
  edges: Array<UserLevelsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<UserLevelAggregates>>;
  /** A list of `UserLevel` objects. */
  nodes: Array<UserLevel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserLevel` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `UserLevel` values. */
export type UserLevelsConnectionGroupedAggregatesArgs = {
  groupBy: Array<UserLevelsGroupBy>;
  having?: InputMaybe<UserLevelsHavingInput>;
};

/** A `UserLevel` edge in the connection. */
export type UserLevelsEdge = {
  __typename?: 'UserLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserLevel` at the end of the edge. */
  node: UserLevel;
};

/** Grouping methods for `UserLevel` for usage during aggregation. */
export enum UserLevelsGroupBy {
  GuildId = 'GUILD_ID',
  LastMsg = 'LAST_MSG',
  LastMsgTruncatedToDay = 'LAST_MSG_TRUNCATED_TO_DAY',
  LastMsgTruncatedToHour = 'LAST_MSG_TRUNCATED_TO_HOUR',
  Level = 'LEVEL',
  MsgAllTime = 'MSG_ALL_TIME',
  MsgDay = 'MSG_DAY',
  MsgMonth = 'MSG_MONTH',
  MsgWeek = 'MSG_WEEK',
  UserId = 'USER_ID'
}

export type UserLevelsHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `UserLevel` aggregates. */
export type UserLevelsHavingInput = {
  AND?: InputMaybe<Array<UserLevelsHavingInput>>;
  OR?: InputMaybe<Array<UserLevelsHavingInput>>;
  average?: InputMaybe<UserLevelsHavingAverageInput>;
  distinctCount?: InputMaybe<UserLevelsHavingDistinctCountInput>;
  max?: InputMaybe<UserLevelsHavingMaxInput>;
  min?: InputMaybe<UserLevelsHavingMinInput>;
  stddevPopulation?: InputMaybe<UserLevelsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<UserLevelsHavingStddevSampleInput>;
  sum?: InputMaybe<UserLevelsHavingSumInput>;
  variancePopulation?: InputMaybe<UserLevelsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<UserLevelsHavingVarianceSampleInput>;
};

export type UserLevelsHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type UserLevelsHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  lastMsg?: InputMaybe<HavingDatetimeFilter>;
  level?: InputMaybe<HavingBigintFilter>;
  msgAllTime?: InputMaybe<HavingBigintFilter>;
  msgDay?: InputMaybe<HavingBigintFilter>;
  msgMonth?: InputMaybe<HavingBigintFilter>;
  msgWeek?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `UserLevel`. */
export enum UserLevelsOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  LastMsgAsc = 'LAST_MSG_ASC',
  LastMsgDesc = 'LAST_MSG_DESC',
  LevelAsc = 'LEVEL_ASC',
  LevelDesc = 'LEVEL_DESC',
  MsgAllTimeAsc = 'MSG_ALL_TIME_ASC',
  MsgAllTimeDesc = 'MSG_ALL_TIME_DESC',
  MsgDayAsc = 'MSG_DAY_ASC',
  MsgDayDesc = 'MSG_DAY_DESC',
  MsgMonthAsc = 'MSG_MONTH_ASC',
  MsgMonthDesc = 'MSG_MONTH_DESC',
  MsgWeekAsc = 'MSG_WEEK_ASC',
  MsgWeekDesc = 'MSG_WEEK_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type UserMaxAggregates = {
  __typename?: 'UserMaxAggregates';
  /** Maximum of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigInt']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Maximum of rep across the matching connection */
  rep?: Maybe<Scalars['BigInt']>;
};

export type UserMinAggregates = {
  __typename?: 'UserMinAggregates';
  /** Minimum of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigInt']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Minimum of rep across the matching connection */
  rep?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  fishies?: InputMaybe<Scalars['BigInt']>;
  id?: InputMaybe<Scalars['BigInt']>;
  isPatron?: InputMaybe<Scalars['Boolean']>;
  lastFishies?: InputMaybe<Scalars['Datetime']>;
  lastRep?: InputMaybe<Scalars['Datetime']>;
  lastfmUsername?: InputMaybe<Scalars['String']>;
  patronEmoji?: InputMaybe<Scalars['String']>;
  profileData?: InputMaybe<Scalars['JSON']>;
  rep?: InputMaybe<Scalars['BigInt']>;
};

export type UserStddevPopulationAggregates = {
  __typename?: 'UserStddevPopulationAggregates';
  /** Population standard deviation of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of rep across the matching connection */
  rep?: Maybe<Scalars['BigFloat']>;
};

export type UserStddevSampleAggregates = {
  __typename?: 'UserStddevSampleAggregates';
  /** Sample standard deviation of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of rep across the matching connection */
  rep?: Maybe<Scalars['BigFloat']>;
};

export type UserSumAggregates = {
  __typename?: 'UserSumAggregates';
  /** Sum of fishies across the matching connection */
  fishies: Scalars['BigFloat'];
  /** Sum of id across the matching connection */
  id: Scalars['BigFloat'];
  /** Sum of rep across the matching connection */
  rep: Scalars['BigFloat'];
};

export type UserVariancePopulationAggregates = {
  __typename?: 'UserVariancePopulationAggregates';
  /** Population variance of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigFloat']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Population variance of rep across the matching connection */
  rep?: Maybe<Scalars['BigFloat']>;
};

export type UserVarianceSampleAggregates = {
  __typename?: 'UserVarianceSampleAggregates';
  /** Sample variance of fishies across the matching connection */
  fishies?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of rep across the matching connection */
  rep?: Maybe<Scalars['BigFloat']>;
};

export type UserXpUpdateResult = {
  __typename?: 'UserXpUpdateResult';
  addRoleIds?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
  newLevel?: Maybe<Scalars['BigInt']>;
  oldLevel?: Maybe<Scalars['BigInt']>;
  removeRoleIds?: Maybe<Array<Maybe<Scalars['BigInt']>>>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<UserAggregates>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<UserAggregates>>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `User` values. */
export type UsersConnectionGroupedAggregatesArgs = {
  groupBy: Array<UsersGroupBy>;
  having?: InputMaybe<UsersHavingInput>;
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node: User;
};

/** Grouping methods for `User` for usage during aggregation. */
export enum UsersGroupBy {
  Fishies = 'FISHIES',
  IsPatron = 'IS_PATRON',
  LastfmUsername = 'LASTFM_USERNAME',
  LastFishies = 'LAST_FISHIES',
  LastFishiesTruncatedToDay = 'LAST_FISHIES_TRUNCATED_TO_DAY',
  LastFishiesTruncatedToHour = 'LAST_FISHIES_TRUNCATED_TO_HOUR',
  LastRep = 'LAST_REP',
  LastRepTruncatedToDay = 'LAST_REP_TRUNCATED_TO_DAY',
  LastRepTruncatedToHour = 'LAST_REP_TRUNCATED_TO_HOUR',
  PatronEmoji = 'PATRON_EMOJI',
  ProfileData = 'PROFILE_DATA',
  Rep = 'REP'
}

export type UsersHavingAverageInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingDistinctCountInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `User` aggregates. */
export type UsersHavingInput = {
  AND?: InputMaybe<Array<UsersHavingInput>>;
  OR?: InputMaybe<Array<UsersHavingInput>>;
  average?: InputMaybe<UsersHavingAverageInput>;
  distinctCount?: InputMaybe<UsersHavingDistinctCountInput>;
  max?: InputMaybe<UsersHavingMaxInput>;
  min?: InputMaybe<UsersHavingMinInput>;
  stddevPopulation?: InputMaybe<UsersHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<UsersHavingStddevSampleInput>;
  sum?: InputMaybe<UsersHavingSumInput>;
  variancePopulation?: InputMaybe<UsersHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<UsersHavingVarianceSampleInput>;
};

export type UsersHavingMaxInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingMinInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingStddevPopulationInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingStddevSampleInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingSumInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingVariancePopulationInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

export type UsersHavingVarianceSampleInput = {
  fishies?: InputMaybe<HavingBigintFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  lastFishies?: InputMaybe<HavingDatetimeFilter>;
  lastRep?: InputMaybe<HavingDatetimeFilter>;
  rep?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  FishiesAsc = 'FISHIES_ASC',
  FishiesDesc = 'FISHIES_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsPatronAsc = 'IS_PATRON_ASC',
  IsPatronDesc = 'IS_PATRON_DESC',
  LastfmUsernameAsc = 'LASTFM_USERNAME_ASC',
  LastfmUsernameDesc = 'LASTFM_USERNAME_DESC',
  LastFishiesAsc = 'LAST_FISHIES_ASC',
  LastFishiesDesc = 'LAST_FISHIES_DESC',
  LastRepAsc = 'LAST_REP_ASC',
  LastRepDesc = 'LAST_REP_DESC',
  Natural = 'NATURAL',
  PatronEmojiAsc = 'PATRON_EMOJI_ASC',
  PatronEmojiDesc = 'PATRON_EMOJI_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProfileDataAsc = 'PROFILE_DATA_ASC',
  ProfileDataDesc = 'PROFILE_DATA_DESC',
  RepAsc = 'REP_ASC',
  RepDesc = 'REP_DESC'
}

/** A user who can log in to the application. */
export type WebUser = Node & {
  __typename?: 'WebUser';
  /** Discord avatar hash. Null if user does not have one. */
  avatar?: Maybe<Scalars['String']>;
  /** First registered on the application. Is not when a user created their Discord account. */
  createdAt: Scalars['Datetime'];
  /** Additional profile details extracted from Discord oauth */
  details: Scalars['JSON'];
  /** Discord disciminator of the user. */
  discriminator: Scalars['Int'];
  /** Unique identifier for the user. This should match their Discord ID. */
  id: Scalars['BigInt'];
  /** If true, the user has elevated privileges. */
  isAdmin: Scalars['Boolean'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  updatedAt: Scalars['Datetime'];
  /** Discord username of the user. */
  username: Scalars['String'];
  /** Reads and enables pagination through a set of `WebUserGuild`. */
  webUserGuildsByUserId: WebUserGuildsConnection;
};


/** A user who can log in to the application. */
export type WebUserWebUserGuildsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  condition?: InputMaybe<WebUserGuildCondition>;
  filter?: InputMaybe<WebUserGuildFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebUserGuildsOrderBy>>;
};

export type WebUserAggregates = {
  __typename?: 'WebUserAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<WebUserAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<WebUserDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<WebUserMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<WebUserMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<WebUserStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<WebUserStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<WebUserSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<WebUserVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<WebUserVarianceSampleAggregates>;
};

export type WebUserAverageAggregates = {
  __typename?: 'WebUserAverageAggregates';
  /** Mean average of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigFloat']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `WebUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type WebUserCondition = {
  /** Checks for equality with the object’s `avatar` field. */
  avatar?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `discriminator` field. */
  discriminator?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']>;
};

export type WebUserDistinctCountAggregates = {
  __typename?: 'WebUserDistinctCountAggregates';
  /** Distinct count of avatar across the matching connection */
  avatar?: Maybe<Scalars['BigInt']>;
  /** Distinct count of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of details across the matching connection */
  details?: Maybe<Scalars['BigInt']>;
  /** Distinct count of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigInt']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
  /** Distinct count of isAdmin across the matching connection */
  isAdmin?: Maybe<Scalars['BigInt']>;
  /** Distinct count of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['BigInt']>;
  /** Distinct count of username across the matching connection */
  username?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `WebUser` object types. All fields are combined with a logical ‘and.’ */
export type WebUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WebUserFilter>>;
  /** Filter by the object’s `avatar` field. */
  avatar?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `discriminator` field. */
  discriminator?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WebUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WebUserFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

export type WebUserGuild = Node & {
  __typename?: 'WebUserGuild';
  /** Reads a single `CachedGuild` that is related to this `WebUserGuild`. */
  cachedGuildByGuildId?: Maybe<CachedGuild>;
  guildId: Scalars['BigInt'];
  manageGuild?: Maybe<Scalars['Boolean']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  owner: Scalars['Boolean'];
  permissions: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  /** Reads a single `WebUser` that is related to this `WebUserGuild`. */
  webUserByUserId?: Maybe<WebUser>;
};

export type WebUserGuildAggregates = {
  __typename?: 'WebUserGuildAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<WebUserGuildAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<WebUserGuildDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<WebUserGuildMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<WebUserGuildMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<WebUserGuildStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<WebUserGuildStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<WebUserGuildSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<WebUserGuildVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<WebUserGuildVarianceSampleAggregates>;
};

export type WebUserGuildAverageAggregates = {
  __typename?: 'WebUserGuildAverageAggregates';
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigFloat']>;
  /** Mean average of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/**
 * A condition to be used against `WebUserGuild` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type WebUserGuildCondition = {
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `manageGuild` field. */
  manageGuild?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `owner` field. */
  owner?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `permissions` field. */
  permissions?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type WebUserGuildDistinctCountAggregates = {
  __typename?: 'WebUserGuildDistinctCountAggregates';
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of manageGuild across the matching connection */
  manageGuild?: Maybe<Scalars['BigInt']>;
  /** Distinct count of owner across the matching connection */
  owner?: Maybe<Scalars['BigInt']>;
  /** Distinct count of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigInt']>;
  /** Distinct count of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `WebUserGuild` object types. All fields are combined with a logical ‘and.’ */
export type WebUserGuildFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WebUserGuildFilter>>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `manageGuild` field. */
  manageGuild?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WebUserGuildFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WebUserGuildFilter>>;
  /** Filter by the object’s `owner` field. */
  owner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `permissions` field. */
  permissions?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<BigIntFilter>;
};

/** An input for mutations affecting `WebUserGuild` */
export type WebUserGuildInput = {
  guildId: Scalars['BigInt'];
  manageGuild?: InputMaybe<Scalars['Boolean']>;
  owner: Scalars['Boolean'];
  permissions: Scalars['BigInt'];
  userId: Scalars['BigInt'];
};

export type WebUserGuildMaxAggregates = {
  __typename?: 'WebUserGuildMaxAggregates';
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Maximum of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigInt']>;
  /** Maximum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

export type WebUserGuildMinAggregates = {
  __typename?: 'WebUserGuildMinAggregates';
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
  /** Minimum of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigInt']>;
  /** Minimum of userId across the matching connection */
  userId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `WebUserGuild`. Fields that are set will be updated. */
export type WebUserGuildPatch = {
  guildId?: InputMaybe<Scalars['BigInt']>;
  manageGuild?: InputMaybe<Scalars['Boolean']>;
  owner?: InputMaybe<Scalars['Boolean']>;
  permissions?: InputMaybe<Scalars['BigInt']>;
  userId?: InputMaybe<Scalars['BigInt']>;
};

export type WebUserGuildStddevPopulationAggregates = {
  __typename?: 'WebUserGuildStddevPopulationAggregates';
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type WebUserGuildStddevSampleAggregates = {
  __typename?: 'WebUserGuildStddevSampleAggregates';
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type WebUserGuildSumAggregates = {
  __typename?: 'WebUserGuildSumAggregates';
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
  /** Sum of permissions across the matching connection */
  permissions: Scalars['BigFloat'];
  /** Sum of userId across the matching connection */
  userId: Scalars['BigFloat'];
};

export type WebUserGuildVariancePopulationAggregates = {
  __typename?: 'WebUserGuildVariancePopulationAggregates';
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigFloat']>;
  /** Population variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

export type WebUserGuildVarianceSampleAggregates = {
  __typename?: 'WebUserGuildVarianceSampleAggregates';
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of permissions across the matching connection */
  permissions?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of userId across the matching connection */
  userId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `WebUserGuild` values. */
export type WebUserGuildsConnection = {
  __typename?: 'WebUserGuildsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<WebUserGuildAggregates>;
  /** A list of edges which contains the `WebUserGuild` and cursor to aid in pagination. */
  edges: Array<WebUserGuildsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<WebUserGuildAggregates>>;
  /** A list of `WebUserGuild` objects. */
  nodes: Array<WebUserGuild>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WebUserGuild` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `WebUserGuild` values. */
export type WebUserGuildsConnectionGroupedAggregatesArgs = {
  groupBy: Array<WebUserGuildsGroupBy>;
  having?: InputMaybe<WebUserGuildsHavingInput>;
};

/** A `WebUserGuild` edge in the connection. */
export type WebUserGuildsEdge = {
  __typename?: 'WebUserGuildsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WebUserGuild` at the end of the edge. */
  node: WebUserGuild;
};

/** Grouping methods for `WebUserGuild` for usage during aggregation. */
export enum WebUserGuildsGroupBy {
  GuildId = 'GUILD_ID',
  ManageGuild = 'MANAGE_GUILD',
  Owner = 'OWNER',
  Permissions = 'PERMISSIONS',
  UserId = 'USER_ID'
}

export type WebUserGuildsHavingAverageInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingDistinctCountInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `WebUserGuild` aggregates. */
export type WebUserGuildsHavingInput = {
  AND?: InputMaybe<Array<WebUserGuildsHavingInput>>;
  OR?: InputMaybe<Array<WebUserGuildsHavingInput>>;
  average?: InputMaybe<WebUserGuildsHavingAverageInput>;
  distinctCount?: InputMaybe<WebUserGuildsHavingDistinctCountInput>;
  max?: InputMaybe<WebUserGuildsHavingMaxInput>;
  min?: InputMaybe<WebUserGuildsHavingMinInput>;
  stddevPopulation?: InputMaybe<WebUserGuildsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<WebUserGuildsHavingStddevSampleInput>;
  sum?: InputMaybe<WebUserGuildsHavingSumInput>;
  variancePopulation?: InputMaybe<WebUserGuildsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<WebUserGuildsHavingVarianceSampleInput>;
};

export type WebUserGuildsHavingMaxInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingMinInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingStddevPopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingStddevSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingSumInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingVariancePopulationInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

export type WebUserGuildsHavingVarianceSampleInput = {
  guildId?: InputMaybe<HavingBigintFilter>;
  permissions?: InputMaybe<HavingBigintFilter>;
  userId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `WebUserGuild`. */
export enum WebUserGuildsOrderBy {
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  ManageGuildAsc = 'MANAGE_GUILD_ASC',
  ManageGuildDesc = 'MANAGE_GUILD_DESC',
  Natural = 'NATURAL',
  OwnerAsc = 'OWNER_ASC',
  OwnerDesc = 'OWNER_DESC',
  PermissionsAsc = 'PERMISSIONS_ASC',
  PermissionsDesc = 'PERMISSIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** An input for mutations affecting `WebUser` */
export type WebUserInput = {
  /** Discord avatar hash. Null if user does not have one. */
  avatar?: InputMaybe<Scalars['String']>;
  /** First registered on the application. Is not when a user created their Discord account. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Additional profile details extracted from Discord oauth */
  details?: InputMaybe<Scalars['JSON']>;
  /** Discord disciminator of the user. */
  discriminator: Scalars['Int'];
  /** Unique identifier for the user. This should match their Discord ID. */
  id: Scalars['BigInt'];
  /** If true, the user has elevated privileges. */
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Discord username of the user. */
  username: Scalars['String'];
};

export type WebUserMaxAggregates = {
  __typename?: 'WebUserMaxAggregates';
  /** Maximum of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['Int']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
};

export type WebUserMinAggregates = {
  __typename?: 'WebUserMinAggregates';
  /** Minimum of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['Int']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `WebUser`. Fields that are set will be updated. */
export type WebUserPatch = {
  /** Discord avatar hash. Null if user does not have one. */
  avatar?: InputMaybe<Scalars['String']>;
  /** First registered on the application. Is not when a user created their Discord account. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Additional profile details extracted from Discord oauth */
  details?: InputMaybe<Scalars['JSON']>;
  /** Discord disciminator of the user. */
  discriminator?: InputMaybe<Scalars['Int']>;
  /** Unique identifier for the user. This should match their Discord ID. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** If true, the user has elevated privileges. */
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Discord username of the user. */
  username?: InputMaybe<Scalars['String']>;
};

export type WebUserStddevPopulationAggregates = {
  __typename?: 'WebUserStddevPopulationAggregates';
  /** Population standard deviation of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
};

export type WebUserStddevSampleAggregates = {
  __typename?: 'WebUserStddevSampleAggregates';
  /** Sample standard deviation of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
};

export type WebUserSumAggregates = {
  __typename?: 'WebUserSumAggregates';
  /** Sum of discriminator across the matching connection */
  discriminator: Scalars['BigInt'];
  /** Sum of id across the matching connection */
  id: Scalars['BigFloat'];
};

export type WebUserVariancePopulationAggregates = {
  __typename?: 'WebUserVariancePopulationAggregates';
  /** Population variance of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigFloat']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
};

export type WebUserVarianceSampleAggregates = {
  __typename?: 'WebUserVarianceSampleAggregates';
  /** Sample variance of discriminator across the matching connection */
  discriminator?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `WebUser` values. */
export type WebUsersConnection = {
  __typename?: 'WebUsersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<WebUserAggregates>;
  /** A list of edges which contains the `WebUser` and cursor to aid in pagination. */
  edges: Array<WebUsersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<WebUserAggregates>>;
  /** A list of `WebUser` objects. */
  nodes: Array<WebUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WebUser` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `WebUser` values. */
export type WebUsersConnectionGroupedAggregatesArgs = {
  groupBy: Array<WebUsersGroupBy>;
  having?: InputMaybe<WebUsersHavingInput>;
};

/** A `WebUser` edge in the connection. */
export type WebUsersEdge = {
  __typename?: 'WebUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `WebUser` at the end of the edge. */
  node: WebUser;
};

/** Grouping methods for `WebUser` for usage during aggregation. */
export enum WebUsersGroupBy {
  Avatar = 'AVATAR',
  CreatedAt = 'CREATED_AT',
  CreatedAtTruncatedToDay = 'CREATED_AT_TRUNCATED_TO_DAY',
  CreatedAtTruncatedToHour = 'CREATED_AT_TRUNCATED_TO_HOUR',
  Details = 'DETAILS',
  Discriminator = 'DISCRIMINATOR',
  IsAdmin = 'IS_ADMIN',
  UpdatedAt = 'UPDATED_AT',
  UpdatedAtTruncatedToDay = 'UPDATED_AT_TRUNCATED_TO_DAY',
  UpdatedAtTruncatedToHour = 'UPDATED_AT_TRUNCATED_TO_HOUR',
  Username = 'USERNAME'
}

export type WebUsersHavingAverageInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingDistinctCountInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `WebUser` aggregates. */
export type WebUsersHavingInput = {
  AND?: InputMaybe<Array<WebUsersHavingInput>>;
  OR?: InputMaybe<Array<WebUsersHavingInput>>;
  average?: InputMaybe<WebUsersHavingAverageInput>;
  distinctCount?: InputMaybe<WebUsersHavingDistinctCountInput>;
  max?: InputMaybe<WebUsersHavingMaxInput>;
  min?: InputMaybe<WebUsersHavingMinInput>;
  stddevPopulation?: InputMaybe<WebUsersHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<WebUsersHavingStddevSampleInput>;
  sum?: InputMaybe<WebUsersHavingSumInput>;
  variancePopulation?: InputMaybe<WebUsersHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<WebUsersHavingVarianceSampleInput>;
};

export type WebUsersHavingMaxInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingMinInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingStddevPopulationInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingStddevSampleInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingSumInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingVariancePopulationInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type WebUsersHavingVarianceSampleInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  discriminator?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Methods to use when ordering `WebUser`. */
export enum WebUsersOrderBy {
  AvatarAsc = 'AVATAR_ASC',
  AvatarDesc = 'AVATAR_DESC',
  CreatedAtAsc = 'CREATED_AT_ASC',
  CreatedAtDesc = 'CREATED_AT_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  DiscriminatorAsc = 'DISCRIMINATOR_ASC',
  DiscriminatorDesc = 'DISCRIMINATOR_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsAdminAsc = 'IS_ADMIN_ASC',
  IsAdminDesc = 'IS_ADMIN_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  UpdatedAtDesc = 'UPDATED_AT_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  WebUserGuildsByUserIdAverageGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_GUILD_ID_ASC',
  WebUserGuildsByUserIdAverageGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_GUILD_ID_DESC',
  WebUserGuildsByUserIdAverageManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdAverageManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdAverageOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_OWNER_ASC',
  WebUserGuildsByUserIdAverageOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_OWNER_DESC',
  WebUserGuildsByUserIdAveragePermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_PERMISSIONS_ASC',
  WebUserGuildsByUserIdAveragePermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_PERMISSIONS_DESC',
  WebUserGuildsByUserIdAverageUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_USER_ID_ASC',
  WebUserGuildsByUserIdAverageUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_AVERAGE_USER_ID_DESC',
  WebUserGuildsByUserIdCountAsc = 'WEB_USER_GUILDS_BY_USER_ID_COUNT_ASC',
  WebUserGuildsByUserIdCountDesc = 'WEB_USER_GUILDS_BY_USER_ID_COUNT_DESC',
  WebUserGuildsByUserIdDistinctCountGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_GUILD_ID_ASC',
  WebUserGuildsByUserIdDistinctCountGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_GUILD_ID_DESC',
  WebUserGuildsByUserIdDistinctCountManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdDistinctCountManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdDistinctCountOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_OWNER_ASC',
  WebUserGuildsByUserIdDistinctCountOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_OWNER_DESC',
  WebUserGuildsByUserIdDistinctCountPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_PERMISSIONS_ASC',
  WebUserGuildsByUserIdDistinctCountPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_PERMISSIONS_DESC',
  WebUserGuildsByUserIdDistinctCountUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_USER_ID_ASC',
  WebUserGuildsByUserIdDistinctCountUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_DISTINCT_COUNT_USER_ID_DESC',
  WebUserGuildsByUserIdMaxGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_GUILD_ID_ASC',
  WebUserGuildsByUserIdMaxGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_GUILD_ID_DESC',
  WebUserGuildsByUserIdMaxManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdMaxManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdMaxOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_OWNER_ASC',
  WebUserGuildsByUserIdMaxOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_OWNER_DESC',
  WebUserGuildsByUserIdMaxPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_PERMISSIONS_ASC',
  WebUserGuildsByUserIdMaxPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_PERMISSIONS_DESC',
  WebUserGuildsByUserIdMaxUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_USER_ID_ASC',
  WebUserGuildsByUserIdMaxUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_MAX_USER_ID_DESC',
  WebUserGuildsByUserIdMinGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_GUILD_ID_ASC',
  WebUserGuildsByUserIdMinGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_GUILD_ID_DESC',
  WebUserGuildsByUserIdMinManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdMinManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdMinOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_OWNER_ASC',
  WebUserGuildsByUserIdMinOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_OWNER_DESC',
  WebUserGuildsByUserIdMinPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_PERMISSIONS_ASC',
  WebUserGuildsByUserIdMinPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_PERMISSIONS_DESC',
  WebUserGuildsByUserIdMinUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_USER_ID_ASC',
  WebUserGuildsByUserIdMinUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_MIN_USER_ID_DESC',
  WebUserGuildsByUserIdStddevPopulationGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_GUILD_ID_ASC',
  WebUserGuildsByUserIdStddevPopulationGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_GUILD_ID_DESC',
  WebUserGuildsByUserIdStddevPopulationManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdStddevPopulationManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdStddevPopulationOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_OWNER_ASC',
  WebUserGuildsByUserIdStddevPopulationOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_OWNER_DESC',
  WebUserGuildsByUserIdStddevPopulationPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_PERMISSIONS_ASC',
  WebUserGuildsByUserIdStddevPopulationPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_PERMISSIONS_DESC',
  WebUserGuildsByUserIdStddevPopulationUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_USER_ID_ASC',
  WebUserGuildsByUserIdStddevPopulationUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_POPULATION_USER_ID_DESC',
  WebUserGuildsByUserIdStddevSampleGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_GUILD_ID_ASC',
  WebUserGuildsByUserIdStddevSampleGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_GUILD_ID_DESC',
  WebUserGuildsByUserIdStddevSampleManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdStddevSampleManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdStddevSampleOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_OWNER_ASC',
  WebUserGuildsByUserIdStddevSampleOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_OWNER_DESC',
  WebUserGuildsByUserIdStddevSamplePermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_PERMISSIONS_ASC',
  WebUserGuildsByUserIdStddevSamplePermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_PERMISSIONS_DESC',
  WebUserGuildsByUserIdStddevSampleUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_ASC',
  WebUserGuildsByUserIdStddevSampleUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_STDDEV_SAMPLE_USER_ID_DESC',
  WebUserGuildsByUserIdSumGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_GUILD_ID_ASC',
  WebUserGuildsByUserIdSumGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_GUILD_ID_DESC',
  WebUserGuildsByUserIdSumManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdSumManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdSumOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_OWNER_ASC',
  WebUserGuildsByUserIdSumOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_OWNER_DESC',
  WebUserGuildsByUserIdSumPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_PERMISSIONS_ASC',
  WebUserGuildsByUserIdSumPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_PERMISSIONS_DESC',
  WebUserGuildsByUserIdSumUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_USER_ID_ASC',
  WebUserGuildsByUserIdSumUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_SUM_USER_ID_DESC',
  WebUserGuildsByUserIdVariancePopulationGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_GUILD_ID_ASC',
  WebUserGuildsByUserIdVariancePopulationGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_GUILD_ID_DESC',
  WebUserGuildsByUserIdVariancePopulationManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdVariancePopulationManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdVariancePopulationOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_OWNER_ASC',
  WebUserGuildsByUserIdVariancePopulationOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_OWNER_DESC',
  WebUserGuildsByUserIdVariancePopulationPermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_PERMISSIONS_ASC',
  WebUserGuildsByUserIdVariancePopulationPermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_PERMISSIONS_DESC',
  WebUserGuildsByUserIdVariancePopulationUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_ASC',
  WebUserGuildsByUserIdVariancePopulationUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_POPULATION_USER_ID_DESC',
  WebUserGuildsByUserIdVarianceSampleGuildIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_GUILD_ID_ASC',
  WebUserGuildsByUserIdVarianceSampleGuildIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_GUILD_ID_DESC',
  WebUserGuildsByUserIdVarianceSampleManageGuildAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_MANAGE_GUILD_ASC',
  WebUserGuildsByUserIdVarianceSampleManageGuildDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_MANAGE_GUILD_DESC',
  WebUserGuildsByUserIdVarianceSampleOwnerAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_OWNER_ASC',
  WebUserGuildsByUserIdVarianceSampleOwnerDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_OWNER_DESC',
  WebUserGuildsByUserIdVarianceSamplePermissionsAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_PERMISSIONS_ASC',
  WebUserGuildsByUserIdVarianceSamplePermissionsDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_PERMISSIONS_DESC',
  WebUserGuildsByUserIdVarianceSampleUserIdAsc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_ASC',
  WebUserGuildsByUserIdVarianceSampleUserIdDesc = 'WEB_USER_GUILDS_BY_USER_ID_VARIANCE_SAMPLE_USER_ID_DESC'
}

export type XpBlock = Node & {
  __typename?: 'XpBlock';
  blockId: Scalars['BigInt'];
  blockType: BlockType;
  guildId: Scalars['BigInt'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type XpBlockAggregates = {
  __typename?: 'XpBlockAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<XpBlockAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<XpBlockDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<XpBlockMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<XpBlockMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<XpBlockStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<XpBlockStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<XpBlockSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<XpBlockVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<XpBlockVarianceSampleAggregates>;
};

export type XpBlockAverageAggregates = {
  __typename?: 'XpBlockAverageAggregates';
  /** Mean average of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigFloat']>;
  /** Mean average of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/** A condition to be used against `XpBlock` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type XpBlockCondition = {
  /** Checks for equality with the object’s `blockId` field. */
  blockId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `blockType` field. */
  blockType?: InputMaybe<BlockType>;
  /** Checks for equality with the object’s `guildId` field. */
  guildId?: InputMaybe<Scalars['BigInt']>;
};

export type XpBlockDistinctCountAggregates = {
  __typename?: 'XpBlockDistinctCountAggregates';
  /** Distinct count of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']>;
  /** Distinct count of blockType across the matching connection */
  blockType?: Maybe<Scalars['BigInt']>;
  /** Distinct count of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

/** A filter to be used against `XpBlock` object types. All fields are combined with a logical ‘and.’ */
export type XpBlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<XpBlockFilter>>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `blockType` field. */
  blockType?: InputMaybe<BlockTypeFilter>;
  /** Filter by the object’s `guildId` field. */
  guildId?: InputMaybe<BigIntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<XpBlockFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<XpBlockFilter>>;
};

/** An input for mutations affecting `XpBlock` */
export type XpBlockInput = {
  blockId: Scalars['BigInt'];
  blockType: BlockType;
  guildId: Scalars['BigInt'];
};

export type XpBlockMaxAggregates = {
  __typename?: 'XpBlockMaxAggregates';
  /** Maximum of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']>;
  /** Maximum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

export type XpBlockMinAggregates = {
  __typename?: 'XpBlockMinAggregates';
  /** Minimum of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']>;
  /** Minimum of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigInt']>;
};

/** Represents an update to a `XpBlock`. Fields that are set will be updated. */
export type XpBlockPatch = {
  blockId?: InputMaybe<Scalars['BigInt']>;
  blockType?: InputMaybe<BlockType>;
  guildId?: InputMaybe<Scalars['BigInt']>;
};

export type XpBlockStddevPopulationAggregates = {
  __typename?: 'XpBlockStddevPopulationAggregates';
  /** Population standard deviation of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigFloat']>;
  /** Population standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type XpBlockStddevSampleAggregates = {
  __typename?: 'XpBlockStddevSampleAggregates';
  /** Sample standard deviation of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigFloat']>;
  /** Sample standard deviation of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type XpBlockSumAggregates = {
  __typename?: 'XpBlockSumAggregates';
  /** Sum of blockId across the matching connection */
  blockId: Scalars['BigFloat'];
  /** Sum of guildId across the matching connection */
  guildId: Scalars['BigFloat'];
};

export type XpBlockVariancePopulationAggregates = {
  __typename?: 'XpBlockVariancePopulationAggregates';
  /** Population variance of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigFloat']>;
  /** Population variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

export type XpBlockVarianceSampleAggregates = {
  __typename?: 'XpBlockVarianceSampleAggregates';
  /** Sample variance of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigFloat']>;
  /** Sample variance of guildId across the matching connection */
  guildId?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `XpBlock` values. */
export type XpBlocksConnection = {
  __typename?: 'XpBlocksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<XpBlockAggregates>;
  /** A list of edges which contains the `XpBlock` and cursor to aid in pagination. */
  edges: Array<XpBlocksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<XpBlockAggregates>>;
  /** A list of `XpBlock` objects. */
  nodes: Array<XpBlock>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `XpBlock` you could get from the connection. */
  totalCount: Scalars['Int'];
};


/** A connection to a list of `XpBlock` values. */
export type XpBlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<XpBlocksGroupBy>;
  having?: InputMaybe<XpBlocksHavingInput>;
};

/** A `XpBlock` edge in the connection. */
export type XpBlocksEdge = {
  __typename?: 'XpBlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `XpBlock` at the end of the edge. */
  node: XpBlock;
};

/** Grouping methods for `XpBlock` for usage during aggregation. */
export enum XpBlocksGroupBy {
  BlockId = 'BLOCK_ID',
  BlockType = 'BLOCK_TYPE',
  GuildId = 'GUILD_ID'
}

export type XpBlocksHavingAverageInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingDistinctCountInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

/** Conditions for `XpBlock` aggregates. */
export type XpBlocksHavingInput = {
  AND?: InputMaybe<Array<XpBlocksHavingInput>>;
  OR?: InputMaybe<Array<XpBlocksHavingInput>>;
  average?: InputMaybe<XpBlocksHavingAverageInput>;
  distinctCount?: InputMaybe<XpBlocksHavingDistinctCountInput>;
  max?: InputMaybe<XpBlocksHavingMaxInput>;
  min?: InputMaybe<XpBlocksHavingMinInput>;
  stddevPopulation?: InputMaybe<XpBlocksHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<XpBlocksHavingStddevSampleInput>;
  sum?: InputMaybe<XpBlocksHavingSumInput>;
  variancePopulation?: InputMaybe<XpBlocksHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<XpBlocksHavingVarianceSampleInput>;
};

export type XpBlocksHavingMaxInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingMinInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingStddevPopulationInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingStddevSampleInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingSumInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingVariancePopulationInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

export type XpBlocksHavingVarianceSampleInput = {
  blockId?: InputMaybe<HavingBigintFilter>;
  guildId?: InputMaybe<HavingBigintFilter>;
};

/** Methods to use when ordering `XpBlock`. */
export enum XpBlocksOrderBy {
  BlockIdAsc = 'BLOCK_ID_ASC',
  BlockIdDesc = 'BLOCK_ID_DESC',
  BlockTypeAsc = 'BLOCK_TYPE_ASC',
  BlockTypeDesc = 'BLOCK_TYPE_DESC',
  GuildIdAsc = 'GUILD_ID_ASC',
  GuildIdDesc = 'GUILD_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AddRoleMenuRolesInput: AddRoleMenuRolesInput;
  AddRoleMenuRolesPayload: ResolverTypeWrapper<AddRoleMenuRolesPayload>;
  BigFloat: ResolverTypeWrapper<Scalars['BigFloat']>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  BigIntFilter: BigIntFilter;
  BigIntListFilter: BigIntListFilter;
  BlockType: BlockType;
  BlockTypeFilter: BlockTypeFilter;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  BooleanFilter: BooleanFilter;
  BotStat: ResolverTypeWrapper<BotStat>;
  BotStatAggregates: ResolverTypeWrapper<BotStatAggregates>;
  BotStatAverageAggregates: ResolverTypeWrapper<BotStatAverageAggregates>;
  BotStatCondition: BotStatCondition;
  BotStatDistinctCountAggregates: ResolverTypeWrapper<BotStatDistinctCountAggregates>;
  BotStatFilter: BotStatFilter;
  BotStatInput: BotStatInput;
  BotStatMaxAggregates: ResolverTypeWrapper<BotStatMaxAggregates>;
  BotStatMinAggregates: ResolverTypeWrapper<BotStatMinAggregates>;
  BotStatPatch: BotStatPatch;
  BotStatStddevPopulationAggregates: ResolverTypeWrapper<BotStatStddevPopulationAggregates>;
  BotStatStddevSampleAggregates: ResolverTypeWrapper<BotStatStddevSampleAggregates>;
  BotStatSumAggregates: ResolverTypeWrapper<BotStatSumAggregates>;
  BotStatVariancePopulationAggregates: ResolverTypeWrapper<BotStatVariancePopulationAggregates>;
  BotStatVarianceSampleAggregates: ResolverTypeWrapper<BotStatVarianceSampleAggregates>;
  BotStatsConnection: ResolverTypeWrapper<BotStatsConnection>;
  BotStatsEdge: ResolverTypeWrapper<BotStatsEdge>;
  BotStatsGroupBy: BotStatsGroupBy;
  BotStatsHavingAverageInput: BotStatsHavingAverageInput;
  BotStatsHavingDistinctCountInput: BotStatsHavingDistinctCountInput;
  BotStatsHavingInput: BotStatsHavingInput;
  BotStatsHavingMaxInput: BotStatsHavingMaxInput;
  BotStatsHavingMinInput: BotStatsHavingMinInput;
  BotStatsHavingStddevPopulationInput: BotStatsHavingStddevPopulationInput;
  BotStatsHavingStddevSampleInput: BotStatsHavingStddevSampleInput;
  BotStatsHavingSumInput: BotStatsHavingSumInput;
  BotStatsHavingVariancePopulationInput: BotStatsHavingVariancePopulationInput;
  BotStatsHavingVarianceSampleInput: BotStatsHavingVarianceSampleInput;
  BotStatsOrderBy: BotStatsOrderBy;
  BulkDeleteModLogInput: BulkDeleteModLogInput;
  BulkDeleteModLogPayload: ResolverTypeWrapper<BulkDeleteModLogPayload>;
  BulkUpdateModLogReasonInput: BulkUpdateModLogReasonInput;
  BulkUpdateModLogReasonPayload: ResolverTypeWrapper<BulkUpdateModLogReasonPayload>;
  CachedGuild: ResolverTypeWrapper<CachedGuild>;
  CachedGuildInput: CachedGuildInput;
  CachedGuildPatch: CachedGuildPatch;
  CachedGuildsEdge: ResolverTypeWrapper<CachedGuildsEdge>;
  CachedGuildsOrderBy: CachedGuildsOrderBy;
  CachedUser: ResolverTypeWrapper<CachedUser>;
  CachedUserInput: CachedUserInput;
  CachedUserPatch: CachedUserPatch;
  CachedUsersEdge: ResolverTypeWrapper<CachedUsersEdge>;
  CachedUsersOrderBy: CachedUsersOrderBy;
  CreateBotStatInput: CreateBotStatInput;
  CreateBotStatPayload: ResolverTypeWrapper<CreateBotStatPayload>;
  CreateCachedGuildInput: CreateCachedGuildInput;
  CreateCachedGuildPayload: ResolverTypeWrapper<CreateCachedGuildPayload>;
  CreateCachedUserInput: CreateCachedUserInput;
  CreateCachedUserPayload: ResolverTypeWrapper<CreateCachedUserPayload>;
  CreateEmojiStickerStatInput: CreateEmojiStickerStatInput;
  CreateEmojiStickerStatPayload: ResolverTypeWrapper<CreateEmojiStickerStatPayload>;
  CreateFeedInput: CreateFeedInput;
  CreateFeedItemInput: CreateFeedItemInput;
  CreateFeedItemPayload: ResolverTypeWrapper<CreateFeedItemPayload>;
  CreateFeedPayload: ResolverTypeWrapper<CreateFeedPayload>;
  CreateFeedSubscriptionInput: CreateFeedSubscriptionInput;
  CreateFeedSubscriptionPayload: ResolverTypeWrapper<CreateFeedSubscriptionPayload>;
  CreateGuildBanInput: CreateGuildBanInput;
  CreateGuildBanPayload: ResolverTypeWrapper<CreateGuildBanPayload>;
  CreateGuildConfigInput: CreateGuildConfigInput;
  CreateGuildConfigPayload: ResolverTypeWrapper<CreateGuildConfigPayload>;
  CreateLevelRoleApplyJobInput: CreateLevelRoleApplyJobInput;
  CreateLevelRoleApplyJobPayload: ResolverTypeWrapper<CreateLevelRoleApplyJobPayload>;
  CreateLevelRoleInput: CreateLevelRoleInput;
  CreateLevelRoleOverrideInput: CreateLevelRoleOverrideInput;
  CreateLevelRoleOverridePayload: ResolverTypeWrapper<CreateLevelRoleOverridePayload>;
  CreateLevelRolePayload: ResolverTypeWrapper<CreateLevelRolePayload>;
  CreateMemberInput: CreateMemberInput;
  CreateMemberPayload: ResolverTypeWrapper<CreateMemberPayload>;
  CreateMessageInput: CreateMessageInput;
  CreateMessagePayload: ResolverTypeWrapper<CreateMessagePayload>;
  CreateModLogInput: CreateModLogInput;
  CreateModLogPayload: ResolverTypeWrapper<CreateModLogPayload>;
  CreateMsgLogBlockInput: CreateMsgLogBlockInput;
  CreateMsgLogBlockPayload: ResolverTypeWrapper<CreateMsgLogBlockPayload>;
  CreateMuteInput: CreateMuteInput;
  CreateMutePayload: ResolverTypeWrapper<CreateMutePayload>;
  CreateNotificationInput: CreateNotificationInput;
  CreateNotificationPayload: ResolverTypeWrapper<CreateNotificationPayload>;
  CreateReminderInput: CreateReminderInput;
  CreateReminderPayload: ResolverTypeWrapper<CreateReminderPayload>;
  CreateRoleMenuInput: CreateRoleMenuInput;
  CreateRoleMenuPayload: ResolverTypeWrapper<CreateRoleMenuPayload>;
  CreateRoleMenuRoleInput: CreateRoleMenuRoleInput;
  CreateRoleMenuRolePayload: ResolverTypeWrapper<CreateRoleMenuRolePayload>;
  CreateTagInput: CreateTagInput;
  CreateTagPayload: ResolverTypeWrapper<CreateTagPayload>;
  CreateUserInput: CreateUserInput;
  CreateUserLevelInput: CreateUserLevelInput;
  CreateUserLevelPayload: ResolverTypeWrapper<CreateUserLevelPayload>;
  CreateUserPayload: ResolverTypeWrapper<CreateUserPayload>;
  CreateWebUserGuildInput: CreateWebUserGuildInput;
  CreateWebUserGuildPayload: ResolverTypeWrapper<CreateWebUserGuildPayload>;
  CreateWebUserInput: CreateWebUserInput;
  CreateWebUserPayload: ResolverTypeWrapper<CreateWebUserPayload>;
  CreateXpBlockInput: CreateXpBlockInput;
  CreateXpBlockPayload: ResolverTypeWrapper<CreateXpBlockPayload>;
  CurrentUserManagedGuildIdEdge: ResolverTypeWrapper<CurrentUserManagedGuildIdEdge>;
  CurrentUserManagedGuildIdsConnection: ResolverTypeWrapper<CurrentUserManagedGuildIdsConnection>;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']>;
  Datetime: ResolverTypeWrapper<Scalars['Datetime']>;
  DatetimeFilter: DatetimeFilter;
  DeleteBotStatByNameAndCategoryInput: DeleteBotStatByNameAndCategoryInput;
  DeleteBotStatInput: DeleteBotStatInput;
  DeleteBotStatPayload: ResolverTypeWrapper<DeleteBotStatPayload>;
  DeleteCachedGuildByIdInput: DeleteCachedGuildByIdInput;
  DeleteCachedGuildInput: DeleteCachedGuildInput;
  DeleteCachedGuildPayload: ResolverTypeWrapper<DeleteCachedGuildPayload>;
  DeleteCachedUserByIdInput: DeleteCachedUserByIdInput;
  DeleteCachedUserInput: DeleteCachedUserInput;
  DeleteCachedUserPayload: ResolverTypeWrapper<DeleteCachedUserPayload>;
  DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput: DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
  DeleteEmojiStickerStatInput: DeleteEmojiStickerStatInput;
  DeleteEmojiStickerStatPayload: ResolverTypeWrapper<DeleteEmojiStickerStatPayload>;
  DeleteFeedByFeedIdInput: DeleteFeedByFeedIdInput;
  DeleteFeedInput: DeleteFeedInput;
  DeleteFeedItemByFeedIdAndItemIdInput: DeleteFeedItemByFeedIdAndItemIdInput;
  DeleteFeedItemInput: DeleteFeedItemInput;
  DeleteFeedItemPayload: ResolverTypeWrapper<DeleteFeedItemPayload>;
  DeleteFeedPayload: ResolverTypeWrapper<DeleteFeedPayload>;
  DeleteFeedSubscriptionByFeedIdAndChannelIdInput: DeleteFeedSubscriptionByFeedIdAndChannelIdInput;
  DeleteFeedSubscriptionInput: DeleteFeedSubscriptionInput;
  DeleteFeedSubscriptionPayload: ResolverTypeWrapper<DeleteFeedSubscriptionPayload>;
  DeleteGuildBanByGuildIdAndUserIdInput: DeleteGuildBanByGuildIdAndUserIdInput;
  DeleteGuildBanInput: DeleteGuildBanInput;
  DeleteGuildBanPayload: ResolverTypeWrapper<DeleteGuildBanPayload>;
  DeleteGuildConfigByIdInput: DeleteGuildConfigByIdInput;
  DeleteGuildConfigInput: DeleteGuildConfigInput;
  DeleteGuildConfigPayload: ResolverTypeWrapper<DeleteGuildConfigPayload>;
  DeleteLevelRoleApplyJobByGuildIdInput: DeleteLevelRoleApplyJobByGuildIdInput;
  DeleteLevelRoleApplyJobByInteractionIdInput: DeleteLevelRoleApplyJobByInteractionIdInput;
  DeleteLevelRoleApplyJobInput: DeleteLevelRoleApplyJobInput;
  DeleteLevelRoleApplyJobPayload: ResolverTypeWrapper<DeleteLevelRoleApplyJobPayload>;
  DeleteLevelRoleByGuildIdAndRoleIdInput: DeleteLevelRoleByGuildIdAndRoleIdInput;
  DeleteLevelRoleInput: DeleteLevelRoleInput;
  DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput: DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
  DeleteLevelRoleOverrideInput: DeleteLevelRoleOverrideInput;
  DeleteLevelRoleOverridePayload: ResolverTypeWrapper<DeleteLevelRoleOverridePayload>;
  DeleteLevelRolePayload: ResolverTypeWrapper<DeleteLevelRolePayload>;
  DeleteMemberByGuildIdAndUserIdInput: DeleteMemberByGuildIdAndUserIdInput;
  DeleteMemberInput: DeleteMemberInput;
  DeleteMemberPayload: ResolverTypeWrapper<DeleteMemberPayload>;
  DeleteMessageByMessageIdInput: DeleteMessageByMessageIdInput;
  DeleteMessageInput: DeleteMessageInput;
  DeleteMessagePayload: ResolverTypeWrapper<DeleteMessagePayload>;
  DeleteMessagesBeforeInput: DeleteMessagesBeforeInput;
  DeleteMessagesBeforePayload: ResolverTypeWrapper<DeleteMessagesBeforePayload>;
  DeleteModLogByGuildIdAndCaseIdInput: DeleteModLogByGuildIdAndCaseIdInput;
  DeleteModLogInput: DeleteModLogInput;
  DeleteModLogPayload: ResolverTypeWrapper<DeleteModLogPayload>;
  DeleteMsgLogBlockByGuildIdAndChannelIdInput: DeleteMsgLogBlockByGuildIdAndChannelIdInput;
  DeleteMsgLogBlockInput: DeleteMsgLogBlockInput;
  DeleteMsgLogBlockPayload: ResolverTypeWrapper<DeleteMsgLogBlockPayload>;
  DeleteMuteByGuildIdAndUserIdInput: DeleteMuteByGuildIdAndUserIdInput;
  DeleteMuteInput: DeleteMuteInput;
  DeleteMutePayload: ResolverTypeWrapper<DeleteMutePayload>;
  DeleteNotificationByUserIdAndGuildIdAndKeywordInput: DeleteNotificationByUserIdAndGuildIdAndKeywordInput;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteNotificationPayload: ResolverTypeWrapper<DeleteNotificationPayload>;
  DeleteReminderByUserIdAndSetAtInput: DeleteReminderByUserIdAndSetAtInput;
  DeleteReminderInput: DeleteReminderInput;
  DeleteReminderPayload: ResolverTypeWrapper<DeleteReminderPayload>;
  DeleteRoleMenuByGuildIdAndMenuNameInput: DeleteRoleMenuByGuildIdAndMenuNameInput;
  DeleteRoleMenuInput: DeleteRoleMenuInput;
  DeleteRoleMenuPayload: ResolverTypeWrapper<DeleteRoleMenuPayload>;
  DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput: DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
  DeleteRoleMenuRoleInput: DeleteRoleMenuRoleInput;
  DeleteRoleMenuRolePayload: ResolverTypeWrapper<DeleteRoleMenuRolePayload>;
  DeleteRoleMenuRolesInput: DeleteRoleMenuRolesInput;
  DeleteRoleMenuRolesPayload: ResolverTypeWrapper<DeleteRoleMenuRolesPayload>;
  DeleteTagByGuildIdAndTagNameInput: DeleteTagByGuildIdAndTagNameInput;
  DeleteTagInput: DeleteTagInput;
  DeleteTagPayload: ResolverTypeWrapper<DeleteTagPayload>;
  DeleteUserByIdInput: DeleteUserByIdInput;
  DeleteUserInput: DeleteUserInput;
  DeleteUserLevelByUserIdAndGuildIdInput: DeleteUserLevelByUserIdAndGuildIdInput;
  DeleteUserLevelInput: DeleteUserLevelInput;
  DeleteUserLevelPayload: ResolverTypeWrapper<DeleteUserLevelPayload>;
  DeleteUserPayload: ResolverTypeWrapper<DeleteUserPayload>;
  DeleteWebUserByIdInput: DeleteWebUserByIdInput;
  DeleteWebUserGuildByUserIdAndGuildIdInput: DeleteWebUserGuildByUserIdAndGuildIdInput;
  DeleteWebUserGuildInput: DeleteWebUserGuildInput;
  DeleteWebUserGuildPayload: ResolverTypeWrapper<DeleteWebUserGuildPayload>;
  DeleteWebUserInput: DeleteWebUserInput;
  DeleteWebUserPayload: ResolverTypeWrapper<DeleteWebUserPayload>;
  DeleteXpBlockByGuildIdAndBlockIdInput: DeleteXpBlockByGuildIdAndBlockIdInput;
  DeleteXpBlockInput: DeleteXpBlockInput;
  DeleteXpBlockPayload: ResolverTypeWrapper<DeleteXpBlockPayload>;
  EligibleLevelRole: ResolverTypeWrapper<EligibleLevelRole>;
  EligibleLevelRoleFilter: EligibleLevelRoleFilter;
  EligibleLevelRolesConnection: ResolverTypeWrapper<EligibleLevelRolesConnection>;
  EligibleLevelRolesEdge: ResolverTypeWrapper<EligibleLevelRolesEdge>;
  EmojiStickerActionType: EmojiStickerActionType;
  EmojiStickerActionTypeFilter: EmojiStickerActionTypeFilter;
  EmojiStickerStat: ResolverTypeWrapper<EmojiStickerStat>;
  EmojiStickerStatAggregates: ResolverTypeWrapper<EmojiStickerStatAggregates>;
  EmojiStickerStatAverageAggregates: ResolverTypeWrapper<EmojiStickerStatAverageAggregates>;
  EmojiStickerStatCondition: EmojiStickerStatCondition;
  EmojiStickerStatDistinctCountAggregates: ResolverTypeWrapper<EmojiStickerStatDistinctCountAggregates>;
  EmojiStickerStatFilter: EmojiStickerStatFilter;
  EmojiStickerStatIncrementDatumInput: EmojiStickerStatIncrementDatumInput;
  EmojiStickerStatInput: EmojiStickerStatInput;
  EmojiStickerStatMaxAggregates: ResolverTypeWrapper<EmojiStickerStatMaxAggregates>;
  EmojiStickerStatMinAggregates: ResolverTypeWrapper<EmojiStickerStatMinAggregates>;
  EmojiStickerStatPatch: EmojiStickerStatPatch;
  EmojiStickerStatStddevPopulationAggregates: ResolverTypeWrapper<EmojiStickerStatStddevPopulationAggregates>;
  EmojiStickerStatStddevSampleAggregates: ResolverTypeWrapper<EmojiStickerStatStddevSampleAggregates>;
  EmojiStickerStatSumAggregates: ResolverTypeWrapper<EmojiStickerStatSumAggregates>;
  EmojiStickerStatVariancePopulationAggregates: ResolverTypeWrapper<EmojiStickerStatVariancePopulationAggregates>;
  EmojiStickerStatVarianceSampleAggregates: ResolverTypeWrapper<EmojiStickerStatVarianceSampleAggregates>;
  EmojiStickerStatsConnection: ResolverTypeWrapper<EmojiStickerStatsConnection>;
  EmojiStickerStatsEdge: ResolverTypeWrapper<EmojiStickerStatsEdge>;
  EmojiStickerStatsGroupBy: EmojiStickerStatsGroupBy;
  EmojiStickerStatsHavingAverageInput: EmojiStickerStatsHavingAverageInput;
  EmojiStickerStatsHavingDistinctCountInput: EmojiStickerStatsHavingDistinctCountInput;
  EmojiStickerStatsHavingInput: EmojiStickerStatsHavingInput;
  EmojiStickerStatsHavingMaxInput: EmojiStickerStatsHavingMaxInput;
  EmojiStickerStatsHavingMinInput: EmojiStickerStatsHavingMinInput;
  EmojiStickerStatsHavingStddevPopulationInput: EmojiStickerStatsHavingStddevPopulationInput;
  EmojiStickerStatsHavingStddevSampleInput: EmojiStickerStatsHavingStddevSampleInput;
  EmojiStickerStatsHavingSumInput: EmojiStickerStatsHavingSumInput;
  EmojiStickerStatsHavingVariancePopulationInput: EmojiStickerStatsHavingVariancePopulationInput;
  EmojiStickerStatsHavingVarianceSampleInput: EmojiStickerStatsHavingVarianceSampleInput;
  EmojiStickerStatsOrderBy: EmojiStickerStatsOrderBy;
  Feed: ResolverTypeWrapper<Feed>;
  FeedAggregates: ResolverTypeWrapper<FeedAggregates>;
  FeedCondition: FeedCondition;
  FeedDistinctCountAggregates: ResolverTypeWrapper<FeedDistinctCountAggregates>;
  FeedFilter: FeedFilter;
  FeedInput: FeedInput;
  FeedItem: ResolverTypeWrapper<FeedItem>;
  FeedItemAggregates: ResolverTypeWrapper<FeedItemAggregates>;
  FeedItemCondition: FeedItemCondition;
  FeedItemDistinctCountAggregates: ResolverTypeWrapper<FeedItemDistinctCountAggregates>;
  FeedItemFilter: FeedItemFilter;
  FeedItemInput: FeedItemInput;
  FeedItemPatch: FeedItemPatch;
  FeedItemsConnection: ResolverTypeWrapper<FeedItemsConnection>;
  FeedItemsEdge: ResolverTypeWrapper<FeedItemsEdge>;
  FeedItemsGroupBy: FeedItemsGroupBy;
  FeedItemsHavingInput: FeedItemsHavingInput;
  FeedItemsOrderBy: FeedItemsOrderBy;
  FeedPatch: FeedPatch;
  FeedSubscription: ResolverTypeWrapper<FeedSubscription>;
  FeedSubscriptionAggregates: ResolverTypeWrapper<FeedSubscriptionAggregates>;
  FeedSubscriptionAverageAggregates: ResolverTypeWrapper<FeedSubscriptionAverageAggregates>;
  FeedSubscriptionCondition: FeedSubscriptionCondition;
  FeedSubscriptionDistinctCountAggregates: ResolverTypeWrapper<FeedSubscriptionDistinctCountAggregates>;
  FeedSubscriptionFilter: FeedSubscriptionFilter;
  FeedSubscriptionInput: FeedSubscriptionInput;
  FeedSubscriptionMaxAggregates: ResolverTypeWrapper<FeedSubscriptionMaxAggregates>;
  FeedSubscriptionMinAggregates: ResolverTypeWrapper<FeedSubscriptionMinAggregates>;
  FeedSubscriptionPatch: FeedSubscriptionPatch;
  FeedSubscriptionStddevPopulationAggregates: ResolverTypeWrapper<FeedSubscriptionStddevPopulationAggregates>;
  FeedSubscriptionStddevSampleAggregates: ResolverTypeWrapper<FeedSubscriptionStddevSampleAggregates>;
  FeedSubscriptionSumAggregates: ResolverTypeWrapper<FeedSubscriptionSumAggregates>;
  FeedSubscriptionVariancePopulationAggregates: ResolverTypeWrapper<FeedSubscriptionVariancePopulationAggregates>;
  FeedSubscriptionVarianceSampleAggregates: ResolverTypeWrapper<FeedSubscriptionVarianceSampleAggregates>;
  FeedSubscriptionsConnection: ResolverTypeWrapper<FeedSubscriptionsConnection>;
  FeedSubscriptionsEdge: ResolverTypeWrapper<FeedSubscriptionsEdge>;
  FeedSubscriptionsGroupBy: FeedSubscriptionsGroupBy;
  FeedSubscriptionsHavingAverageInput: FeedSubscriptionsHavingAverageInput;
  FeedSubscriptionsHavingDistinctCountInput: FeedSubscriptionsHavingDistinctCountInput;
  FeedSubscriptionsHavingInput: FeedSubscriptionsHavingInput;
  FeedSubscriptionsHavingMaxInput: FeedSubscriptionsHavingMaxInput;
  FeedSubscriptionsHavingMinInput: FeedSubscriptionsHavingMinInput;
  FeedSubscriptionsHavingStddevPopulationInput: FeedSubscriptionsHavingStddevPopulationInput;
  FeedSubscriptionsHavingStddevSampleInput: FeedSubscriptionsHavingStddevSampleInput;
  FeedSubscriptionsHavingSumInput: FeedSubscriptionsHavingSumInput;
  FeedSubscriptionsHavingVariancePopulationInput: FeedSubscriptionsHavingVariancePopulationInput;
  FeedSubscriptionsHavingVarianceSampleInput: FeedSubscriptionsHavingVarianceSampleInput;
  FeedSubscriptionsOrderBy: FeedSubscriptionsOrderBy;
  FeedsConnection: ResolverTypeWrapper<FeedsConnection>;
  FeedsEdge: ResolverTypeWrapper<FeedsEdge>;
  FeedsGroupBy: FeedsGroupBy;
  FeedsHavingInput: FeedsHavingInput;
  FeedsOrderBy: FeedsOrderBy;
  GraphqlInput: GraphqlInput;
  GraphqlPayload: ResolverTypeWrapper<GraphqlPayload>;
  GuildAssetType: GuildAssetType;
  GuildAssetTypeFilter: GuildAssetTypeFilter;
  GuildBan: ResolverTypeWrapper<GuildBan>;
  GuildBanAggregates: ResolverTypeWrapper<GuildBanAggregates>;
  GuildBanAverageAggregates: ResolverTypeWrapper<GuildBanAverageAggregates>;
  GuildBanCondition: GuildBanCondition;
  GuildBanDistinctCountAggregates: ResolverTypeWrapper<GuildBanDistinctCountAggregates>;
  GuildBanFilter: GuildBanFilter;
  GuildBanInput: GuildBanInput;
  GuildBanMaxAggregates: ResolverTypeWrapper<GuildBanMaxAggregates>;
  GuildBanMinAggregates: ResolverTypeWrapper<GuildBanMinAggregates>;
  GuildBanPatch: GuildBanPatch;
  GuildBanStddevPopulationAggregates: ResolverTypeWrapper<GuildBanStddevPopulationAggregates>;
  GuildBanStddevSampleAggregates: ResolverTypeWrapper<GuildBanStddevSampleAggregates>;
  GuildBanSumAggregates: ResolverTypeWrapper<GuildBanSumAggregates>;
  GuildBanVariancePopulationAggregates: ResolverTypeWrapper<GuildBanVariancePopulationAggregates>;
  GuildBanVarianceSampleAggregates: ResolverTypeWrapper<GuildBanVarianceSampleAggregates>;
  GuildBansConnection: ResolverTypeWrapper<GuildBansConnection>;
  GuildBansEdge: ResolverTypeWrapper<GuildBansEdge>;
  GuildBansGroupBy: GuildBansGroupBy;
  GuildBansHavingAverageInput: GuildBansHavingAverageInput;
  GuildBansHavingDistinctCountInput: GuildBansHavingDistinctCountInput;
  GuildBansHavingInput: GuildBansHavingInput;
  GuildBansHavingMaxInput: GuildBansHavingMaxInput;
  GuildBansHavingMinInput: GuildBansHavingMinInput;
  GuildBansHavingStddevPopulationInput: GuildBansHavingStddevPopulationInput;
  GuildBansHavingStddevSampleInput: GuildBansHavingStddevSampleInput;
  GuildBansHavingSumInput: GuildBansHavingSumInput;
  GuildBansHavingVariancePopulationInput: GuildBansHavingVariancePopulationInput;
  GuildBansHavingVarianceSampleInput: GuildBansHavingVarianceSampleInput;
  GuildBansOrderBy: GuildBansOrderBy;
  GuildConfig: ResolverTypeWrapper<GuildConfig>;
  GuildConfigAggregates: ResolverTypeWrapper<GuildConfigAggregates>;
  GuildConfigAverageAggregates: ResolverTypeWrapper<GuildConfigAverageAggregates>;
  GuildConfigCondition: GuildConfigCondition;
  GuildConfigDistinctCountAggregates: ResolverTypeWrapper<GuildConfigDistinctCountAggregates>;
  GuildConfigFilter: GuildConfigFilter;
  GuildConfigInput: GuildConfigInput;
  GuildConfigMaxAggregates: ResolverTypeWrapper<GuildConfigMaxAggregates>;
  GuildConfigMinAggregates: ResolverTypeWrapper<GuildConfigMinAggregates>;
  GuildConfigPatch: GuildConfigPatch;
  GuildConfigStddevPopulationAggregates: ResolverTypeWrapper<GuildConfigStddevPopulationAggregates>;
  GuildConfigStddevSampleAggregates: ResolverTypeWrapper<GuildConfigStddevSampleAggregates>;
  GuildConfigSumAggregates: ResolverTypeWrapper<GuildConfigSumAggregates>;
  GuildConfigVariancePopulationAggregates: ResolverTypeWrapper<GuildConfigVariancePopulationAggregates>;
  GuildConfigVarianceSampleAggregates: ResolverTypeWrapper<GuildConfigVarianceSampleAggregates>;
  GuildConfigsConnection: ResolverTypeWrapper<GuildConfigsConnection>;
  GuildConfigsEdge: ResolverTypeWrapper<GuildConfigsEdge>;
  GuildConfigsGroupBy: GuildConfigsGroupBy;
  GuildConfigsHavingAverageInput: GuildConfigsHavingAverageInput;
  GuildConfigsHavingDistinctCountInput: GuildConfigsHavingDistinctCountInput;
  GuildConfigsHavingInput: GuildConfigsHavingInput;
  GuildConfigsHavingMaxInput: GuildConfigsHavingMaxInput;
  GuildConfigsHavingMinInput: GuildConfigsHavingMinInput;
  GuildConfigsHavingStddevPopulationInput: GuildConfigsHavingStddevPopulationInput;
  GuildConfigsHavingStddevSampleInput: GuildConfigsHavingStddevSampleInput;
  GuildConfigsHavingSumInput: GuildConfigsHavingSumInput;
  GuildConfigsHavingVariancePopulationInput: GuildConfigsHavingVariancePopulationInput;
  GuildConfigsHavingVarianceSampleInput: GuildConfigsHavingVarianceSampleInput;
  GuildConfigsOrderBy: GuildConfigsOrderBy;
  HavingBigintFilter: HavingBigintFilter;
  HavingDatetimeFilter: HavingDatetimeFilter;
  HavingIntFilter: HavingIntFilter;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  IncrementEmojiStickerStatInput: IncrementEmojiStickerStatInput;
  IncrementEmojiStickerStatPayload: ResolverTypeWrapper<IncrementEmojiStickerStatPayload>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  IntFilter: IntFilter;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  JSONFilter: JsonFilter;
  LevelRole: ResolverTypeWrapper<LevelRole>;
  LevelRoleAggregates: ResolverTypeWrapper<LevelRoleAggregates>;
  LevelRoleApplyJob: ResolverTypeWrapper<LevelRoleApplyJob>;
  LevelRoleApplyJobAggregates: ResolverTypeWrapper<LevelRoleApplyJobAggregates>;
  LevelRoleApplyJobAverageAggregates: ResolverTypeWrapper<LevelRoleApplyJobAverageAggregates>;
  LevelRoleApplyJobCondition: LevelRoleApplyJobCondition;
  LevelRoleApplyJobDistinctCountAggregates: ResolverTypeWrapper<LevelRoleApplyJobDistinctCountAggregates>;
  LevelRoleApplyJobFilter: LevelRoleApplyJobFilter;
  LevelRoleApplyJobInput: LevelRoleApplyJobInput;
  LevelRoleApplyJobMaxAggregates: ResolverTypeWrapper<LevelRoleApplyJobMaxAggregates>;
  LevelRoleApplyJobMinAggregates: ResolverTypeWrapper<LevelRoleApplyJobMinAggregates>;
  LevelRoleApplyJobPatch: LevelRoleApplyJobPatch;
  LevelRoleApplyJobStddevPopulationAggregates: ResolverTypeWrapper<LevelRoleApplyJobStddevPopulationAggregates>;
  LevelRoleApplyJobStddevSampleAggregates: ResolverTypeWrapper<LevelRoleApplyJobStddevSampleAggregates>;
  LevelRoleApplyJobSumAggregates: ResolverTypeWrapper<LevelRoleApplyJobSumAggregates>;
  LevelRoleApplyJobVariancePopulationAggregates: ResolverTypeWrapper<LevelRoleApplyJobVariancePopulationAggregates>;
  LevelRoleApplyJobVarianceSampleAggregates: ResolverTypeWrapper<LevelRoleApplyJobVarianceSampleAggregates>;
  LevelRoleApplyJobsConnection: ResolverTypeWrapper<LevelRoleApplyJobsConnection>;
  LevelRoleApplyJobsEdge: ResolverTypeWrapper<LevelRoleApplyJobsEdge>;
  LevelRoleApplyJobsGroupBy: LevelRoleApplyJobsGroupBy;
  LevelRoleApplyJobsHavingAverageInput: LevelRoleApplyJobsHavingAverageInput;
  LevelRoleApplyJobsHavingDistinctCountInput: LevelRoleApplyJobsHavingDistinctCountInput;
  LevelRoleApplyJobsHavingInput: LevelRoleApplyJobsHavingInput;
  LevelRoleApplyJobsHavingMaxInput: LevelRoleApplyJobsHavingMaxInput;
  LevelRoleApplyJobsHavingMinInput: LevelRoleApplyJobsHavingMinInput;
  LevelRoleApplyJobsHavingStddevPopulationInput: LevelRoleApplyJobsHavingStddevPopulationInput;
  LevelRoleApplyJobsHavingStddevSampleInput: LevelRoleApplyJobsHavingStddevSampleInput;
  LevelRoleApplyJobsHavingSumInput: LevelRoleApplyJobsHavingSumInput;
  LevelRoleApplyJobsHavingVariancePopulationInput: LevelRoleApplyJobsHavingVariancePopulationInput;
  LevelRoleApplyJobsHavingVarianceSampleInput: LevelRoleApplyJobsHavingVarianceSampleInput;
  LevelRoleApplyJobsOrderBy: LevelRoleApplyJobsOrderBy;
  LevelRoleAverageAggregates: ResolverTypeWrapper<LevelRoleAverageAggregates>;
  LevelRoleCondition: LevelRoleCondition;
  LevelRoleDistinctCountAggregates: ResolverTypeWrapper<LevelRoleDistinctCountAggregates>;
  LevelRoleFilter: LevelRoleFilter;
  LevelRoleInput: LevelRoleInput;
  LevelRoleMaxAggregates: ResolverTypeWrapper<LevelRoleMaxAggregates>;
  LevelRoleMinAggregates: ResolverTypeWrapper<LevelRoleMinAggregates>;
  LevelRoleOverride: ResolverTypeWrapper<LevelRoleOverride>;
  LevelRoleOverrideAggregates: ResolverTypeWrapper<LevelRoleOverrideAggregates>;
  LevelRoleOverrideAverageAggregates: ResolverTypeWrapper<LevelRoleOverrideAverageAggregates>;
  LevelRoleOverrideCondition: LevelRoleOverrideCondition;
  LevelRoleOverrideDistinctCountAggregates: ResolverTypeWrapper<LevelRoleOverrideDistinctCountAggregates>;
  LevelRoleOverrideFilter: LevelRoleOverrideFilter;
  LevelRoleOverrideInput: LevelRoleOverrideInput;
  LevelRoleOverrideMaxAggregates: ResolverTypeWrapper<LevelRoleOverrideMaxAggregates>;
  LevelRoleOverrideMinAggregates: ResolverTypeWrapper<LevelRoleOverrideMinAggregates>;
  LevelRoleOverridePatch: LevelRoleOverridePatch;
  LevelRoleOverrideStddevPopulationAggregates: ResolverTypeWrapper<LevelRoleOverrideStddevPopulationAggregates>;
  LevelRoleOverrideStddevSampleAggregates: ResolverTypeWrapper<LevelRoleOverrideStddevSampleAggregates>;
  LevelRoleOverrideSumAggregates: ResolverTypeWrapper<LevelRoleOverrideSumAggregates>;
  LevelRoleOverrideType: LevelRoleOverrideType;
  LevelRoleOverrideTypeFilter: LevelRoleOverrideTypeFilter;
  LevelRoleOverrideVariancePopulationAggregates: ResolverTypeWrapper<LevelRoleOverrideVariancePopulationAggregates>;
  LevelRoleOverrideVarianceSampleAggregates: ResolverTypeWrapper<LevelRoleOverrideVarianceSampleAggregates>;
  LevelRoleOverridesConnection: ResolverTypeWrapper<LevelRoleOverridesConnection>;
  LevelRoleOverridesEdge: ResolverTypeWrapper<LevelRoleOverridesEdge>;
  LevelRoleOverridesGroupBy: LevelRoleOverridesGroupBy;
  LevelRoleOverridesHavingAverageInput: LevelRoleOverridesHavingAverageInput;
  LevelRoleOverridesHavingDistinctCountInput: LevelRoleOverridesHavingDistinctCountInput;
  LevelRoleOverridesHavingInput: LevelRoleOverridesHavingInput;
  LevelRoleOverridesHavingMaxInput: LevelRoleOverridesHavingMaxInput;
  LevelRoleOverridesHavingMinInput: LevelRoleOverridesHavingMinInput;
  LevelRoleOverridesHavingStddevPopulationInput: LevelRoleOverridesHavingStddevPopulationInput;
  LevelRoleOverridesHavingStddevSampleInput: LevelRoleOverridesHavingStddevSampleInput;
  LevelRoleOverridesHavingSumInput: LevelRoleOverridesHavingSumInput;
  LevelRoleOverridesHavingVariancePopulationInput: LevelRoleOverridesHavingVariancePopulationInput;
  LevelRoleOverridesHavingVarianceSampleInput: LevelRoleOverridesHavingVarianceSampleInput;
  LevelRoleOverridesOrderBy: LevelRoleOverridesOrderBy;
  LevelRolePatch: LevelRolePatch;
  LevelRoleStddevPopulationAggregates: ResolverTypeWrapper<LevelRoleStddevPopulationAggregates>;
  LevelRoleStddevSampleAggregates: ResolverTypeWrapper<LevelRoleStddevSampleAggregates>;
  LevelRoleSumAggregates: ResolverTypeWrapper<LevelRoleSumAggregates>;
  LevelRoleVariancePopulationAggregates: ResolverTypeWrapper<LevelRoleVariancePopulationAggregates>;
  LevelRoleVarianceSampleAggregates: ResolverTypeWrapper<LevelRoleVarianceSampleAggregates>;
  LevelRolesConnection: ResolverTypeWrapper<LevelRolesConnection>;
  LevelRolesEdge: ResolverTypeWrapper<LevelRolesEdge>;
  LevelRolesGroupBy: LevelRolesGroupBy;
  LevelRolesHavingAverageInput: LevelRolesHavingAverageInput;
  LevelRolesHavingDistinctCountInput: LevelRolesHavingDistinctCountInput;
  LevelRolesHavingInput: LevelRolesHavingInput;
  LevelRolesHavingMaxInput: LevelRolesHavingMaxInput;
  LevelRolesHavingMinInput: LevelRolesHavingMinInput;
  LevelRolesHavingStddevPopulationInput: LevelRolesHavingStddevPopulationInput;
  LevelRolesHavingStddevSampleInput: LevelRolesHavingStddevSampleInput;
  LevelRolesHavingSumInput: LevelRolesHavingSumInput;
  LevelRolesHavingVariancePopulationInput: LevelRolesHavingVariancePopulationInput;
  LevelRolesHavingVarianceSampleInput: LevelRolesHavingVarianceSampleInput;
  LevelRolesOrderBy: LevelRolesOrderBy;
  LevelTimeframe: LevelTimeframe;
  LogoutInput: LogoutInput;
  LogoutPayload: ResolverTypeWrapper<LogoutPayload>;
  Member: ResolverTypeWrapper<Member>;
  MemberAggregates: ResolverTypeWrapper<MemberAggregates>;
  MemberAverageAggregates: ResolverTypeWrapper<MemberAverageAggregates>;
  MemberCondition: MemberCondition;
  MemberDistinctCountAggregates: ResolverTypeWrapper<MemberDistinctCountAggregates>;
  MemberFilter: MemberFilter;
  MemberInput: MemberInput;
  MemberMaxAggregates: ResolverTypeWrapper<MemberMaxAggregates>;
  MemberMinAggregates: ResolverTypeWrapper<MemberMinAggregates>;
  MemberPatch: MemberPatch;
  MemberStddevPopulationAggregates: ResolverTypeWrapper<MemberStddevPopulationAggregates>;
  MemberStddevSampleAggregates: ResolverTypeWrapper<MemberStddevSampleAggregates>;
  MemberSumAggregates: ResolverTypeWrapper<MemberSumAggregates>;
  MemberVariancePopulationAggregates: ResolverTypeWrapper<MemberVariancePopulationAggregates>;
  MemberVarianceSampleAggregates: ResolverTypeWrapper<MemberVarianceSampleAggregates>;
  MembersConnection: ResolverTypeWrapper<MembersConnection>;
  MembersEdge: ResolverTypeWrapper<MembersEdge>;
  MembersGroupBy: MembersGroupBy;
  MembersHavingAverageInput: MembersHavingAverageInput;
  MembersHavingDistinctCountInput: MembersHavingDistinctCountInput;
  MembersHavingInput: MembersHavingInput;
  MembersHavingMaxInput: MembersHavingMaxInput;
  MembersHavingMinInput: MembersHavingMinInput;
  MembersHavingStddevPopulationInput: MembersHavingStddevPopulationInput;
  MembersHavingStddevSampleInput: MembersHavingStddevSampleInput;
  MembersHavingSumInput: MembersHavingSumInput;
  MembersHavingVariancePopulationInput: MembersHavingVariancePopulationInput;
  MembersHavingVarianceSampleInput: MembersHavingVarianceSampleInput;
  MembersOrderBy: MembersOrderBy;
  Message: ResolverTypeWrapper<Message>;
  MessageAggregates: ResolverTypeWrapper<MessageAggregates>;
  MessageAverageAggregates: ResolverTypeWrapper<MessageAverageAggregates>;
  MessageCondition: MessageCondition;
  MessageDistinctCountAggregates: ResolverTypeWrapper<MessageDistinctCountAggregates>;
  MessageFilter: MessageFilter;
  MessageInput: MessageInput;
  MessageMaxAggregates: ResolverTypeWrapper<MessageMaxAggregates>;
  MessageMinAggregates: ResolverTypeWrapper<MessageMinAggregates>;
  MessagePatch: MessagePatch;
  MessageStddevPopulationAggregates: ResolverTypeWrapper<MessageStddevPopulationAggregates>;
  MessageStddevSampleAggregates: ResolverTypeWrapper<MessageStddevSampleAggregates>;
  MessageSumAggregates: ResolverTypeWrapper<MessageSumAggregates>;
  MessageVariancePopulationAggregates: ResolverTypeWrapper<MessageVariancePopulationAggregates>;
  MessageVarianceSampleAggregates: ResolverTypeWrapper<MessageVarianceSampleAggregates>;
  MessagesConnection: ResolverTypeWrapper<MessagesConnection>;
  MessagesEdge: ResolverTypeWrapper<MessagesEdge>;
  MessagesGroupBy: MessagesGroupBy;
  MessagesHavingAverageInput: MessagesHavingAverageInput;
  MessagesHavingDistinctCountInput: MessagesHavingDistinctCountInput;
  MessagesHavingInput: MessagesHavingInput;
  MessagesHavingMaxInput: MessagesHavingMaxInput;
  MessagesHavingMinInput: MessagesHavingMinInput;
  MessagesHavingStddevPopulationInput: MessagesHavingStddevPopulationInput;
  MessagesHavingStddevSampleInput: MessagesHavingStddevSampleInput;
  MessagesHavingSumInput: MessagesHavingSumInput;
  MessagesHavingVariancePopulationInput: MessagesHavingVariancePopulationInput;
  MessagesHavingVarianceSampleInput: MessagesHavingVarianceSampleInput;
  MessagesOrderBy: MessagesOrderBy;
  ModLog: ResolverTypeWrapper<ModLog>;
  ModLogAggregates: ResolverTypeWrapper<ModLogAggregates>;
  ModLogAverageAggregates: ResolverTypeWrapper<ModLogAverageAggregates>;
  ModLogCondition: ModLogCondition;
  ModLogDistinctCountAggregates: ResolverTypeWrapper<ModLogDistinctCountAggregates>;
  ModLogFilter: ModLogFilter;
  ModLogInput: ModLogInput;
  ModLogMaxAggregates: ResolverTypeWrapper<ModLogMaxAggregates>;
  ModLogMinAggregates: ResolverTypeWrapper<ModLogMinAggregates>;
  ModLogPatch: ModLogPatch;
  ModLogStddevPopulationAggregates: ResolverTypeWrapper<ModLogStddevPopulationAggregates>;
  ModLogStddevSampleAggregates: ResolverTypeWrapper<ModLogStddevSampleAggregates>;
  ModLogSumAggregates: ResolverTypeWrapper<ModLogSumAggregates>;
  ModLogVariancePopulationAggregates: ResolverTypeWrapper<ModLogVariancePopulationAggregates>;
  ModLogVarianceSampleAggregates: ResolverTypeWrapper<ModLogVarianceSampleAggregates>;
  ModLogsConnection: ResolverTypeWrapper<ModLogsConnection>;
  ModLogsEdge: ResolverTypeWrapper<ModLogsEdge>;
  ModLogsGroupBy: ModLogsGroupBy;
  ModLogsHavingAverageInput: ModLogsHavingAverageInput;
  ModLogsHavingDistinctCountInput: ModLogsHavingDistinctCountInput;
  ModLogsHavingInput: ModLogsHavingInput;
  ModLogsHavingMaxInput: ModLogsHavingMaxInput;
  ModLogsHavingMinInput: ModLogsHavingMinInput;
  ModLogsHavingStddevPopulationInput: ModLogsHavingStddevPopulationInput;
  ModLogsHavingStddevSampleInput: ModLogsHavingStddevSampleInput;
  ModLogsHavingSumInput: ModLogsHavingSumInput;
  ModLogsHavingVariancePopulationInput: ModLogsHavingVariancePopulationInput;
  ModLogsHavingVarianceSampleInput: ModLogsHavingVarianceSampleInput;
  ModLogsOrderBy: ModLogsOrderBy;
  MsgLogBlock: ResolverTypeWrapper<MsgLogBlock>;
  MsgLogBlockAggregates: ResolverTypeWrapper<MsgLogBlockAggregates>;
  MsgLogBlockAverageAggregates: ResolverTypeWrapper<MsgLogBlockAverageAggregates>;
  MsgLogBlockCondition: MsgLogBlockCondition;
  MsgLogBlockDistinctCountAggregates: ResolverTypeWrapper<MsgLogBlockDistinctCountAggregates>;
  MsgLogBlockFilter: MsgLogBlockFilter;
  MsgLogBlockInput: MsgLogBlockInput;
  MsgLogBlockMaxAggregates: ResolverTypeWrapper<MsgLogBlockMaxAggregates>;
  MsgLogBlockMinAggregates: ResolverTypeWrapper<MsgLogBlockMinAggregates>;
  MsgLogBlockPatch: MsgLogBlockPatch;
  MsgLogBlockStddevPopulationAggregates: ResolverTypeWrapper<MsgLogBlockStddevPopulationAggregates>;
  MsgLogBlockStddevSampleAggregates: ResolverTypeWrapper<MsgLogBlockStddevSampleAggregates>;
  MsgLogBlockSumAggregates: ResolverTypeWrapper<MsgLogBlockSumAggregates>;
  MsgLogBlockType: MsgLogBlockType;
  MsgLogBlockTypeFilter: MsgLogBlockTypeFilter;
  MsgLogBlockVariancePopulationAggregates: ResolverTypeWrapper<MsgLogBlockVariancePopulationAggregates>;
  MsgLogBlockVarianceSampleAggregates: ResolverTypeWrapper<MsgLogBlockVarianceSampleAggregates>;
  MsgLogBlocksConnection: ResolverTypeWrapper<MsgLogBlocksConnection>;
  MsgLogBlocksEdge: ResolverTypeWrapper<MsgLogBlocksEdge>;
  MsgLogBlocksGroupBy: MsgLogBlocksGroupBy;
  MsgLogBlocksHavingAverageInput: MsgLogBlocksHavingAverageInput;
  MsgLogBlocksHavingDistinctCountInput: MsgLogBlocksHavingDistinctCountInput;
  MsgLogBlocksHavingInput: MsgLogBlocksHavingInput;
  MsgLogBlocksHavingMaxInput: MsgLogBlocksHavingMaxInput;
  MsgLogBlocksHavingMinInput: MsgLogBlocksHavingMinInput;
  MsgLogBlocksHavingStddevPopulationInput: MsgLogBlocksHavingStddevPopulationInput;
  MsgLogBlocksHavingStddevSampleInput: MsgLogBlocksHavingStddevSampleInput;
  MsgLogBlocksHavingSumInput: MsgLogBlocksHavingSumInput;
  MsgLogBlocksHavingVariancePopulationInput: MsgLogBlocksHavingVariancePopulationInput;
  MsgLogBlocksHavingVarianceSampleInput: MsgLogBlocksHavingVarianceSampleInput;
  MsgLogBlocksOrderBy: MsgLogBlocksOrderBy;
  Mutation: ResolverTypeWrapper<{}>;
  Mute: ResolverTypeWrapper<Mute>;
  MuteAggregates: ResolverTypeWrapper<MuteAggregates>;
  MuteAverageAggregates: ResolverTypeWrapper<MuteAverageAggregates>;
  MuteCondition: MuteCondition;
  MuteDistinctCountAggregates: ResolverTypeWrapper<MuteDistinctCountAggregates>;
  MuteFilter: MuteFilter;
  MuteInput: MuteInput;
  MuteMaxAggregates: ResolverTypeWrapper<MuteMaxAggregates>;
  MuteMinAggregates: ResolverTypeWrapper<MuteMinAggregates>;
  MutePatch: MutePatch;
  MuteStddevPopulationAggregates: ResolverTypeWrapper<MuteStddevPopulationAggregates>;
  MuteStddevSampleAggregates: ResolverTypeWrapper<MuteStddevSampleAggregates>;
  MuteSumAggregates: ResolverTypeWrapper<MuteSumAggregates>;
  MuteVariancePopulationAggregates: ResolverTypeWrapper<MuteVariancePopulationAggregates>;
  MuteVarianceSampleAggregates: ResolverTypeWrapper<MuteVarianceSampleAggregates>;
  MutesConnection: ResolverTypeWrapper<MutesConnection>;
  MutesEdge: ResolverTypeWrapper<MutesEdge>;
  MutesGroupBy: MutesGroupBy;
  MutesHavingAverageInput: MutesHavingAverageInput;
  MutesHavingDistinctCountInput: MutesHavingDistinctCountInput;
  MutesHavingInput: MutesHavingInput;
  MutesHavingMaxInput: MutesHavingMaxInput;
  MutesHavingMinInput: MutesHavingMinInput;
  MutesHavingStddevPopulationInput: MutesHavingStddevPopulationInput;
  MutesHavingStddevSampleInput: MutesHavingStddevSampleInput;
  MutesHavingSumInput: MutesHavingSumInput;
  MutesHavingVariancePopulationInput: MutesHavingVariancePopulationInput;
  MutesHavingVarianceSampleInput: MutesHavingVarianceSampleInput;
  MutesOrderBy: MutesOrderBy;
  Node: ResolversTypes['BotStat'] | ResolversTypes['CachedGuild'] | ResolversTypes['CachedUser'] | ResolversTypes['EmojiStickerStat'] | ResolversTypes['Feed'] | ResolversTypes['FeedItem'] | ResolversTypes['FeedSubscription'] | ResolversTypes['GuildBan'] | ResolversTypes['GuildConfig'] | ResolversTypes['LevelRole'] | ResolversTypes['LevelRoleApplyJob'] | ResolversTypes['LevelRoleOverride'] | ResolversTypes['Member'] | ResolversTypes['Message'] | ResolversTypes['ModLog'] | ResolversTypes['MsgLogBlock'] | ResolversTypes['Mute'] | ResolversTypes['Notification'] | ResolversTypes['Query'] | ResolversTypes['Reminder'] | ResolversTypes['RoleMenu'] | ResolversTypes['RoleMenuRole'] | ResolversTypes['Tag'] | ResolversTypes['User'] | ResolversTypes['UserLevel'] | ResolversTypes['WebUser'] | ResolversTypes['WebUserGuild'] | ResolversTypes['XpBlock'];
  Notification: ResolverTypeWrapper<Notification>;
  NotificationAggregates: ResolverTypeWrapper<NotificationAggregates>;
  NotificationAverageAggregates: ResolverTypeWrapper<NotificationAverageAggregates>;
  NotificationCondition: NotificationCondition;
  NotificationDistinctCountAggregates: ResolverTypeWrapper<NotificationDistinctCountAggregates>;
  NotificationFilter: NotificationFilter;
  NotificationInput: NotificationInput;
  NotificationMaxAggregates: ResolverTypeWrapper<NotificationMaxAggregates>;
  NotificationMinAggregates: ResolverTypeWrapper<NotificationMinAggregates>;
  NotificationPatch: NotificationPatch;
  NotificationStddevPopulationAggregates: ResolverTypeWrapper<NotificationStddevPopulationAggregates>;
  NotificationStddevSampleAggregates: ResolverTypeWrapper<NotificationStddevSampleAggregates>;
  NotificationSumAggregates: ResolverTypeWrapper<NotificationSumAggregates>;
  NotificationVariancePopulationAggregates: ResolverTypeWrapper<NotificationVariancePopulationAggregates>;
  NotificationVarianceSampleAggregates: ResolverTypeWrapper<NotificationVarianceSampleAggregates>;
  NotificationsConnection: ResolverTypeWrapper<NotificationsConnection>;
  NotificationsEdge: ResolverTypeWrapper<NotificationsEdge>;
  NotificationsGroupBy: NotificationsGroupBy;
  NotificationsHavingAverageInput: NotificationsHavingAverageInput;
  NotificationsHavingDistinctCountInput: NotificationsHavingDistinctCountInput;
  NotificationsHavingInput: NotificationsHavingInput;
  NotificationsHavingMaxInput: NotificationsHavingMaxInput;
  NotificationsHavingMinInput: NotificationsHavingMinInput;
  NotificationsHavingStddevPopulationInput: NotificationsHavingStddevPopulationInput;
  NotificationsHavingStddevSampleInput: NotificationsHavingStddevSampleInput;
  NotificationsHavingSumInput: NotificationsHavingSumInput;
  NotificationsHavingVariancePopulationInput: NotificationsHavingVariancePopulationInput;
  NotificationsHavingVarianceSampleInput: NotificationsHavingVarianceSampleInput;
  NotificationsOrderBy: NotificationsOrderBy;
  NotificationsStartingWithConnection: ResolverTypeWrapper<NotificationsStartingWithConnection>;
  NotificationsStartingWithEdge: ResolverTypeWrapper<NotificationsStartingWithEdge>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Query: ResolverTypeWrapper<{}>;
  RedisGuild: ResolverTypeWrapper<RedisGuild>;
  RedisGuildRole: ResolverTypeWrapper<RedisGuildRole>;
  RedisRoleTags: ResolverTypeWrapper<RedisRoleTags>;
  Reminder: ResolverTypeWrapper<Reminder>;
  ReminderAggregates: ResolverTypeWrapper<ReminderAggregates>;
  ReminderAverageAggregates: ResolverTypeWrapper<ReminderAverageAggregates>;
  ReminderCondition: ReminderCondition;
  ReminderDistinctCountAggregates: ResolverTypeWrapper<ReminderDistinctCountAggregates>;
  ReminderFilter: ReminderFilter;
  ReminderInput: ReminderInput;
  ReminderMaxAggregates: ResolverTypeWrapper<ReminderMaxAggregates>;
  ReminderMinAggregates: ResolverTypeWrapper<ReminderMinAggregates>;
  ReminderPatch: ReminderPatch;
  ReminderStddevPopulationAggregates: ResolverTypeWrapper<ReminderStddevPopulationAggregates>;
  ReminderStddevSampleAggregates: ResolverTypeWrapper<ReminderStddevSampleAggregates>;
  ReminderSumAggregates: ResolverTypeWrapper<ReminderSumAggregates>;
  ReminderVariancePopulationAggregates: ResolverTypeWrapper<ReminderVariancePopulationAggregates>;
  ReminderVarianceSampleAggregates: ResolverTypeWrapper<ReminderVarianceSampleAggregates>;
  RemindersConnection: ResolverTypeWrapper<RemindersConnection>;
  RemindersEdge: ResolverTypeWrapper<RemindersEdge>;
  RemindersGroupBy: RemindersGroupBy;
  RemindersHavingAverageInput: RemindersHavingAverageInput;
  RemindersHavingDistinctCountInput: RemindersHavingDistinctCountInput;
  RemindersHavingInput: RemindersHavingInput;
  RemindersHavingMaxInput: RemindersHavingMaxInput;
  RemindersHavingMinInput: RemindersHavingMinInput;
  RemindersHavingStddevPopulationInput: RemindersHavingStddevPopulationInput;
  RemindersHavingStddevSampleInput: RemindersHavingStddevSampleInput;
  RemindersHavingSumInput: RemindersHavingSumInput;
  RemindersHavingVariancePopulationInput: RemindersHavingVariancePopulationInput;
  RemindersHavingVarianceSampleInput: RemindersHavingVarianceSampleInput;
  RemindersOrderBy: RemindersOrderBy;
  RoleMenu: ResolverTypeWrapper<RoleMenu>;
  RoleMenuAggregates: ResolverTypeWrapper<RoleMenuAggregates>;
  RoleMenuAverageAggregates: ResolverTypeWrapper<RoleMenuAverageAggregates>;
  RoleMenuCondition: RoleMenuCondition;
  RoleMenuDistinctCountAggregates: ResolverTypeWrapper<RoleMenuDistinctCountAggregates>;
  RoleMenuFilter: RoleMenuFilter;
  RoleMenuInput: RoleMenuInput;
  RoleMenuMaxAggregates: ResolverTypeWrapper<RoleMenuMaxAggregates>;
  RoleMenuMinAggregates: ResolverTypeWrapper<RoleMenuMinAggregates>;
  RoleMenuPatch: RoleMenuPatch;
  RoleMenuRole: ResolverTypeWrapper<RoleMenuRole>;
  RoleMenuRoleAggregates: ResolverTypeWrapper<RoleMenuRoleAggregates>;
  RoleMenuRoleAverageAggregates: ResolverTypeWrapper<RoleMenuRoleAverageAggregates>;
  RoleMenuRoleCondition: RoleMenuRoleCondition;
  RoleMenuRoleDistinctCountAggregates: ResolverTypeWrapper<RoleMenuRoleDistinctCountAggregates>;
  RoleMenuRoleFilter: RoleMenuRoleFilter;
  RoleMenuRoleInput: RoleMenuRoleInput;
  RoleMenuRoleMaxAggregates: ResolverTypeWrapper<RoleMenuRoleMaxAggregates>;
  RoleMenuRoleMinAggregates: ResolverTypeWrapper<RoleMenuRoleMinAggregates>;
  RoleMenuRolePatch: RoleMenuRolePatch;
  RoleMenuRoleStddevPopulationAggregates: ResolverTypeWrapper<RoleMenuRoleStddevPopulationAggregates>;
  RoleMenuRoleStddevSampleAggregates: ResolverTypeWrapper<RoleMenuRoleStddevSampleAggregates>;
  RoleMenuRoleSumAggregates: ResolverTypeWrapper<RoleMenuRoleSumAggregates>;
  RoleMenuRoleVariancePopulationAggregates: ResolverTypeWrapper<RoleMenuRoleVariancePopulationAggregates>;
  RoleMenuRoleVarianceSampleAggregates: ResolverTypeWrapper<RoleMenuRoleVarianceSampleAggregates>;
  RoleMenuRolesConnection: ResolverTypeWrapper<RoleMenuRolesConnection>;
  RoleMenuRolesEdge: ResolverTypeWrapper<RoleMenuRolesEdge>;
  RoleMenuRolesGroupBy: RoleMenuRolesGroupBy;
  RoleMenuRolesHavingAverageInput: RoleMenuRolesHavingAverageInput;
  RoleMenuRolesHavingDistinctCountInput: RoleMenuRolesHavingDistinctCountInput;
  RoleMenuRolesHavingInput: RoleMenuRolesHavingInput;
  RoleMenuRolesHavingMaxInput: RoleMenuRolesHavingMaxInput;
  RoleMenuRolesHavingMinInput: RoleMenuRolesHavingMinInput;
  RoleMenuRolesHavingStddevPopulationInput: RoleMenuRolesHavingStddevPopulationInput;
  RoleMenuRolesHavingStddevSampleInput: RoleMenuRolesHavingStddevSampleInput;
  RoleMenuRolesHavingSumInput: RoleMenuRolesHavingSumInput;
  RoleMenuRolesHavingVariancePopulationInput: RoleMenuRolesHavingVariancePopulationInput;
  RoleMenuRolesHavingVarianceSampleInput: RoleMenuRolesHavingVarianceSampleInput;
  RoleMenuRolesOrderBy: RoleMenuRolesOrderBy;
  RoleMenuStddevPopulationAggregates: ResolverTypeWrapper<RoleMenuStddevPopulationAggregates>;
  RoleMenuStddevSampleAggregates: ResolverTypeWrapper<RoleMenuStddevSampleAggregates>;
  RoleMenuSumAggregates: ResolverTypeWrapper<RoleMenuSumAggregates>;
  RoleMenuVariancePopulationAggregates: ResolverTypeWrapper<RoleMenuVariancePopulationAggregates>;
  RoleMenuVarianceSampleAggregates: ResolverTypeWrapper<RoleMenuVarianceSampleAggregates>;
  RoleMenusConnection: ResolverTypeWrapper<RoleMenusConnection>;
  RoleMenusEdge: ResolverTypeWrapper<RoleMenusEdge>;
  RoleMenusGroupBy: RoleMenusGroupBy;
  RoleMenusHavingAverageInput: RoleMenusHavingAverageInput;
  RoleMenusHavingDistinctCountInput: RoleMenusHavingDistinctCountInput;
  RoleMenusHavingInput: RoleMenusHavingInput;
  RoleMenusHavingMaxInput: RoleMenusHavingMaxInput;
  RoleMenusHavingMinInput: RoleMenusHavingMinInput;
  RoleMenusHavingStddevPopulationInput: RoleMenusHavingStddevPopulationInput;
  RoleMenusHavingStddevSampleInput: RoleMenusHavingStddevSampleInput;
  RoleMenusHavingSumInput: RoleMenusHavingSumInput;
  RoleMenusHavingVariancePopulationInput: RoleMenusHavingVariancePopulationInput;
  RoleMenusHavingVarianceSampleInput: RoleMenusHavingVarianceSampleInput;
  RoleMenusOrderBy: RoleMenusOrderBy;
  SetRoleMenuRoleOrderInput: SetRoleMenuRoleOrderInput;
  SetRoleMenuRoleOrderPayload: ResolverTypeWrapper<SetRoleMenuRoleOrderPayload>;
  String: ResolverTypeWrapper<Scalars['String']>;
  StringFilter: StringFilter;
  StringListFilter: StringListFilter;
  Tag: ResolverTypeWrapper<Tag>;
  TagAggregates: ResolverTypeWrapper<TagAggregates>;
  TagAverageAggregates: ResolverTypeWrapper<TagAverageAggregates>;
  TagCondition: TagCondition;
  TagDistinctCountAggregates: ResolverTypeWrapper<TagDistinctCountAggregates>;
  TagFilter: TagFilter;
  TagInput: TagInput;
  TagMaxAggregates: ResolverTypeWrapper<TagMaxAggregates>;
  TagMinAggregates: ResolverTypeWrapper<TagMinAggregates>;
  TagPatch: TagPatch;
  TagStddevPopulationAggregates: ResolverTypeWrapper<TagStddevPopulationAggregates>;
  TagStddevSampleAggregates: ResolverTypeWrapper<TagStddevSampleAggregates>;
  TagSumAggregates: ResolverTypeWrapper<TagSumAggregates>;
  TagVariancePopulationAggregates: ResolverTypeWrapper<TagVariancePopulationAggregates>;
  TagVarianceSampleAggregates: ResolverTypeWrapper<TagVarianceSampleAggregates>;
  TagsConnection: ResolverTypeWrapper<TagsConnection>;
  TagsEdge: ResolverTypeWrapper<TagsEdge>;
  TagsGroupBy: TagsGroupBy;
  TagsHavingAverageInput: TagsHavingAverageInput;
  TagsHavingDistinctCountInput: TagsHavingDistinctCountInput;
  TagsHavingInput: TagsHavingInput;
  TagsHavingMaxInput: TagsHavingMaxInput;
  TagsHavingMinInput: TagsHavingMinInput;
  TagsHavingStddevPopulationInput: TagsHavingStddevPopulationInput;
  TagsHavingStddevSampleInput: TagsHavingStddevSampleInput;
  TagsHavingSumInput: TagsHavingSumInput;
  TagsHavingVariancePopulationInput: TagsHavingVariancePopulationInput;
  TagsHavingVarianceSampleInput: TagsHavingVarianceSampleInput;
  TagsOrderBy: TagsOrderBy;
  TimeframeUserLevelEdge: ResolverTypeWrapper<TimeframeUserLevelEdge>;
  TimeframeUserLevelsConnection: ResolverTypeWrapper<TimeframeUserLevelsConnection>;
  TimeframeUserLevelsRecord: ResolverTypeWrapper<TimeframeUserLevelsRecord>;
  TimeframeUserLevelsRecordFilter: TimeframeUserLevelsRecordFilter;
  UUID: ResolverTypeWrapper<Scalars['UUID']>;
  UpdateBotStatByNameAndCategoryInput: UpdateBotStatByNameAndCategoryInput;
  UpdateBotStatInput: UpdateBotStatInput;
  UpdateBotStatPayload: ResolverTypeWrapper<UpdateBotStatPayload>;
  UpdateCachedGuildByIdInput: UpdateCachedGuildByIdInput;
  UpdateCachedGuildInput: UpdateCachedGuildInput;
  UpdateCachedGuildPayload: ResolverTypeWrapper<UpdateCachedGuildPayload>;
  UpdateCachedUserByIdInput: UpdateCachedUserByIdInput;
  UpdateCachedUserInput: UpdateCachedUserInput;
  UpdateCachedUserPayload: ResolverTypeWrapper<UpdateCachedUserPayload>;
  UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput: UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
  UpdateEmojiStickerStatInput: UpdateEmojiStickerStatInput;
  UpdateEmojiStickerStatPayload: ResolverTypeWrapper<UpdateEmojiStickerStatPayload>;
  UpdateFeedByFeedIdInput: UpdateFeedByFeedIdInput;
  UpdateFeedInput: UpdateFeedInput;
  UpdateFeedItemByFeedIdAndItemIdInput: UpdateFeedItemByFeedIdAndItemIdInput;
  UpdateFeedItemInput: UpdateFeedItemInput;
  UpdateFeedItemPayload: ResolverTypeWrapper<UpdateFeedItemPayload>;
  UpdateFeedPayload: ResolverTypeWrapper<UpdateFeedPayload>;
  UpdateFeedSubscriptionByFeedIdAndChannelIdInput: UpdateFeedSubscriptionByFeedIdAndChannelIdInput;
  UpdateFeedSubscriptionInput: UpdateFeedSubscriptionInput;
  UpdateFeedSubscriptionPayload: ResolverTypeWrapper<UpdateFeedSubscriptionPayload>;
  UpdateGuildBanByGuildIdAndUserIdInput: UpdateGuildBanByGuildIdAndUserIdInput;
  UpdateGuildBanInput: UpdateGuildBanInput;
  UpdateGuildBanPayload: ResolverTypeWrapper<UpdateGuildBanPayload>;
  UpdateGuildConfigByIdInput: UpdateGuildConfigByIdInput;
  UpdateGuildConfigInput: UpdateGuildConfigInput;
  UpdateGuildConfigPayload: ResolverTypeWrapper<UpdateGuildConfigPayload>;
  UpdateLevelRoleApplyJobByGuildIdInput: UpdateLevelRoleApplyJobByGuildIdInput;
  UpdateLevelRoleApplyJobByInteractionIdInput: UpdateLevelRoleApplyJobByInteractionIdInput;
  UpdateLevelRoleApplyJobInput: UpdateLevelRoleApplyJobInput;
  UpdateLevelRoleApplyJobPayload: ResolverTypeWrapper<UpdateLevelRoleApplyJobPayload>;
  UpdateLevelRoleByGuildIdAndRoleIdInput: UpdateLevelRoleByGuildIdAndRoleIdInput;
  UpdateLevelRoleInput: UpdateLevelRoleInput;
  UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput: UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
  UpdateLevelRoleOverrideInput: UpdateLevelRoleOverrideInput;
  UpdateLevelRoleOverridePayload: ResolverTypeWrapper<UpdateLevelRoleOverridePayload>;
  UpdateLevelRolePayload: ResolverTypeWrapper<UpdateLevelRolePayload>;
  UpdateMemberByGuildIdAndUserIdInput: UpdateMemberByGuildIdAndUserIdInput;
  UpdateMemberInput: UpdateMemberInput;
  UpdateMemberPayload: ResolverTypeWrapper<UpdateMemberPayload>;
  UpdateMessageByMessageIdInput: UpdateMessageByMessageIdInput;
  UpdateMessageInput: UpdateMessageInput;
  UpdateMessagePayload: ResolverTypeWrapper<UpdateMessagePayload>;
  UpdateModLogByGuildIdAndCaseIdInput: UpdateModLogByGuildIdAndCaseIdInput;
  UpdateModLogInput: UpdateModLogInput;
  UpdateModLogPayload: ResolverTypeWrapper<UpdateModLogPayload>;
  UpdateMsgLogBlockByGuildIdAndChannelIdInput: UpdateMsgLogBlockByGuildIdAndChannelIdInput;
  UpdateMsgLogBlockInput: UpdateMsgLogBlockInput;
  UpdateMsgLogBlockPayload: ResolverTypeWrapper<UpdateMsgLogBlockPayload>;
  UpdateMuteByGuildIdAndUserIdInput: UpdateMuteByGuildIdAndUserIdInput;
  UpdateMuteInput: UpdateMuteInput;
  UpdateMutePayload: ResolverTypeWrapper<UpdateMutePayload>;
  UpdateNotificationByUserIdAndGuildIdAndKeywordInput: UpdateNotificationByUserIdAndGuildIdAndKeywordInput;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateNotificationPayload: ResolverTypeWrapper<UpdateNotificationPayload>;
  UpdateReminderByUserIdAndSetAtInput: UpdateReminderByUserIdAndSetAtInput;
  UpdateReminderInput: UpdateReminderInput;
  UpdateReminderPayload: ResolverTypeWrapper<UpdateReminderPayload>;
  UpdateRoleMenuByGuildIdAndMenuNameInput: UpdateRoleMenuByGuildIdAndMenuNameInput;
  UpdateRoleMenuInput: UpdateRoleMenuInput;
  UpdateRoleMenuPayload: ResolverTypeWrapper<UpdateRoleMenuPayload>;
  UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput: UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
  UpdateRoleMenuRoleInput: UpdateRoleMenuRoleInput;
  UpdateRoleMenuRolePayload: ResolverTypeWrapper<UpdateRoleMenuRolePayload>;
  UpdateTagByGuildIdAndTagNameInput: UpdateTagByGuildIdAndTagNameInput;
  UpdateTagInput: UpdateTagInput;
  UpdateTagPayload: ResolverTypeWrapper<UpdateTagPayload>;
  UpdateUserByIdInput: UpdateUserByIdInput;
  UpdateUserInput: UpdateUserInput;
  UpdateUserLevelByUserIdAndGuildIdInput: UpdateUserLevelByUserIdAndGuildIdInput;
  UpdateUserLevelInput: UpdateUserLevelInput;
  UpdateUserLevelPayload: ResolverTypeWrapper<UpdateUserLevelPayload>;
  UpdateUserPayload: ResolverTypeWrapper<UpdateUserPayload>;
  UpdateUserXpInput: UpdateUserXpInput;
  UpdateUserXpPayload: ResolverTypeWrapper<UpdateUserXpPayload>;
  UpdateWebUserByIdInput: UpdateWebUserByIdInput;
  UpdateWebUserGuildByUserIdAndGuildIdInput: UpdateWebUserGuildByUserIdAndGuildIdInput;
  UpdateWebUserGuildInput: UpdateWebUserGuildInput;
  UpdateWebUserGuildPayload: ResolverTypeWrapper<UpdateWebUserGuildPayload>;
  UpdateWebUserInput: UpdateWebUserInput;
  UpdateWebUserPayload: ResolverTypeWrapper<UpdateWebUserPayload>;
  UpdateXpBlockByGuildIdAndBlockIdInput: UpdateXpBlockByGuildIdAndBlockIdInput;
  UpdateXpBlockInput: UpdateXpBlockInput;
  UpdateXpBlockPayload: ResolverTypeWrapper<UpdateXpBlockPayload>;
  UpsertBotStatInput: UpsertBotStatInput;
  UpsertBotStatPayload: ResolverTypeWrapper<UpsertBotStatPayload>;
  UpsertBotStatWhere: UpsertBotStatWhere;
  UpsertCachedGuildInput: UpsertCachedGuildInput;
  UpsertCachedGuildPayload: ResolverTypeWrapper<UpsertCachedGuildPayload>;
  UpsertCachedGuildWhere: UpsertCachedGuildWhere;
  UpsertCachedUserInput: UpsertCachedUserInput;
  UpsertCachedUserPayload: ResolverTypeWrapper<UpsertCachedUserPayload>;
  UpsertCachedUserWhere: UpsertCachedUserWhere;
  UpsertEmojiStickerStatInput: UpsertEmojiStickerStatInput;
  UpsertEmojiStickerStatPayload: ResolverTypeWrapper<UpsertEmojiStickerStatPayload>;
  UpsertEmojiStickerStatWhere: UpsertEmojiStickerStatWhere;
  UpsertFeedInput: UpsertFeedInput;
  UpsertFeedItemInput: UpsertFeedItemInput;
  UpsertFeedItemPayload: ResolverTypeWrapper<UpsertFeedItemPayload>;
  UpsertFeedItemWhere: UpsertFeedItemWhere;
  UpsertFeedPayload: ResolverTypeWrapper<UpsertFeedPayload>;
  UpsertFeedSubscriptionInput: UpsertFeedSubscriptionInput;
  UpsertFeedSubscriptionPayload: ResolverTypeWrapper<UpsertFeedSubscriptionPayload>;
  UpsertFeedSubscriptionWhere: UpsertFeedSubscriptionWhere;
  UpsertFeedWhere: UpsertFeedWhere;
  UpsertGuildBanInput: UpsertGuildBanInput;
  UpsertGuildBanPayload: ResolverTypeWrapper<UpsertGuildBanPayload>;
  UpsertGuildBanWhere: UpsertGuildBanWhere;
  UpsertGuildConfigInput: UpsertGuildConfigInput;
  UpsertGuildConfigPayload: ResolverTypeWrapper<UpsertGuildConfigPayload>;
  UpsertGuildConfigWhere: UpsertGuildConfigWhere;
  UpsertLevelRoleApplyJobInput: UpsertLevelRoleApplyJobInput;
  UpsertLevelRoleApplyJobPayload: ResolverTypeWrapper<UpsertLevelRoleApplyJobPayload>;
  UpsertLevelRoleApplyJobWhere: UpsertLevelRoleApplyJobWhere;
  UpsertLevelRoleInput: UpsertLevelRoleInput;
  UpsertLevelRoleOverrideInput: UpsertLevelRoleOverrideInput;
  UpsertLevelRoleOverridePayload: ResolverTypeWrapper<UpsertLevelRoleOverridePayload>;
  UpsertLevelRoleOverrideWhere: UpsertLevelRoleOverrideWhere;
  UpsertLevelRolePayload: ResolverTypeWrapper<UpsertLevelRolePayload>;
  UpsertLevelRoleWhere: UpsertLevelRoleWhere;
  UpsertMemberInput: UpsertMemberInput;
  UpsertMemberPayload: ResolverTypeWrapper<UpsertMemberPayload>;
  UpsertMemberWhere: UpsertMemberWhere;
  UpsertMessageInput: UpsertMessageInput;
  UpsertMessagePayload: ResolverTypeWrapper<UpsertMessagePayload>;
  UpsertMessageWhere: UpsertMessageWhere;
  UpsertModLogInput: UpsertModLogInput;
  UpsertModLogPayload: ResolverTypeWrapper<UpsertModLogPayload>;
  UpsertModLogWhere: UpsertModLogWhere;
  UpsertMsgLogBlockInput: UpsertMsgLogBlockInput;
  UpsertMsgLogBlockPayload: ResolverTypeWrapper<UpsertMsgLogBlockPayload>;
  UpsertMsgLogBlockWhere: UpsertMsgLogBlockWhere;
  UpsertMuteInput: UpsertMuteInput;
  UpsertMutePayload: ResolverTypeWrapper<UpsertMutePayload>;
  UpsertMuteWhere: UpsertMuteWhere;
  UpsertNotificationInput: UpsertNotificationInput;
  UpsertNotificationPayload: ResolverTypeWrapper<UpsertNotificationPayload>;
  UpsertNotificationWhere: UpsertNotificationWhere;
  UpsertReminderInput: UpsertReminderInput;
  UpsertReminderPayload: ResolverTypeWrapper<UpsertReminderPayload>;
  UpsertReminderWhere: UpsertReminderWhere;
  UpsertRoleMenuInput: UpsertRoleMenuInput;
  UpsertRoleMenuPayload: ResolverTypeWrapper<UpsertRoleMenuPayload>;
  UpsertRoleMenuRoleInput: UpsertRoleMenuRoleInput;
  UpsertRoleMenuRolePayload: ResolverTypeWrapper<UpsertRoleMenuRolePayload>;
  UpsertRoleMenuRoleWhere: UpsertRoleMenuRoleWhere;
  UpsertRoleMenuWhere: UpsertRoleMenuWhere;
  UpsertTagInput: UpsertTagInput;
  UpsertTagPayload: ResolverTypeWrapper<UpsertTagPayload>;
  UpsertTagWhere: UpsertTagWhere;
  UpsertUserInput: UpsertUserInput;
  UpsertUserLevelInput: UpsertUserLevelInput;
  UpsertUserLevelPayload: ResolverTypeWrapper<UpsertUserLevelPayload>;
  UpsertUserLevelWhere: UpsertUserLevelWhere;
  UpsertUserPayload: ResolverTypeWrapper<UpsertUserPayload>;
  UpsertUserWhere: UpsertUserWhere;
  UpsertWebUserGuildInput: UpsertWebUserGuildInput;
  UpsertWebUserGuildPayload: ResolverTypeWrapper<UpsertWebUserGuildPayload>;
  UpsertWebUserGuildWhere: UpsertWebUserGuildWhere;
  UpsertWebUserInput: UpsertWebUserInput;
  UpsertWebUserPayload: ResolverTypeWrapper<UpsertWebUserPayload>;
  UpsertWebUserWhere: UpsertWebUserWhere;
  UpsertXpBlockInput: UpsertXpBlockInput;
  UpsertXpBlockPayload: ResolverTypeWrapper<UpsertXpBlockPayload>;
  UpsertXpBlockWhere: UpsertXpBlockWhere;
  User: ResolverTypeWrapper<User>;
  UserAggregates: ResolverTypeWrapper<UserAggregates>;
  UserAverageAggregates: ResolverTypeWrapper<UserAverageAggregates>;
  UserCondition: UserCondition;
  UserDistinctCountAggregates: ResolverTypeWrapper<UserDistinctCountAggregates>;
  UserFilter: UserFilter;
  UserGuildRankResult: ResolverTypeWrapper<UserGuildRankResult>;
  UserInput: UserInput;
  UserLevel: ResolverTypeWrapper<UserLevel>;
  UserLevelAggregates: ResolverTypeWrapper<UserLevelAggregates>;
  UserLevelAverageAggregates: ResolverTypeWrapper<UserLevelAverageAggregates>;
  UserLevelCondition: UserLevelCondition;
  UserLevelDistinctCountAggregates: ResolverTypeWrapper<UserLevelDistinctCountAggregates>;
  UserLevelFilter: UserLevelFilter;
  UserLevelInput: UserLevelInput;
  UserLevelMaxAggregates: ResolverTypeWrapper<UserLevelMaxAggregates>;
  UserLevelMinAggregates: ResolverTypeWrapper<UserLevelMinAggregates>;
  UserLevelPatch: UserLevelPatch;
  UserLevelStddevPopulationAggregates: ResolverTypeWrapper<UserLevelStddevPopulationAggregates>;
  UserLevelStddevSampleAggregates: ResolverTypeWrapper<UserLevelStddevSampleAggregates>;
  UserLevelSumAggregates: ResolverTypeWrapper<UserLevelSumAggregates>;
  UserLevelVariancePopulationAggregates: ResolverTypeWrapper<UserLevelVariancePopulationAggregates>;
  UserLevelVarianceSampleAggregates: ResolverTypeWrapper<UserLevelVarianceSampleAggregates>;
  UserLevelsConnection: ResolverTypeWrapper<UserLevelsConnection>;
  UserLevelsEdge: ResolverTypeWrapper<UserLevelsEdge>;
  UserLevelsGroupBy: UserLevelsGroupBy;
  UserLevelsHavingAverageInput: UserLevelsHavingAverageInput;
  UserLevelsHavingDistinctCountInput: UserLevelsHavingDistinctCountInput;
  UserLevelsHavingInput: UserLevelsHavingInput;
  UserLevelsHavingMaxInput: UserLevelsHavingMaxInput;
  UserLevelsHavingMinInput: UserLevelsHavingMinInput;
  UserLevelsHavingStddevPopulationInput: UserLevelsHavingStddevPopulationInput;
  UserLevelsHavingStddevSampleInput: UserLevelsHavingStddevSampleInput;
  UserLevelsHavingSumInput: UserLevelsHavingSumInput;
  UserLevelsHavingVariancePopulationInput: UserLevelsHavingVariancePopulationInput;
  UserLevelsHavingVarianceSampleInput: UserLevelsHavingVarianceSampleInput;
  UserLevelsOrderBy: UserLevelsOrderBy;
  UserMaxAggregates: ResolverTypeWrapper<UserMaxAggregates>;
  UserMinAggregates: ResolverTypeWrapper<UserMinAggregates>;
  UserPatch: UserPatch;
  UserStddevPopulationAggregates: ResolverTypeWrapper<UserStddevPopulationAggregates>;
  UserStddevSampleAggregates: ResolverTypeWrapper<UserStddevSampleAggregates>;
  UserSumAggregates: ResolverTypeWrapper<UserSumAggregates>;
  UserVariancePopulationAggregates: ResolverTypeWrapper<UserVariancePopulationAggregates>;
  UserVarianceSampleAggregates: ResolverTypeWrapper<UserVarianceSampleAggregates>;
  UserXpUpdateResult: ResolverTypeWrapper<UserXpUpdateResult>;
  UsersConnection: ResolverTypeWrapper<UsersConnection>;
  UsersEdge: ResolverTypeWrapper<UsersEdge>;
  UsersGroupBy: UsersGroupBy;
  UsersHavingAverageInput: UsersHavingAverageInput;
  UsersHavingDistinctCountInput: UsersHavingDistinctCountInput;
  UsersHavingInput: UsersHavingInput;
  UsersHavingMaxInput: UsersHavingMaxInput;
  UsersHavingMinInput: UsersHavingMinInput;
  UsersHavingStddevPopulationInput: UsersHavingStddevPopulationInput;
  UsersHavingStddevSampleInput: UsersHavingStddevSampleInput;
  UsersHavingSumInput: UsersHavingSumInput;
  UsersHavingVariancePopulationInput: UsersHavingVariancePopulationInput;
  UsersHavingVarianceSampleInput: UsersHavingVarianceSampleInput;
  UsersOrderBy: UsersOrderBy;
  WebUser: ResolverTypeWrapper<WebUser>;
  WebUserAggregates: ResolverTypeWrapper<WebUserAggregates>;
  WebUserAverageAggregates: ResolverTypeWrapper<WebUserAverageAggregates>;
  WebUserCondition: WebUserCondition;
  WebUserDistinctCountAggregates: ResolverTypeWrapper<WebUserDistinctCountAggregates>;
  WebUserFilter: WebUserFilter;
  WebUserGuild: ResolverTypeWrapper<WebUserGuild>;
  WebUserGuildAggregates: ResolverTypeWrapper<WebUserGuildAggregates>;
  WebUserGuildAverageAggregates: ResolverTypeWrapper<WebUserGuildAverageAggregates>;
  WebUserGuildCondition: WebUserGuildCondition;
  WebUserGuildDistinctCountAggregates: ResolverTypeWrapper<WebUserGuildDistinctCountAggregates>;
  WebUserGuildFilter: WebUserGuildFilter;
  WebUserGuildInput: WebUserGuildInput;
  WebUserGuildMaxAggregates: ResolverTypeWrapper<WebUserGuildMaxAggregates>;
  WebUserGuildMinAggregates: ResolverTypeWrapper<WebUserGuildMinAggregates>;
  WebUserGuildPatch: WebUserGuildPatch;
  WebUserGuildStddevPopulationAggregates: ResolverTypeWrapper<WebUserGuildStddevPopulationAggregates>;
  WebUserGuildStddevSampleAggregates: ResolverTypeWrapper<WebUserGuildStddevSampleAggregates>;
  WebUserGuildSumAggregates: ResolverTypeWrapper<WebUserGuildSumAggregates>;
  WebUserGuildVariancePopulationAggregates: ResolverTypeWrapper<WebUserGuildVariancePopulationAggregates>;
  WebUserGuildVarianceSampleAggregates: ResolverTypeWrapper<WebUserGuildVarianceSampleAggregates>;
  WebUserGuildsConnection: ResolverTypeWrapper<WebUserGuildsConnection>;
  WebUserGuildsEdge: ResolverTypeWrapper<WebUserGuildsEdge>;
  WebUserGuildsGroupBy: WebUserGuildsGroupBy;
  WebUserGuildsHavingAverageInput: WebUserGuildsHavingAverageInput;
  WebUserGuildsHavingDistinctCountInput: WebUserGuildsHavingDistinctCountInput;
  WebUserGuildsHavingInput: WebUserGuildsHavingInput;
  WebUserGuildsHavingMaxInput: WebUserGuildsHavingMaxInput;
  WebUserGuildsHavingMinInput: WebUserGuildsHavingMinInput;
  WebUserGuildsHavingStddevPopulationInput: WebUserGuildsHavingStddevPopulationInput;
  WebUserGuildsHavingStddevSampleInput: WebUserGuildsHavingStddevSampleInput;
  WebUserGuildsHavingSumInput: WebUserGuildsHavingSumInput;
  WebUserGuildsHavingVariancePopulationInput: WebUserGuildsHavingVariancePopulationInput;
  WebUserGuildsHavingVarianceSampleInput: WebUserGuildsHavingVarianceSampleInput;
  WebUserGuildsOrderBy: WebUserGuildsOrderBy;
  WebUserInput: WebUserInput;
  WebUserMaxAggregates: ResolverTypeWrapper<WebUserMaxAggregates>;
  WebUserMinAggregates: ResolverTypeWrapper<WebUserMinAggregates>;
  WebUserPatch: WebUserPatch;
  WebUserStddevPopulationAggregates: ResolverTypeWrapper<WebUserStddevPopulationAggregates>;
  WebUserStddevSampleAggregates: ResolverTypeWrapper<WebUserStddevSampleAggregates>;
  WebUserSumAggregates: ResolverTypeWrapper<WebUserSumAggregates>;
  WebUserVariancePopulationAggregates: ResolverTypeWrapper<WebUserVariancePopulationAggregates>;
  WebUserVarianceSampleAggregates: ResolverTypeWrapper<WebUserVarianceSampleAggregates>;
  WebUsersConnection: ResolverTypeWrapper<WebUsersConnection>;
  WebUsersEdge: ResolverTypeWrapper<WebUsersEdge>;
  WebUsersGroupBy: WebUsersGroupBy;
  WebUsersHavingAverageInput: WebUsersHavingAverageInput;
  WebUsersHavingDistinctCountInput: WebUsersHavingDistinctCountInput;
  WebUsersHavingInput: WebUsersHavingInput;
  WebUsersHavingMaxInput: WebUsersHavingMaxInput;
  WebUsersHavingMinInput: WebUsersHavingMinInput;
  WebUsersHavingStddevPopulationInput: WebUsersHavingStddevPopulationInput;
  WebUsersHavingStddevSampleInput: WebUsersHavingStddevSampleInput;
  WebUsersHavingSumInput: WebUsersHavingSumInput;
  WebUsersHavingVariancePopulationInput: WebUsersHavingVariancePopulationInput;
  WebUsersHavingVarianceSampleInput: WebUsersHavingVarianceSampleInput;
  WebUsersOrderBy: WebUsersOrderBy;
  XpBlock: ResolverTypeWrapper<XpBlock>;
  XpBlockAggregates: ResolverTypeWrapper<XpBlockAggregates>;
  XpBlockAverageAggregates: ResolverTypeWrapper<XpBlockAverageAggregates>;
  XpBlockCondition: XpBlockCondition;
  XpBlockDistinctCountAggregates: ResolverTypeWrapper<XpBlockDistinctCountAggregates>;
  XpBlockFilter: XpBlockFilter;
  XpBlockInput: XpBlockInput;
  XpBlockMaxAggregates: ResolverTypeWrapper<XpBlockMaxAggregates>;
  XpBlockMinAggregates: ResolverTypeWrapper<XpBlockMinAggregates>;
  XpBlockPatch: XpBlockPatch;
  XpBlockStddevPopulationAggregates: ResolverTypeWrapper<XpBlockStddevPopulationAggregates>;
  XpBlockStddevSampleAggregates: ResolverTypeWrapper<XpBlockStddevSampleAggregates>;
  XpBlockSumAggregates: ResolverTypeWrapper<XpBlockSumAggregates>;
  XpBlockVariancePopulationAggregates: ResolverTypeWrapper<XpBlockVariancePopulationAggregates>;
  XpBlockVarianceSampleAggregates: ResolverTypeWrapper<XpBlockVarianceSampleAggregates>;
  XpBlocksConnection: ResolverTypeWrapper<XpBlocksConnection>;
  XpBlocksEdge: ResolverTypeWrapper<XpBlocksEdge>;
  XpBlocksGroupBy: XpBlocksGroupBy;
  XpBlocksHavingAverageInput: XpBlocksHavingAverageInput;
  XpBlocksHavingDistinctCountInput: XpBlocksHavingDistinctCountInput;
  XpBlocksHavingInput: XpBlocksHavingInput;
  XpBlocksHavingMaxInput: XpBlocksHavingMaxInput;
  XpBlocksHavingMinInput: XpBlocksHavingMinInput;
  XpBlocksHavingStddevPopulationInput: XpBlocksHavingStddevPopulationInput;
  XpBlocksHavingStddevSampleInput: XpBlocksHavingStddevSampleInput;
  XpBlocksHavingSumInput: XpBlocksHavingSumInput;
  XpBlocksHavingVariancePopulationInput: XpBlocksHavingVariancePopulationInput;
  XpBlocksHavingVarianceSampleInput: XpBlocksHavingVarianceSampleInput;
  XpBlocksOrderBy: XpBlocksOrderBy;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AddRoleMenuRolesInput: AddRoleMenuRolesInput;
  AddRoleMenuRolesPayload: AddRoleMenuRolesPayload;
  BigFloat: Scalars['BigFloat'];
  BigInt: Scalars['BigInt'];
  BigIntFilter: BigIntFilter;
  BigIntListFilter: BigIntListFilter;
  BlockTypeFilter: BlockTypeFilter;
  Boolean: Scalars['Boolean'];
  BooleanFilter: BooleanFilter;
  BotStat: BotStat;
  BotStatAggregates: BotStatAggregates;
  BotStatAverageAggregates: BotStatAverageAggregates;
  BotStatCondition: BotStatCondition;
  BotStatDistinctCountAggregates: BotStatDistinctCountAggregates;
  BotStatFilter: BotStatFilter;
  BotStatInput: BotStatInput;
  BotStatMaxAggregates: BotStatMaxAggregates;
  BotStatMinAggregates: BotStatMinAggregates;
  BotStatPatch: BotStatPatch;
  BotStatStddevPopulationAggregates: BotStatStddevPopulationAggregates;
  BotStatStddevSampleAggregates: BotStatStddevSampleAggregates;
  BotStatSumAggregates: BotStatSumAggregates;
  BotStatVariancePopulationAggregates: BotStatVariancePopulationAggregates;
  BotStatVarianceSampleAggregates: BotStatVarianceSampleAggregates;
  BotStatsConnection: BotStatsConnection;
  BotStatsEdge: BotStatsEdge;
  BotStatsHavingAverageInput: BotStatsHavingAverageInput;
  BotStatsHavingDistinctCountInput: BotStatsHavingDistinctCountInput;
  BotStatsHavingInput: BotStatsHavingInput;
  BotStatsHavingMaxInput: BotStatsHavingMaxInput;
  BotStatsHavingMinInput: BotStatsHavingMinInput;
  BotStatsHavingStddevPopulationInput: BotStatsHavingStddevPopulationInput;
  BotStatsHavingStddevSampleInput: BotStatsHavingStddevSampleInput;
  BotStatsHavingSumInput: BotStatsHavingSumInput;
  BotStatsHavingVariancePopulationInput: BotStatsHavingVariancePopulationInput;
  BotStatsHavingVarianceSampleInput: BotStatsHavingVarianceSampleInput;
  BulkDeleteModLogInput: BulkDeleteModLogInput;
  BulkDeleteModLogPayload: BulkDeleteModLogPayload;
  BulkUpdateModLogReasonInput: BulkUpdateModLogReasonInput;
  BulkUpdateModLogReasonPayload: BulkUpdateModLogReasonPayload;
  CachedGuild: CachedGuild;
  CachedGuildInput: CachedGuildInput;
  CachedGuildPatch: CachedGuildPatch;
  CachedGuildsEdge: CachedGuildsEdge;
  CachedUser: CachedUser;
  CachedUserInput: CachedUserInput;
  CachedUserPatch: CachedUserPatch;
  CachedUsersEdge: CachedUsersEdge;
  CreateBotStatInput: CreateBotStatInput;
  CreateBotStatPayload: CreateBotStatPayload;
  CreateCachedGuildInput: CreateCachedGuildInput;
  CreateCachedGuildPayload: CreateCachedGuildPayload;
  CreateCachedUserInput: CreateCachedUserInput;
  CreateCachedUserPayload: CreateCachedUserPayload;
  CreateEmojiStickerStatInput: CreateEmojiStickerStatInput;
  CreateEmojiStickerStatPayload: CreateEmojiStickerStatPayload;
  CreateFeedInput: CreateFeedInput;
  CreateFeedItemInput: CreateFeedItemInput;
  CreateFeedItemPayload: CreateFeedItemPayload;
  CreateFeedPayload: CreateFeedPayload;
  CreateFeedSubscriptionInput: CreateFeedSubscriptionInput;
  CreateFeedSubscriptionPayload: CreateFeedSubscriptionPayload;
  CreateGuildBanInput: CreateGuildBanInput;
  CreateGuildBanPayload: CreateGuildBanPayload;
  CreateGuildConfigInput: CreateGuildConfigInput;
  CreateGuildConfigPayload: CreateGuildConfigPayload;
  CreateLevelRoleApplyJobInput: CreateLevelRoleApplyJobInput;
  CreateLevelRoleApplyJobPayload: CreateLevelRoleApplyJobPayload;
  CreateLevelRoleInput: CreateLevelRoleInput;
  CreateLevelRoleOverrideInput: CreateLevelRoleOverrideInput;
  CreateLevelRoleOverridePayload: CreateLevelRoleOverridePayload;
  CreateLevelRolePayload: CreateLevelRolePayload;
  CreateMemberInput: CreateMemberInput;
  CreateMemberPayload: CreateMemberPayload;
  CreateMessageInput: CreateMessageInput;
  CreateMessagePayload: CreateMessagePayload;
  CreateModLogInput: CreateModLogInput;
  CreateModLogPayload: CreateModLogPayload;
  CreateMsgLogBlockInput: CreateMsgLogBlockInput;
  CreateMsgLogBlockPayload: CreateMsgLogBlockPayload;
  CreateMuteInput: CreateMuteInput;
  CreateMutePayload: CreateMutePayload;
  CreateNotificationInput: CreateNotificationInput;
  CreateNotificationPayload: CreateNotificationPayload;
  CreateReminderInput: CreateReminderInput;
  CreateReminderPayload: CreateReminderPayload;
  CreateRoleMenuInput: CreateRoleMenuInput;
  CreateRoleMenuPayload: CreateRoleMenuPayload;
  CreateRoleMenuRoleInput: CreateRoleMenuRoleInput;
  CreateRoleMenuRolePayload: CreateRoleMenuRolePayload;
  CreateTagInput: CreateTagInput;
  CreateTagPayload: CreateTagPayload;
  CreateUserInput: CreateUserInput;
  CreateUserLevelInput: CreateUserLevelInput;
  CreateUserLevelPayload: CreateUserLevelPayload;
  CreateUserPayload: CreateUserPayload;
  CreateWebUserGuildInput: CreateWebUserGuildInput;
  CreateWebUserGuildPayload: CreateWebUserGuildPayload;
  CreateWebUserInput: CreateWebUserInput;
  CreateWebUserPayload: CreateWebUserPayload;
  CreateXpBlockInput: CreateXpBlockInput;
  CreateXpBlockPayload: CreateXpBlockPayload;
  CurrentUserManagedGuildIdEdge: CurrentUserManagedGuildIdEdge;
  CurrentUserManagedGuildIdsConnection: CurrentUserManagedGuildIdsConnection;
  Cursor: Scalars['Cursor'];
  Datetime: Scalars['Datetime'];
  DatetimeFilter: DatetimeFilter;
  DeleteBotStatByNameAndCategoryInput: DeleteBotStatByNameAndCategoryInput;
  DeleteBotStatInput: DeleteBotStatInput;
  DeleteBotStatPayload: DeleteBotStatPayload;
  DeleteCachedGuildByIdInput: DeleteCachedGuildByIdInput;
  DeleteCachedGuildInput: DeleteCachedGuildInput;
  DeleteCachedGuildPayload: DeleteCachedGuildPayload;
  DeleteCachedUserByIdInput: DeleteCachedUserByIdInput;
  DeleteCachedUserInput: DeleteCachedUserInput;
  DeleteCachedUserPayload: DeleteCachedUserPayload;
  DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput: DeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
  DeleteEmojiStickerStatInput: DeleteEmojiStickerStatInput;
  DeleteEmojiStickerStatPayload: DeleteEmojiStickerStatPayload;
  DeleteFeedByFeedIdInput: DeleteFeedByFeedIdInput;
  DeleteFeedInput: DeleteFeedInput;
  DeleteFeedItemByFeedIdAndItemIdInput: DeleteFeedItemByFeedIdAndItemIdInput;
  DeleteFeedItemInput: DeleteFeedItemInput;
  DeleteFeedItemPayload: DeleteFeedItemPayload;
  DeleteFeedPayload: DeleteFeedPayload;
  DeleteFeedSubscriptionByFeedIdAndChannelIdInput: DeleteFeedSubscriptionByFeedIdAndChannelIdInput;
  DeleteFeedSubscriptionInput: DeleteFeedSubscriptionInput;
  DeleteFeedSubscriptionPayload: DeleteFeedSubscriptionPayload;
  DeleteGuildBanByGuildIdAndUserIdInput: DeleteGuildBanByGuildIdAndUserIdInput;
  DeleteGuildBanInput: DeleteGuildBanInput;
  DeleteGuildBanPayload: DeleteGuildBanPayload;
  DeleteGuildConfigByIdInput: DeleteGuildConfigByIdInput;
  DeleteGuildConfigInput: DeleteGuildConfigInput;
  DeleteGuildConfigPayload: DeleteGuildConfigPayload;
  DeleteLevelRoleApplyJobByGuildIdInput: DeleteLevelRoleApplyJobByGuildIdInput;
  DeleteLevelRoleApplyJobByInteractionIdInput: DeleteLevelRoleApplyJobByInteractionIdInput;
  DeleteLevelRoleApplyJobInput: DeleteLevelRoleApplyJobInput;
  DeleteLevelRoleApplyJobPayload: DeleteLevelRoleApplyJobPayload;
  DeleteLevelRoleByGuildIdAndRoleIdInput: DeleteLevelRoleByGuildIdAndRoleIdInput;
  DeleteLevelRoleInput: DeleteLevelRoleInput;
  DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput: DeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
  DeleteLevelRoleOverrideInput: DeleteLevelRoleOverrideInput;
  DeleteLevelRoleOverridePayload: DeleteLevelRoleOverridePayload;
  DeleteLevelRolePayload: DeleteLevelRolePayload;
  DeleteMemberByGuildIdAndUserIdInput: DeleteMemberByGuildIdAndUserIdInput;
  DeleteMemberInput: DeleteMemberInput;
  DeleteMemberPayload: DeleteMemberPayload;
  DeleteMessageByMessageIdInput: DeleteMessageByMessageIdInput;
  DeleteMessageInput: DeleteMessageInput;
  DeleteMessagePayload: DeleteMessagePayload;
  DeleteMessagesBeforeInput: DeleteMessagesBeforeInput;
  DeleteMessagesBeforePayload: DeleteMessagesBeforePayload;
  DeleteModLogByGuildIdAndCaseIdInput: DeleteModLogByGuildIdAndCaseIdInput;
  DeleteModLogInput: DeleteModLogInput;
  DeleteModLogPayload: DeleteModLogPayload;
  DeleteMsgLogBlockByGuildIdAndChannelIdInput: DeleteMsgLogBlockByGuildIdAndChannelIdInput;
  DeleteMsgLogBlockInput: DeleteMsgLogBlockInput;
  DeleteMsgLogBlockPayload: DeleteMsgLogBlockPayload;
  DeleteMuteByGuildIdAndUserIdInput: DeleteMuteByGuildIdAndUserIdInput;
  DeleteMuteInput: DeleteMuteInput;
  DeleteMutePayload: DeleteMutePayload;
  DeleteNotificationByUserIdAndGuildIdAndKeywordInput: DeleteNotificationByUserIdAndGuildIdAndKeywordInput;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteNotificationPayload: DeleteNotificationPayload;
  DeleteReminderByUserIdAndSetAtInput: DeleteReminderByUserIdAndSetAtInput;
  DeleteReminderInput: DeleteReminderInput;
  DeleteReminderPayload: DeleteReminderPayload;
  DeleteRoleMenuByGuildIdAndMenuNameInput: DeleteRoleMenuByGuildIdAndMenuNameInput;
  DeleteRoleMenuInput: DeleteRoleMenuInput;
  DeleteRoleMenuPayload: DeleteRoleMenuPayload;
  DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput: DeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
  DeleteRoleMenuRoleInput: DeleteRoleMenuRoleInput;
  DeleteRoleMenuRolePayload: DeleteRoleMenuRolePayload;
  DeleteRoleMenuRolesInput: DeleteRoleMenuRolesInput;
  DeleteRoleMenuRolesPayload: DeleteRoleMenuRolesPayload;
  DeleteTagByGuildIdAndTagNameInput: DeleteTagByGuildIdAndTagNameInput;
  DeleteTagInput: DeleteTagInput;
  DeleteTagPayload: DeleteTagPayload;
  DeleteUserByIdInput: DeleteUserByIdInput;
  DeleteUserInput: DeleteUserInput;
  DeleteUserLevelByUserIdAndGuildIdInput: DeleteUserLevelByUserIdAndGuildIdInput;
  DeleteUserLevelInput: DeleteUserLevelInput;
  DeleteUserLevelPayload: DeleteUserLevelPayload;
  DeleteUserPayload: DeleteUserPayload;
  DeleteWebUserByIdInput: DeleteWebUserByIdInput;
  DeleteWebUserGuildByUserIdAndGuildIdInput: DeleteWebUserGuildByUserIdAndGuildIdInput;
  DeleteWebUserGuildInput: DeleteWebUserGuildInput;
  DeleteWebUserGuildPayload: DeleteWebUserGuildPayload;
  DeleteWebUserInput: DeleteWebUserInput;
  DeleteWebUserPayload: DeleteWebUserPayload;
  DeleteXpBlockByGuildIdAndBlockIdInput: DeleteXpBlockByGuildIdAndBlockIdInput;
  DeleteXpBlockInput: DeleteXpBlockInput;
  DeleteXpBlockPayload: DeleteXpBlockPayload;
  EligibleLevelRole: EligibleLevelRole;
  EligibleLevelRoleFilter: EligibleLevelRoleFilter;
  EligibleLevelRolesConnection: EligibleLevelRolesConnection;
  EligibleLevelRolesEdge: EligibleLevelRolesEdge;
  EmojiStickerActionTypeFilter: EmojiStickerActionTypeFilter;
  EmojiStickerStat: EmojiStickerStat;
  EmojiStickerStatAggregates: EmojiStickerStatAggregates;
  EmojiStickerStatAverageAggregates: EmojiStickerStatAverageAggregates;
  EmojiStickerStatCondition: EmojiStickerStatCondition;
  EmojiStickerStatDistinctCountAggregates: EmojiStickerStatDistinctCountAggregates;
  EmojiStickerStatFilter: EmojiStickerStatFilter;
  EmojiStickerStatIncrementDatumInput: EmojiStickerStatIncrementDatumInput;
  EmojiStickerStatInput: EmojiStickerStatInput;
  EmojiStickerStatMaxAggregates: EmojiStickerStatMaxAggregates;
  EmojiStickerStatMinAggregates: EmojiStickerStatMinAggregates;
  EmojiStickerStatPatch: EmojiStickerStatPatch;
  EmojiStickerStatStddevPopulationAggregates: EmojiStickerStatStddevPopulationAggregates;
  EmojiStickerStatStddevSampleAggregates: EmojiStickerStatStddevSampleAggregates;
  EmojiStickerStatSumAggregates: EmojiStickerStatSumAggregates;
  EmojiStickerStatVariancePopulationAggregates: EmojiStickerStatVariancePopulationAggregates;
  EmojiStickerStatVarianceSampleAggregates: EmojiStickerStatVarianceSampleAggregates;
  EmojiStickerStatsConnection: EmojiStickerStatsConnection;
  EmojiStickerStatsEdge: EmojiStickerStatsEdge;
  EmojiStickerStatsHavingAverageInput: EmojiStickerStatsHavingAverageInput;
  EmojiStickerStatsHavingDistinctCountInput: EmojiStickerStatsHavingDistinctCountInput;
  EmojiStickerStatsHavingInput: EmojiStickerStatsHavingInput;
  EmojiStickerStatsHavingMaxInput: EmojiStickerStatsHavingMaxInput;
  EmojiStickerStatsHavingMinInput: EmojiStickerStatsHavingMinInput;
  EmojiStickerStatsHavingStddevPopulationInput: EmojiStickerStatsHavingStddevPopulationInput;
  EmojiStickerStatsHavingStddevSampleInput: EmojiStickerStatsHavingStddevSampleInput;
  EmojiStickerStatsHavingSumInput: EmojiStickerStatsHavingSumInput;
  EmojiStickerStatsHavingVariancePopulationInput: EmojiStickerStatsHavingVariancePopulationInput;
  EmojiStickerStatsHavingVarianceSampleInput: EmojiStickerStatsHavingVarianceSampleInput;
  Feed: Feed;
  FeedAggregates: FeedAggregates;
  FeedCondition: FeedCondition;
  FeedDistinctCountAggregates: FeedDistinctCountAggregates;
  FeedFilter: FeedFilter;
  FeedInput: FeedInput;
  FeedItem: FeedItem;
  FeedItemAggregates: FeedItemAggregates;
  FeedItemCondition: FeedItemCondition;
  FeedItemDistinctCountAggregates: FeedItemDistinctCountAggregates;
  FeedItemFilter: FeedItemFilter;
  FeedItemInput: FeedItemInput;
  FeedItemPatch: FeedItemPatch;
  FeedItemsConnection: FeedItemsConnection;
  FeedItemsEdge: FeedItemsEdge;
  FeedItemsHavingInput: FeedItemsHavingInput;
  FeedPatch: FeedPatch;
  FeedSubscription: FeedSubscription;
  FeedSubscriptionAggregates: FeedSubscriptionAggregates;
  FeedSubscriptionAverageAggregates: FeedSubscriptionAverageAggregates;
  FeedSubscriptionCondition: FeedSubscriptionCondition;
  FeedSubscriptionDistinctCountAggregates: FeedSubscriptionDistinctCountAggregates;
  FeedSubscriptionFilter: FeedSubscriptionFilter;
  FeedSubscriptionInput: FeedSubscriptionInput;
  FeedSubscriptionMaxAggregates: FeedSubscriptionMaxAggregates;
  FeedSubscriptionMinAggregates: FeedSubscriptionMinAggregates;
  FeedSubscriptionPatch: FeedSubscriptionPatch;
  FeedSubscriptionStddevPopulationAggregates: FeedSubscriptionStddevPopulationAggregates;
  FeedSubscriptionStddevSampleAggregates: FeedSubscriptionStddevSampleAggregates;
  FeedSubscriptionSumAggregates: FeedSubscriptionSumAggregates;
  FeedSubscriptionVariancePopulationAggregates: FeedSubscriptionVariancePopulationAggregates;
  FeedSubscriptionVarianceSampleAggregates: FeedSubscriptionVarianceSampleAggregates;
  FeedSubscriptionsConnection: FeedSubscriptionsConnection;
  FeedSubscriptionsEdge: FeedSubscriptionsEdge;
  FeedSubscriptionsHavingAverageInput: FeedSubscriptionsHavingAverageInput;
  FeedSubscriptionsHavingDistinctCountInput: FeedSubscriptionsHavingDistinctCountInput;
  FeedSubscriptionsHavingInput: FeedSubscriptionsHavingInput;
  FeedSubscriptionsHavingMaxInput: FeedSubscriptionsHavingMaxInput;
  FeedSubscriptionsHavingMinInput: FeedSubscriptionsHavingMinInput;
  FeedSubscriptionsHavingStddevPopulationInput: FeedSubscriptionsHavingStddevPopulationInput;
  FeedSubscriptionsHavingStddevSampleInput: FeedSubscriptionsHavingStddevSampleInput;
  FeedSubscriptionsHavingSumInput: FeedSubscriptionsHavingSumInput;
  FeedSubscriptionsHavingVariancePopulationInput: FeedSubscriptionsHavingVariancePopulationInput;
  FeedSubscriptionsHavingVarianceSampleInput: FeedSubscriptionsHavingVarianceSampleInput;
  FeedsConnection: FeedsConnection;
  FeedsEdge: FeedsEdge;
  FeedsHavingInput: FeedsHavingInput;
  GraphqlInput: GraphqlInput;
  GraphqlPayload: GraphqlPayload;
  GuildAssetTypeFilter: GuildAssetTypeFilter;
  GuildBan: GuildBan;
  GuildBanAggregates: GuildBanAggregates;
  GuildBanAverageAggregates: GuildBanAverageAggregates;
  GuildBanCondition: GuildBanCondition;
  GuildBanDistinctCountAggregates: GuildBanDistinctCountAggregates;
  GuildBanFilter: GuildBanFilter;
  GuildBanInput: GuildBanInput;
  GuildBanMaxAggregates: GuildBanMaxAggregates;
  GuildBanMinAggregates: GuildBanMinAggregates;
  GuildBanPatch: GuildBanPatch;
  GuildBanStddevPopulationAggregates: GuildBanStddevPopulationAggregates;
  GuildBanStddevSampleAggregates: GuildBanStddevSampleAggregates;
  GuildBanSumAggregates: GuildBanSumAggregates;
  GuildBanVariancePopulationAggregates: GuildBanVariancePopulationAggregates;
  GuildBanVarianceSampleAggregates: GuildBanVarianceSampleAggregates;
  GuildBansConnection: GuildBansConnection;
  GuildBansEdge: GuildBansEdge;
  GuildBansHavingAverageInput: GuildBansHavingAverageInput;
  GuildBansHavingDistinctCountInput: GuildBansHavingDistinctCountInput;
  GuildBansHavingInput: GuildBansHavingInput;
  GuildBansHavingMaxInput: GuildBansHavingMaxInput;
  GuildBansHavingMinInput: GuildBansHavingMinInput;
  GuildBansHavingStddevPopulationInput: GuildBansHavingStddevPopulationInput;
  GuildBansHavingStddevSampleInput: GuildBansHavingStddevSampleInput;
  GuildBansHavingSumInput: GuildBansHavingSumInput;
  GuildBansHavingVariancePopulationInput: GuildBansHavingVariancePopulationInput;
  GuildBansHavingVarianceSampleInput: GuildBansHavingVarianceSampleInput;
  GuildConfig: GuildConfig;
  GuildConfigAggregates: GuildConfigAggregates;
  GuildConfigAverageAggregates: GuildConfigAverageAggregates;
  GuildConfigCondition: GuildConfigCondition;
  GuildConfigDistinctCountAggregates: GuildConfigDistinctCountAggregates;
  GuildConfigFilter: GuildConfigFilter;
  GuildConfigInput: GuildConfigInput;
  GuildConfigMaxAggregates: GuildConfigMaxAggregates;
  GuildConfigMinAggregates: GuildConfigMinAggregates;
  GuildConfigPatch: GuildConfigPatch;
  GuildConfigStddevPopulationAggregates: GuildConfigStddevPopulationAggregates;
  GuildConfigStddevSampleAggregates: GuildConfigStddevSampleAggregates;
  GuildConfigSumAggregates: GuildConfigSumAggregates;
  GuildConfigVariancePopulationAggregates: GuildConfigVariancePopulationAggregates;
  GuildConfigVarianceSampleAggregates: GuildConfigVarianceSampleAggregates;
  GuildConfigsConnection: GuildConfigsConnection;
  GuildConfigsEdge: GuildConfigsEdge;
  GuildConfigsHavingAverageInput: GuildConfigsHavingAverageInput;
  GuildConfigsHavingDistinctCountInput: GuildConfigsHavingDistinctCountInput;
  GuildConfigsHavingInput: GuildConfigsHavingInput;
  GuildConfigsHavingMaxInput: GuildConfigsHavingMaxInput;
  GuildConfigsHavingMinInput: GuildConfigsHavingMinInput;
  GuildConfigsHavingStddevPopulationInput: GuildConfigsHavingStddevPopulationInput;
  GuildConfigsHavingStddevSampleInput: GuildConfigsHavingStddevSampleInput;
  GuildConfigsHavingSumInput: GuildConfigsHavingSumInput;
  GuildConfigsHavingVariancePopulationInput: GuildConfigsHavingVariancePopulationInput;
  GuildConfigsHavingVarianceSampleInput: GuildConfigsHavingVarianceSampleInput;
  HavingBigintFilter: HavingBigintFilter;
  HavingDatetimeFilter: HavingDatetimeFilter;
  HavingIntFilter: HavingIntFilter;
  ID: Scalars['ID'];
  IncrementEmojiStickerStatInput: IncrementEmojiStickerStatInput;
  IncrementEmojiStickerStatPayload: IncrementEmojiStickerStatPayload;
  Int: Scalars['Int'];
  IntFilter: IntFilter;
  JSON: Scalars['JSON'];
  JSONFilter: JsonFilter;
  LevelRole: LevelRole;
  LevelRoleAggregates: LevelRoleAggregates;
  LevelRoleApplyJob: LevelRoleApplyJob;
  LevelRoleApplyJobAggregates: LevelRoleApplyJobAggregates;
  LevelRoleApplyJobAverageAggregates: LevelRoleApplyJobAverageAggregates;
  LevelRoleApplyJobCondition: LevelRoleApplyJobCondition;
  LevelRoleApplyJobDistinctCountAggregates: LevelRoleApplyJobDistinctCountAggregates;
  LevelRoleApplyJobFilter: LevelRoleApplyJobFilter;
  LevelRoleApplyJobInput: LevelRoleApplyJobInput;
  LevelRoleApplyJobMaxAggregates: LevelRoleApplyJobMaxAggregates;
  LevelRoleApplyJobMinAggregates: LevelRoleApplyJobMinAggregates;
  LevelRoleApplyJobPatch: LevelRoleApplyJobPatch;
  LevelRoleApplyJobStddevPopulationAggregates: LevelRoleApplyJobStddevPopulationAggregates;
  LevelRoleApplyJobStddevSampleAggregates: LevelRoleApplyJobStddevSampleAggregates;
  LevelRoleApplyJobSumAggregates: LevelRoleApplyJobSumAggregates;
  LevelRoleApplyJobVariancePopulationAggregates: LevelRoleApplyJobVariancePopulationAggregates;
  LevelRoleApplyJobVarianceSampleAggregates: LevelRoleApplyJobVarianceSampleAggregates;
  LevelRoleApplyJobsConnection: LevelRoleApplyJobsConnection;
  LevelRoleApplyJobsEdge: LevelRoleApplyJobsEdge;
  LevelRoleApplyJobsHavingAverageInput: LevelRoleApplyJobsHavingAverageInput;
  LevelRoleApplyJobsHavingDistinctCountInput: LevelRoleApplyJobsHavingDistinctCountInput;
  LevelRoleApplyJobsHavingInput: LevelRoleApplyJobsHavingInput;
  LevelRoleApplyJobsHavingMaxInput: LevelRoleApplyJobsHavingMaxInput;
  LevelRoleApplyJobsHavingMinInput: LevelRoleApplyJobsHavingMinInput;
  LevelRoleApplyJobsHavingStddevPopulationInput: LevelRoleApplyJobsHavingStddevPopulationInput;
  LevelRoleApplyJobsHavingStddevSampleInput: LevelRoleApplyJobsHavingStddevSampleInput;
  LevelRoleApplyJobsHavingSumInput: LevelRoleApplyJobsHavingSumInput;
  LevelRoleApplyJobsHavingVariancePopulationInput: LevelRoleApplyJobsHavingVariancePopulationInput;
  LevelRoleApplyJobsHavingVarianceSampleInput: LevelRoleApplyJobsHavingVarianceSampleInput;
  LevelRoleAverageAggregates: LevelRoleAverageAggregates;
  LevelRoleCondition: LevelRoleCondition;
  LevelRoleDistinctCountAggregates: LevelRoleDistinctCountAggregates;
  LevelRoleFilter: LevelRoleFilter;
  LevelRoleInput: LevelRoleInput;
  LevelRoleMaxAggregates: LevelRoleMaxAggregates;
  LevelRoleMinAggregates: LevelRoleMinAggregates;
  LevelRoleOverride: LevelRoleOverride;
  LevelRoleOverrideAggregates: LevelRoleOverrideAggregates;
  LevelRoleOverrideAverageAggregates: LevelRoleOverrideAverageAggregates;
  LevelRoleOverrideCondition: LevelRoleOverrideCondition;
  LevelRoleOverrideDistinctCountAggregates: LevelRoleOverrideDistinctCountAggregates;
  LevelRoleOverrideFilter: LevelRoleOverrideFilter;
  LevelRoleOverrideInput: LevelRoleOverrideInput;
  LevelRoleOverrideMaxAggregates: LevelRoleOverrideMaxAggregates;
  LevelRoleOverrideMinAggregates: LevelRoleOverrideMinAggregates;
  LevelRoleOverridePatch: LevelRoleOverridePatch;
  LevelRoleOverrideStddevPopulationAggregates: LevelRoleOverrideStddevPopulationAggregates;
  LevelRoleOverrideStddevSampleAggregates: LevelRoleOverrideStddevSampleAggregates;
  LevelRoleOverrideSumAggregates: LevelRoleOverrideSumAggregates;
  LevelRoleOverrideTypeFilter: LevelRoleOverrideTypeFilter;
  LevelRoleOverrideVariancePopulationAggregates: LevelRoleOverrideVariancePopulationAggregates;
  LevelRoleOverrideVarianceSampleAggregates: LevelRoleOverrideVarianceSampleAggregates;
  LevelRoleOverridesConnection: LevelRoleOverridesConnection;
  LevelRoleOverridesEdge: LevelRoleOverridesEdge;
  LevelRoleOverridesHavingAverageInput: LevelRoleOverridesHavingAverageInput;
  LevelRoleOverridesHavingDistinctCountInput: LevelRoleOverridesHavingDistinctCountInput;
  LevelRoleOverridesHavingInput: LevelRoleOverridesHavingInput;
  LevelRoleOverridesHavingMaxInput: LevelRoleOverridesHavingMaxInput;
  LevelRoleOverridesHavingMinInput: LevelRoleOverridesHavingMinInput;
  LevelRoleOverridesHavingStddevPopulationInput: LevelRoleOverridesHavingStddevPopulationInput;
  LevelRoleOverridesHavingStddevSampleInput: LevelRoleOverridesHavingStddevSampleInput;
  LevelRoleOverridesHavingSumInput: LevelRoleOverridesHavingSumInput;
  LevelRoleOverridesHavingVariancePopulationInput: LevelRoleOverridesHavingVariancePopulationInput;
  LevelRoleOverridesHavingVarianceSampleInput: LevelRoleOverridesHavingVarianceSampleInput;
  LevelRolePatch: LevelRolePatch;
  LevelRoleStddevPopulationAggregates: LevelRoleStddevPopulationAggregates;
  LevelRoleStddevSampleAggregates: LevelRoleStddevSampleAggregates;
  LevelRoleSumAggregates: LevelRoleSumAggregates;
  LevelRoleVariancePopulationAggregates: LevelRoleVariancePopulationAggregates;
  LevelRoleVarianceSampleAggregates: LevelRoleVarianceSampleAggregates;
  LevelRolesConnection: LevelRolesConnection;
  LevelRolesEdge: LevelRolesEdge;
  LevelRolesHavingAverageInput: LevelRolesHavingAverageInput;
  LevelRolesHavingDistinctCountInput: LevelRolesHavingDistinctCountInput;
  LevelRolesHavingInput: LevelRolesHavingInput;
  LevelRolesHavingMaxInput: LevelRolesHavingMaxInput;
  LevelRolesHavingMinInput: LevelRolesHavingMinInput;
  LevelRolesHavingStddevPopulationInput: LevelRolesHavingStddevPopulationInput;
  LevelRolesHavingStddevSampleInput: LevelRolesHavingStddevSampleInput;
  LevelRolesHavingSumInput: LevelRolesHavingSumInput;
  LevelRolesHavingVariancePopulationInput: LevelRolesHavingVariancePopulationInput;
  LevelRolesHavingVarianceSampleInput: LevelRolesHavingVarianceSampleInput;
  LogoutInput: LogoutInput;
  LogoutPayload: LogoutPayload;
  Member: Member;
  MemberAggregates: MemberAggregates;
  MemberAverageAggregates: MemberAverageAggregates;
  MemberCondition: MemberCondition;
  MemberDistinctCountAggregates: MemberDistinctCountAggregates;
  MemberFilter: MemberFilter;
  MemberInput: MemberInput;
  MemberMaxAggregates: MemberMaxAggregates;
  MemberMinAggregates: MemberMinAggregates;
  MemberPatch: MemberPatch;
  MemberStddevPopulationAggregates: MemberStddevPopulationAggregates;
  MemberStddevSampleAggregates: MemberStddevSampleAggregates;
  MemberSumAggregates: MemberSumAggregates;
  MemberVariancePopulationAggregates: MemberVariancePopulationAggregates;
  MemberVarianceSampleAggregates: MemberVarianceSampleAggregates;
  MembersConnection: MembersConnection;
  MembersEdge: MembersEdge;
  MembersHavingAverageInput: MembersHavingAverageInput;
  MembersHavingDistinctCountInput: MembersHavingDistinctCountInput;
  MembersHavingInput: MembersHavingInput;
  MembersHavingMaxInput: MembersHavingMaxInput;
  MembersHavingMinInput: MembersHavingMinInput;
  MembersHavingStddevPopulationInput: MembersHavingStddevPopulationInput;
  MembersHavingStddevSampleInput: MembersHavingStddevSampleInput;
  MembersHavingSumInput: MembersHavingSumInput;
  MembersHavingVariancePopulationInput: MembersHavingVariancePopulationInput;
  MembersHavingVarianceSampleInput: MembersHavingVarianceSampleInput;
  Message: Message;
  MessageAggregates: MessageAggregates;
  MessageAverageAggregates: MessageAverageAggregates;
  MessageCondition: MessageCondition;
  MessageDistinctCountAggregates: MessageDistinctCountAggregates;
  MessageFilter: MessageFilter;
  MessageInput: MessageInput;
  MessageMaxAggregates: MessageMaxAggregates;
  MessageMinAggregates: MessageMinAggregates;
  MessagePatch: MessagePatch;
  MessageStddevPopulationAggregates: MessageStddevPopulationAggregates;
  MessageStddevSampleAggregates: MessageStddevSampleAggregates;
  MessageSumAggregates: MessageSumAggregates;
  MessageVariancePopulationAggregates: MessageVariancePopulationAggregates;
  MessageVarianceSampleAggregates: MessageVarianceSampleAggregates;
  MessagesConnection: MessagesConnection;
  MessagesEdge: MessagesEdge;
  MessagesHavingAverageInput: MessagesHavingAverageInput;
  MessagesHavingDistinctCountInput: MessagesHavingDistinctCountInput;
  MessagesHavingInput: MessagesHavingInput;
  MessagesHavingMaxInput: MessagesHavingMaxInput;
  MessagesHavingMinInput: MessagesHavingMinInput;
  MessagesHavingStddevPopulationInput: MessagesHavingStddevPopulationInput;
  MessagesHavingStddevSampleInput: MessagesHavingStddevSampleInput;
  MessagesHavingSumInput: MessagesHavingSumInput;
  MessagesHavingVariancePopulationInput: MessagesHavingVariancePopulationInput;
  MessagesHavingVarianceSampleInput: MessagesHavingVarianceSampleInput;
  ModLog: ModLog;
  ModLogAggregates: ModLogAggregates;
  ModLogAverageAggregates: ModLogAverageAggregates;
  ModLogCondition: ModLogCondition;
  ModLogDistinctCountAggregates: ModLogDistinctCountAggregates;
  ModLogFilter: ModLogFilter;
  ModLogInput: ModLogInput;
  ModLogMaxAggregates: ModLogMaxAggregates;
  ModLogMinAggregates: ModLogMinAggregates;
  ModLogPatch: ModLogPatch;
  ModLogStddevPopulationAggregates: ModLogStddevPopulationAggregates;
  ModLogStddevSampleAggregates: ModLogStddevSampleAggregates;
  ModLogSumAggregates: ModLogSumAggregates;
  ModLogVariancePopulationAggregates: ModLogVariancePopulationAggregates;
  ModLogVarianceSampleAggregates: ModLogVarianceSampleAggregates;
  ModLogsConnection: ModLogsConnection;
  ModLogsEdge: ModLogsEdge;
  ModLogsHavingAverageInput: ModLogsHavingAverageInput;
  ModLogsHavingDistinctCountInput: ModLogsHavingDistinctCountInput;
  ModLogsHavingInput: ModLogsHavingInput;
  ModLogsHavingMaxInput: ModLogsHavingMaxInput;
  ModLogsHavingMinInput: ModLogsHavingMinInput;
  ModLogsHavingStddevPopulationInput: ModLogsHavingStddevPopulationInput;
  ModLogsHavingStddevSampleInput: ModLogsHavingStddevSampleInput;
  ModLogsHavingSumInput: ModLogsHavingSumInput;
  ModLogsHavingVariancePopulationInput: ModLogsHavingVariancePopulationInput;
  ModLogsHavingVarianceSampleInput: ModLogsHavingVarianceSampleInput;
  MsgLogBlock: MsgLogBlock;
  MsgLogBlockAggregates: MsgLogBlockAggregates;
  MsgLogBlockAverageAggregates: MsgLogBlockAverageAggregates;
  MsgLogBlockCondition: MsgLogBlockCondition;
  MsgLogBlockDistinctCountAggregates: MsgLogBlockDistinctCountAggregates;
  MsgLogBlockFilter: MsgLogBlockFilter;
  MsgLogBlockInput: MsgLogBlockInput;
  MsgLogBlockMaxAggregates: MsgLogBlockMaxAggregates;
  MsgLogBlockMinAggregates: MsgLogBlockMinAggregates;
  MsgLogBlockPatch: MsgLogBlockPatch;
  MsgLogBlockStddevPopulationAggregates: MsgLogBlockStddevPopulationAggregates;
  MsgLogBlockStddevSampleAggregates: MsgLogBlockStddevSampleAggregates;
  MsgLogBlockSumAggregates: MsgLogBlockSumAggregates;
  MsgLogBlockTypeFilter: MsgLogBlockTypeFilter;
  MsgLogBlockVariancePopulationAggregates: MsgLogBlockVariancePopulationAggregates;
  MsgLogBlockVarianceSampleAggregates: MsgLogBlockVarianceSampleAggregates;
  MsgLogBlocksConnection: MsgLogBlocksConnection;
  MsgLogBlocksEdge: MsgLogBlocksEdge;
  MsgLogBlocksHavingAverageInput: MsgLogBlocksHavingAverageInput;
  MsgLogBlocksHavingDistinctCountInput: MsgLogBlocksHavingDistinctCountInput;
  MsgLogBlocksHavingInput: MsgLogBlocksHavingInput;
  MsgLogBlocksHavingMaxInput: MsgLogBlocksHavingMaxInput;
  MsgLogBlocksHavingMinInput: MsgLogBlocksHavingMinInput;
  MsgLogBlocksHavingStddevPopulationInput: MsgLogBlocksHavingStddevPopulationInput;
  MsgLogBlocksHavingStddevSampleInput: MsgLogBlocksHavingStddevSampleInput;
  MsgLogBlocksHavingSumInput: MsgLogBlocksHavingSumInput;
  MsgLogBlocksHavingVariancePopulationInput: MsgLogBlocksHavingVariancePopulationInput;
  MsgLogBlocksHavingVarianceSampleInput: MsgLogBlocksHavingVarianceSampleInput;
  Mutation: {};
  Mute: Mute;
  MuteAggregates: MuteAggregates;
  MuteAverageAggregates: MuteAverageAggregates;
  MuteCondition: MuteCondition;
  MuteDistinctCountAggregates: MuteDistinctCountAggregates;
  MuteFilter: MuteFilter;
  MuteInput: MuteInput;
  MuteMaxAggregates: MuteMaxAggregates;
  MuteMinAggregates: MuteMinAggregates;
  MutePatch: MutePatch;
  MuteStddevPopulationAggregates: MuteStddevPopulationAggregates;
  MuteStddevSampleAggregates: MuteStddevSampleAggregates;
  MuteSumAggregates: MuteSumAggregates;
  MuteVariancePopulationAggregates: MuteVariancePopulationAggregates;
  MuteVarianceSampleAggregates: MuteVarianceSampleAggregates;
  MutesConnection: MutesConnection;
  MutesEdge: MutesEdge;
  MutesHavingAverageInput: MutesHavingAverageInput;
  MutesHavingDistinctCountInput: MutesHavingDistinctCountInput;
  MutesHavingInput: MutesHavingInput;
  MutesHavingMaxInput: MutesHavingMaxInput;
  MutesHavingMinInput: MutesHavingMinInput;
  MutesHavingStddevPopulationInput: MutesHavingStddevPopulationInput;
  MutesHavingStddevSampleInput: MutesHavingStddevSampleInput;
  MutesHavingSumInput: MutesHavingSumInput;
  MutesHavingVariancePopulationInput: MutesHavingVariancePopulationInput;
  MutesHavingVarianceSampleInput: MutesHavingVarianceSampleInput;
  Node: ResolversParentTypes['BotStat'] | ResolversParentTypes['CachedGuild'] | ResolversParentTypes['CachedUser'] | ResolversParentTypes['EmojiStickerStat'] | ResolversParentTypes['Feed'] | ResolversParentTypes['FeedItem'] | ResolversParentTypes['FeedSubscription'] | ResolversParentTypes['GuildBan'] | ResolversParentTypes['GuildConfig'] | ResolversParentTypes['LevelRole'] | ResolversParentTypes['LevelRoleApplyJob'] | ResolversParentTypes['LevelRoleOverride'] | ResolversParentTypes['Member'] | ResolversParentTypes['Message'] | ResolversParentTypes['ModLog'] | ResolversParentTypes['MsgLogBlock'] | ResolversParentTypes['Mute'] | ResolversParentTypes['Notification'] | ResolversParentTypes['Query'] | ResolversParentTypes['Reminder'] | ResolversParentTypes['RoleMenu'] | ResolversParentTypes['RoleMenuRole'] | ResolversParentTypes['Tag'] | ResolversParentTypes['User'] | ResolversParentTypes['UserLevel'] | ResolversParentTypes['WebUser'] | ResolversParentTypes['WebUserGuild'] | ResolversParentTypes['XpBlock'];
  Notification: Notification;
  NotificationAggregates: NotificationAggregates;
  NotificationAverageAggregates: NotificationAverageAggregates;
  NotificationCondition: NotificationCondition;
  NotificationDistinctCountAggregates: NotificationDistinctCountAggregates;
  NotificationFilter: NotificationFilter;
  NotificationInput: NotificationInput;
  NotificationMaxAggregates: NotificationMaxAggregates;
  NotificationMinAggregates: NotificationMinAggregates;
  NotificationPatch: NotificationPatch;
  NotificationStddevPopulationAggregates: NotificationStddevPopulationAggregates;
  NotificationStddevSampleAggregates: NotificationStddevSampleAggregates;
  NotificationSumAggregates: NotificationSumAggregates;
  NotificationVariancePopulationAggregates: NotificationVariancePopulationAggregates;
  NotificationVarianceSampleAggregates: NotificationVarianceSampleAggregates;
  NotificationsConnection: NotificationsConnection;
  NotificationsEdge: NotificationsEdge;
  NotificationsHavingAverageInput: NotificationsHavingAverageInput;
  NotificationsHavingDistinctCountInput: NotificationsHavingDistinctCountInput;
  NotificationsHavingInput: NotificationsHavingInput;
  NotificationsHavingMaxInput: NotificationsHavingMaxInput;
  NotificationsHavingMinInput: NotificationsHavingMinInput;
  NotificationsHavingStddevPopulationInput: NotificationsHavingStddevPopulationInput;
  NotificationsHavingStddevSampleInput: NotificationsHavingStddevSampleInput;
  NotificationsHavingSumInput: NotificationsHavingSumInput;
  NotificationsHavingVariancePopulationInput: NotificationsHavingVariancePopulationInput;
  NotificationsHavingVarianceSampleInput: NotificationsHavingVarianceSampleInput;
  NotificationsStartingWithConnection: NotificationsStartingWithConnection;
  NotificationsStartingWithEdge: NotificationsStartingWithEdge;
  PageInfo: PageInfo;
  Query: {};
  RedisGuild: RedisGuild;
  RedisGuildRole: RedisGuildRole;
  RedisRoleTags: RedisRoleTags;
  Reminder: Reminder;
  ReminderAggregates: ReminderAggregates;
  ReminderAverageAggregates: ReminderAverageAggregates;
  ReminderCondition: ReminderCondition;
  ReminderDistinctCountAggregates: ReminderDistinctCountAggregates;
  ReminderFilter: ReminderFilter;
  ReminderInput: ReminderInput;
  ReminderMaxAggregates: ReminderMaxAggregates;
  ReminderMinAggregates: ReminderMinAggregates;
  ReminderPatch: ReminderPatch;
  ReminderStddevPopulationAggregates: ReminderStddevPopulationAggregates;
  ReminderStddevSampleAggregates: ReminderStddevSampleAggregates;
  ReminderSumAggregates: ReminderSumAggregates;
  ReminderVariancePopulationAggregates: ReminderVariancePopulationAggregates;
  ReminderVarianceSampleAggregates: ReminderVarianceSampleAggregates;
  RemindersConnection: RemindersConnection;
  RemindersEdge: RemindersEdge;
  RemindersHavingAverageInput: RemindersHavingAverageInput;
  RemindersHavingDistinctCountInput: RemindersHavingDistinctCountInput;
  RemindersHavingInput: RemindersHavingInput;
  RemindersHavingMaxInput: RemindersHavingMaxInput;
  RemindersHavingMinInput: RemindersHavingMinInput;
  RemindersHavingStddevPopulationInput: RemindersHavingStddevPopulationInput;
  RemindersHavingStddevSampleInput: RemindersHavingStddevSampleInput;
  RemindersHavingSumInput: RemindersHavingSumInput;
  RemindersHavingVariancePopulationInput: RemindersHavingVariancePopulationInput;
  RemindersHavingVarianceSampleInput: RemindersHavingVarianceSampleInput;
  RoleMenu: RoleMenu;
  RoleMenuAggregates: RoleMenuAggregates;
  RoleMenuAverageAggregates: RoleMenuAverageAggregates;
  RoleMenuCondition: RoleMenuCondition;
  RoleMenuDistinctCountAggregates: RoleMenuDistinctCountAggregates;
  RoleMenuFilter: RoleMenuFilter;
  RoleMenuInput: RoleMenuInput;
  RoleMenuMaxAggregates: RoleMenuMaxAggregates;
  RoleMenuMinAggregates: RoleMenuMinAggregates;
  RoleMenuPatch: RoleMenuPatch;
  RoleMenuRole: RoleMenuRole;
  RoleMenuRoleAggregates: RoleMenuRoleAggregates;
  RoleMenuRoleAverageAggregates: RoleMenuRoleAverageAggregates;
  RoleMenuRoleCondition: RoleMenuRoleCondition;
  RoleMenuRoleDistinctCountAggregates: RoleMenuRoleDistinctCountAggregates;
  RoleMenuRoleFilter: RoleMenuRoleFilter;
  RoleMenuRoleInput: RoleMenuRoleInput;
  RoleMenuRoleMaxAggregates: RoleMenuRoleMaxAggregates;
  RoleMenuRoleMinAggregates: RoleMenuRoleMinAggregates;
  RoleMenuRolePatch: RoleMenuRolePatch;
  RoleMenuRoleStddevPopulationAggregates: RoleMenuRoleStddevPopulationAggregates;
  RoleMenuRoleStddevSampleAggregates: RoleMenuRoleStddevSampleAggregates;
  RoleMenuRoleSumAggregates: RoleMenuRoleSumAggregates;
  RoleMenuRoleVariancePopulationAggregates: RoleMenuRoleVariancePopulationAggregates;
  RoleMenuRoleVarianceSampleAggregates: RoleMenuRoleVarianceSampleAggregates;
  RoleMenuRolesConnection: RoleMenuRolesConnection;
  RoleMenuRolesEdge: RoleMenuRolesEdge;
  RoleMenuRolesHavingAverageInput: RoleMenuRolesHavingAverageInput;
  RoleMenuRolesHavingDistinctCountInput: RoleMenuRolesHavingDistinctCountInput;
  RoleMenuRolesHavingInput: RoleMenuRolesHavingInput;
  RoleMenuRolesHavingMaxInput: RoleMenuRolesHavingMaxInput;
  RoleMenuRolesHavingMinInput: RoleMenuRolesHavingMinInput;
  RoleMenuRolesHavingStddevPopulationInput: RoleMenuRolesHavingStddevPopulationInput;
  RoleMenuRolesHavingStddevSampleInput: RoleMenuRolesHavingStddevSampleInput;
  RoleMenuRolesHavingSumInput: RoleMenuRolesHavingSumInput;
  RoleMenuRolesHavingVariancePopulationInput: RoleMenuRolesHavingVariancePopulationInput;
  RoleMenuRolesHavingVarianceSampleInput: RoleMenuRolesHavingVarianceSampleInput;
  RoleMenuStddevPopulationAggregates: RoleMenuStddevPopulationAggregates;
  RoleMenuStddevSampleAggregates: RoleMenuStddevSampleAggregates;
  RoleMenuSumAggregates: RoleMenuSumAggregates;
  RoleMenuVariancePopulationAggregates: RoleMenuVariancePopulationAggregates;
  RoleMenuVarianceSampleAggregates: RoleMenuVarianceSampleAggregates;
  RoleMenusConnection: RoleMenusConnection;
  RoleMenusEdge: RoleMenusEdge;
  RoleMenusHavingAverageInput: RoleMenusHavingAverageInput;
  RoleMenusHavingDistinctCountInput: RoleMenusHavingDistinctCountInput;
  RoleMenusHavingInput: RoleMenusHavingInput;
  RoleMenusHavingMaxInput: RoleMenusHavingMaxInput;
  RoleMenusHavingMinInput: RoleMenusHavingMinInput;
  RoleMenusHavingStddevPopulationInput: RoleMenusHavingStddevPopulationInput;
  RoleMenusHavingStddevSampleInput: RoleMenusHavingStddevSampleInput;
  RoleMenusHavingSumInput: RoleMenusHavingSumInput;
  RoleMenusHavingVariancePopulationInput: RoleMenusHavingVariancePopulationInput;
  RoleMenusHavingVarianceSampleInput: RoleMenusHavingVarianceSampleInput;
  SetRoleMenuRoleOrderInput: SetRoleMenuRoleOrderInput;
  SetRoleMenuRoleOrderPayload: SetRoleMenuRoleOrderPayload;
  String: Scalars['String'];
  StringFilter: StringFilter;
  StringListFilter: StringListFilter;
  Tag: Tag;
  TagAggregates: TagAggregates;
  TagAverageAggregates: TagAverageAggregates;
  TagCondition: TagCondition;
  TagDistinctCountAggregates: TagDistinctCountAggregates;
  TagFilter: TagFilter;
  TagInput: TagInput;
  TagMaxAggregates: TagMaxAggregates;
  TagMinAggregates: TagMinAggregates;
  TagPatch: TagPatch;
  TagStddevPopulationAggregates: TagStddevPopulationAggregates;
  TagStddevSampleAggregates: TagStddevSampleAggregates;
  TagSumAggregates: TagSumAggregates;
  TagVariancePopulationAggregates: TagVariancePopulationAggregates;
  TagVarianceSampleAggregates: TagVarianceSampleAggregates;
  TagsConnection: TagsConnection;
  TagsEdge: TagsEdge;
  TagsHavingAverageInput: TagsHavingAverageInput;
  TagsHavingDistinctCountInput: TagsHavingDistinctCountInput;
  TagsHavingInput: TagsHavingInput;
  TagsHavingMaxInput: TagsHavingMaxInput;
  TagsHavingMinInput: TagsHavingMinInput;
  TagsHavingStddevPopulationInput: TagsHavingStddevPopulationInput;
  TagsHavingStddevSampleInput: TagsHavingStddevSampleInput;
  TagsHavingSumInput: TagsHavingSumInput;
  TagsHavingVariancePopulationInput: TagsHavingVariancePopulationInput;
  TagsHavingVarianceSampleInput: TagsHavingVarianceSampleInput;
  TimeframeUserLevelEdge: TimeframeUserLevelEdge;
  TimeframeUserLevelsConnection: TimeframeUserLevelsConnection;
  TimeframeUserLevelsRecord: TimeframeUserLevelsRecord;
  TimeframeUserLevelsRecordFilter: TimeframeUserLevelsRecordFilter;
  UUID: Scalars['UUID'];
  UpdateBotStatByNameAndCategoryInput: UpdateBotStatByNameAndCategoryInput;
  UpdateBotStatInput: UpdateBotStatInput;
  UpdateBotStatPayload: UpdateBotStatPayload;
  UpdateCachedGuildByIdInput: UpdateCachedGuildByIdInput;
  UpdateCachedGuildInput: UpdateCachedGuildInput;
  UpdateCachedGuildPayload: UpdateCachedGuildPayload;
  UpdateCachedUserByIdInput: UpdateCachedUserByIdInput;
  UpdateCachedUserInput: UpdateCachedUserInput;
  UpdateCachedUserPayload: UpdateCachedUserPayload;
  UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput: UpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeInput;
  UpdateEmojiStickerStatInput: UpdateEmojiStickerStatInput;
  UpdateEmojiStickerStatPayload: UpdateEmojiStickerStatPayload;
  UpdateFeedByFeedIdInput: UpdateFeedByFeedIdInput;
  UpdateFeedInput: UpdateFeedInput;
  UpdateFeedItemByFeedIdAndItemIdInput: UpdateFeedItemByFeedIdAndItemIdInput;
  UpdateFeedItemInput: UpdateFeedItemInput;
  UpdateFeedItemPayload: UpdateFeedItemPayload;
  UpdateFeedPayload: UpdateFeedPayload;
  UpdateFeedSubscriptionByFeedIdAndChannelIdInput: UpdateFeedSubscriptionByFeedIdAndChannelIdInput;
  UpdateFeedSubscriptionInput: UpdateFeedSubscriptionInput;
  UpdateFeedSubscriptionPayload: UpdateFeedSubscriptionPayload;
  UpdateGuildBanByGuildIdAndUserIdInput: UpdateGuildBanByGuildIdAndUserIdInput;
  UpdateGuildBanInput: UpdateGuildBanInput;
  UpdateGuildBanPayload: UpdateGuildBanPayload;
  UpdateGuildConfigByIdInput: UpdateGuildConfigByIdInput;
  UpdateGuildConfigInput: UpdateGuildConfigInput;
  UpdateGuildConfigPayload: UpdateGuildConfigPayload;
  UpdateLevelRoleApplyJobByGuildIdInput: UpdateLevelRoleApplyJobByGuildIdInput;
  UpdateLevelRoleApplyJobByInteractionIdInput: UpdateLevelRoleApplyJobByInteractionIdInput;
  UpdateLevelRoleApplyJobInput: UpdateLevelRoleApplyJobInput;
  UpdateLevelRoleApplyJobPayload: UpdateLevelRoleApplyJobPayload;
  UpdateLevelRoleByGuildIdAndRoleIdInput: UpdateLevelRoleByGuildIdAndRoleIdInput;
  UpdateLevelRoleInput: UpdateLevelRoleInput;
  UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput: UpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdInput;
  UpdateLevelRoleOverrideInput: UpdateLevelRoleOverrideInput;
  UpdateLevelRoleOverridePayload: UpdateLevelRoleOverridePayload;
  UpdateLevelRolePayload: UpdateLevelRolePayload;
  UpdateMemberByGuildIdAndUserIdInput: UpdateMemberByGuildIdAndUserIdInput;
  UpdateMemberInput: UpdateMemberInput;
  UpdateMemberPayload: UpdateMemberPayload;
  UpdateMessageByMessageIdInput: UpdateMessageByMessageIdInput;
  UpdateMessageInput: UpdateMessageInput;
  UpdateMessagePayload: UpdateMessagePayload;
  UpdateModLogByGuildIdAndCaseIdInput: UpdateModLogByGuildIdAndCaseIdInput;
  UpdateModLogInput: UpdateModLogInput;
  UpdateModLogPayload: UpdateModLogPayload;
  UpdateMsgLogBlockByGuildIdAndChannelIdInput: UpdateMsgLogBlockByGuildIdAndChannelIdInput;
  UpdateMsgLogBlockInput: UpdateMsgLogBlockInput;
  UpdateMsgLogBlockPayload: UpdateMsgLogBlockPayload;
  UpdateMuteByGuildIdAndUserIdInput: UpdateMuteByGuildIdAndUserIdInput;
  UpdateMuteInput: UpdateMuteInput;
  UpdateMutePayload: UpdateMutePayload;
  UpdateNotificationByUserIdAndGuildIdAndKeywordInput: UpdateNotificationByUserIdAndGuildIdAndKeywordInput;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateNotificationPayload: UpdateNotificationPayload;
  UpdateReminderByUserIdAndSetAtInput: UpdateReminderByUserIdAndSetAtInput;
  UpdateReminderInput: UpdateReminderInput;
  UpdateReminderPayload: UpdateReminderPayload;
  UpdateRoleMenuByGuildIdAndMenuNameInput: UpdateRoleMenuByGuildIdAndMenuNameInput;
  UpdateRoleMenuInput: UpdateRoleMenuInput;
  UpdateRoleMenuPayload: UpdateRoleMenuPayload;
  UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput: UpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdInput;
  UpdateRoleMenuRoleInput: UpdateRoleMenuRoleInput;
  UpdateRoleMenuRolePayload: UpdateRoleMenuRolePayload;
  UpdateTagByGuildIdAndTagNameInput: UpdateTagByGuildIdAndTagNameInput;
  UpdateTagInput: UpdateTagInput;
  UpdateTagPayload: UpdateTagPayload;
  UpdateUserByIdInput: UpdateUserByIdInput;
  UpdateUserInput: UpdateUserInput;
  UpdateUserLevelByUserIdAndGuildIdInput: UpdateUserLevelByUserIdAndGuildIdInput;
  UpdateUserLevelInput: UpdateUserLevelInput;
  UpdateUserLevelPayload: UpdateUserLevelPayload;
  UpdateUserPayload: UpdateUserPayload;
  UpdateUserXpInput: UpdateUserXpInput;
  UpdateUserXpPayload: UpdateUserXpPayload;
  UpdateWebUserByIdInput: UpdateWebUserByIdInput;
  UpdateWebUserGuildByUserIdAndGuildIdInput: UpdateWebUserGuildByUserIdAndGuildIdInput;
  UpdateWebUserGuildInput: UpdateWebUserGuildInput;
  UpdateWebUserGuildPayload: UpdateWebUserGuildPayload;
  UpdateWebUserInput: UpdateWebUserInput;
  UpdateWebUserPayload: UpdateWebUserPayload;
  UpdateXpBlockByGuildIdAndBlockIdInput: UpdateXpBlockByGuildIdAndBlockIdInput;
  UpdateXpBlockInput: UpdateXpBlockInput;
  UpdateXpBlockPayload: UpdateXpBlockPayload;
  UpsertBotStatInput: UpsertBotStatInput;
  UpsertBotStatPayload: UpsertBotStatPayload;
  UpsertBotStatWhere: UpsertBotStatWhere;
  UpsertCachedGuildInput: UpsertCachedGuildInput;
  UpsertCachedGuildPayload: UpsertCachedGuildPayload;
  UpsertCachedGuildWhere: UpsertCachedGuildWhere;
  UpsertCachedUserInput: UpsertCachedUserInput;
  UpsertCachedUserPayload: UpsertCachedUserPayload;
  UpsertCachedUserWhere: UpsertCachedUserWhere;
  UpsertEmojiStickerStatInput: UpsertEmojiStickerStatInput;
  UpsertEmojiStickerStatPayload: UpsertEmojiStickerStatPayload;
  UpsertEmojiStickerStatWhere: UpsertEmojiStickerStatWhere;
  UpsertFeedInput: UpsertFeedInput;
  UpsertFeedItemInput: UpsertFeedItemInput;
  UpsertFeedItemPayload: UpsertFeedItemPayload;
  UpsertFeedItemWhere: UpsertFeedItemWhere;
  UpsertFeedPayload: UpsertFeedPayload;
  UpsertFeedSubscriptionInput: UpsertFeedSubscriptionInput;
  UpsertFeedSubscriptionPayload: UpsertFeedSubscriptionPayload;
  UpsertFeedSubscriptionWhere: UpsertFeedSubscriptionWhere;
  UpsertFeedWhere: UpsertFeedWhere;
  UpsertGuildBanInput: UpsertGuildBanInput;
  UpsertGuildBanPayload: UpsertGuildBanPayload;
  UpsertGuildBanWhere: UpsertGuildBanWhere;
  UpsertGuildConfigInput: UpsertGuildConfigInput;
  UpsertGuildConfigPayload: UpsertGuildConfigPayload;
  UpsertGuildConfigWhere: UpsertGuildConfigWhere;
  UpsertLevelRoleApplyJobInput: UpsertLevelRoleApplyJobInput;
  UpsertLevelRoleApplyJobPayload: UpsertLevelRoleApplyJobPayload;
  UpsertLevelRoleApplyJobWhere: UpsertLevelRoleApplyJobWhere;
  UpsertLevelRoleInput: UpsertLevelRoleInput;
  UpsertLevelRoleOverrideInput: UpsertLevelRoleOverrideInput;
  UpsertLevelRoleOverridePayload: UpsertLevelRoleOverridePayload;
  UpsertLevelRoleOverrideWhere: UpsertLevelRoleOverrideWhere;
  UpsertLevelRolePayload: UpsertLevelRolePayload;
  UpsertLevelRoleWhere: UpsertLevelRoleWhere;
  UpsertMemberInput: UpsertMemberInput;
  UpsertMemberPayload: UpsertMemberPayload;
  UpsertMemberWhere: UpsertMemberWhere;
  UpsertMessageInput: UpsertMessageInput;
  UpsertMessagePayload: UpsertMessagePayload;
  UpsertMessageWhere: UpsertMessageWhere;
  UpsertModLogInput: UpsertModLogInput;
  UpsertModLogPayload: UpsertModLogPayload;
  UpsertModLogWhere: UpsertModLogWhere;
  UpsertMsgLogBlockInput: UpsertMsgLogBlockInput;
  UpsertMsgLogBlockPayload: UpsertMsgLogBlockPayload;
  UpsertMsgLogBlockWhere: UpsertMsgLogBlockWhere;
  UpsertMuteInput: UpsertMuteInput;
  UpsertMutePayload: UpsertMutePayload;
  UpsertMuteWhere: UpsertMuteWhere;
  UpsertNotificationInput: UpsertNotificationInput;
  UpsertNotificationPayload: UpsertNotificationPayload;
  UpsertNotificationWhere: UpsertNotificationWhere;
  UpsertReminderInput: UpsertReminderInput;
  UpsertReminderPayload: UpsertReminderPayload;
  UpsertReminderWhere: UpsertReminderWhere;
  UpsertRoleMenuInput: UpsertRoleMenuInput;
  UpsertRoleMenuPayload: UpsertRoleMenuPayload;
  UpsertRoleMenuRoleInput: UpsertRoleMenuRoleInput;
  UpsertRoleMenuRolePayload: UpsertRoleMenuRolePayload;
  UpsertRoleMenuRoleWhere: UpsertRoleMenuRoleWhere;
  UpsertRoleMenuWhere: UpsertRoleMenuWhere;
  UpsertTagInput: UpsertTagInput;
  UpsertTagPayload: UpsertTagPayload;
  UpsertTagWhere: UpsertTagWhere;
  UpsertUserInput: UpsertUserInput;
  UpsertUserLevelInput: UpsertUserLevelInput;
  UpsertUserLevelPayload: UpsertUserLevelPayload;
  UpsertUserLevelWhere: UpsertUserLevelWhere;
  UpsertUserPayload: UpsertUserPayload;
  UpsertUserWhere: UpsertUserWhere;
  UpsertWebUserGuildInput: UpsertWebUserGuildInput;
  UpsertWebUserGuildPayload: UpsertWebUserGuildPayload;
  UpsertWebUserGuildWhere: UpsertWebUserGuildWhere;
  UpsertWebUserInput: UpsertWebUserInput;
  UpsertWebUserPayload: UpsertWebUserPayload;
  UpsertWebUserWhere: UpsertWebUserWhere;
  UpsertXpBlockInput: UpsertXpBlockInput;
  UpsertXpBlockPayload: UpsertXpBlockPayload;
  UpsertXpBlockWhere: UpsertXpBlockWhere;
  User: User;
  UserAggregates: UserAggregates;
  UserAverageAggregates: UserAverageAggregates;
  UserCondition: UserCondition;
  UserDistinctCountAggregates: UserDistinctCountAggregates;
  UserFilter: UserFilter;
  UserGuildRankResult: UserGuildRankResult;
  UserInput: UserInput;
  UserLevel: UserLevel;
  UserLevelAggregates: UserLevelAggregates;
  UserLevelAverageAggregates: UserLevelAverageAggregates;
  UserLevelCondition: UserLevelCondition;
  UserLevelDistinctCountAggregates: UserLevelDistinctCountAggregates;
  UserLevelFilter: UserLevelFilter;
  UserLevelInput: UserLevelInput;
  UserLevelMaxAggregates: UserLevelMaxAggregates;
  UserLevelMinAggregates: UserLevelMinAggregates;
  UserLevelPatch: UserLevelPatch;
  UserLevelStddevPopulationAggregates: UserLevelStddevPopulationAggregates;
  UserLevelStddevSampleAggregates: UserLevelStddevSampleAggregates;
  UserLevelSumAggregates: UserLevelSumAggregates;
  UserLevelVariancePopulationAggregates: UserLevelVariancePopulationAggregates;
  UserLevelVarianceSampleAggregates: UserLevelVarianceSampleAggregates;
  UserLevelsConnection: UserLevelsConnection;
  UserLevelsEdge: UserLevelsEdge;
  UserLevelsHavingAverageInput: UserLevelsHavingAverageInput;
  UserLevelsHavingDistinctCountInput: UserLevelsHavingDistinctCountInput;
  UserLevelsHavingInput: UserLevelsHavingInput;
  UserLevelsHavingMaxInput: UserLevelsHavingMaxInput;
  UserLevelsHavingMinInput: UserLevelsHavingMinInput;
  UserLevelsHavingStddevPopulationInput: UserLevelsHavingStddevPopulationInput;
  UserLevelsHavingStddevSampleInput: UserLevelsHavingStddevSampleInput;
  UserLevelsHavingSumInput: UserLevelsHavingSumInput;
  UserLevelsHavingVariancePopulationInput: UserLevelsHavingVariancePopulationInput;
  UserLevelsHavingVarianceSampleInput: UserLevelsHavingVarianceSampleInput;
  UserMaxAggregates: UserMaxAggregates;
  UserMinAggregates: UserMinAggregates;
  UserPatch: UserPatch;
  UserStddevPopulationAggregates: UserStddevPopulationAggregates;
  UserStddevSampleAggregates: UserStddevSampleAggregates;
  UserSumAggregates: UserSumAggregates;
  UserVariancePopulationAggregates: UserVariancePopulationAggregates;
  UserVarianceSampleAggregates: UserVarianceSampleAggregates;
  UserXpUpdateResult: UserXpUpdateResult;
  UsersConnection: UsersConnection;
  UsersEdge: UsersEdge;
  UsersHavingAverageInput: UsersHavingAverageInput;
  UsersHavingDistinctCountInput: UsersHavingDistinctCountInput;
  UsersHavingInput: UsersHavingInput;
  UsersHavingMaxInput: UsersHavingMaxInput;
  UsersHavingMinInput: UsersHavingMinInput;
  UsersHavingStddevPopulationInput: UsersHavingStddevPopulationInput;
  UsersHavingStddevSampleInput: UsersHavingStddevSampleInput;
  UsersHavingSumInput: UsersHavingSumInput;
  UsersHavingVariancePopulationInput: UsersHavingVariancePopulationInput;
  UsersHavingVarianceSampleInput: UsersHavingVarianceSampleInput;
  WebUser: WebUser;
  WebUserAggregates: WebUserAggregates;
  WebUserAverageAggregates: WebUserAverageAggregates;
  WebUserCondition: WebUserCondition;
  WebUserDistinctCountAggregates: WebUserDistinctCountAggregates;
  WebUserFilter: WebUserFilter;
  WebUserGuild: WebUserGuild;
  WebUserGuildAggregates: WebUserGuildAggregates;
  WebUserGuildAverageAggregates: WebUserGuildAverageAggregates;
  WebUserGuildCondition: WebUserGuildCondition;
  WebUserGuildDistinctCountAggregates: WebUserGuildDistinctCountAggregates;
  WebUserGuildFilter: WebUserGuildFilter;
  WebUserGuildInput: WebUserGuildInput;
  WebUserGuildMaxAggregates: WebUserGuildMaxAggregates;
  WebUserGuildMinAggregates: WebUserGuildMinAggregates;
  WebUserGuildPatch: WebUserGuildPatch;
  WebUserGuildStddevPopulationAggregates: WebUserGuildStddevPopulationAggregates;
  WebUserGuildStddevSampleAggregates: WebUserGuildStddevSampleAggregates;
  WebUserGuildSumAggregates: WebUserGuildSumAggregates;
  WebUserGuildVariancePopulationAggregates: WebUserGuildVariancePopulationAggregates;
  WebUserGuildVarianceSampleAggregates: WebUserGuildVarianceSampleAggregates;
  WebUserGuildsConnection: WebUserGuildsConnection;
  WebUserGuildsEdge: WebUserGuildsEdge;
  WebUserGuildsHavingAverageInput: WebUserGuildsHavingAverageInput;
  WebUserGuildsHavingDistinctCountInput: WebUserGuildsHavingDistinctCountInput;
  WebUserGuildsHavingInput: WebUserGuildsHavingInput;
  WebUserGuildsHavingMaxInput: WebUserGuildsHavingMaxInput;
  WebUserGuildsHavingMinInput: WebUserGuildsHavingMinInput;
  WebUserGuildsHavingStddevPopulationInput: WebUserGuildsHavingStddevPopulationInput;
  WebUserGuildsHavingStddevSampleInput: WebUserGuildsHavingStddevSampleInput;
  WebUserGuildsHavingSumInput: WebUserGuildsHavingSumInput;
  WebUserGuildsHavingVariancePopulationInput: WebUserGuildsHavingVariancePopulationInput;
  WebUserGuildsHavingVarianceSampleInput: WebUserGuildsHavingVarianceSampleInput;
  WebUserInput: WebUserInput;
  WebUserMaxAggregates: WebUserMaxAggregates;
  WebUserMinAggregates: WebUserMinAggregates;
  WebUserPatch: WebUserPatch;
  WebUserStddevPopulationAggregates: WebUserStddevPopulationAggregates;
  WebUserStddevSampleAggregates: WebUserStddevSampleAggregates;
  WebUserSumAggregates: WebUserSumAggregates;
  WebUserVariancePopulationAggregates: WebUserVariancePopulationAggregates;
  WebUserVarianceSampleAggregates: WebUserVarianceSampleAggregates;
  WebUsersConnection: WebUsersConnection;
  WebUsersEdge: WebUsersEdge;
  WebUsersHavingAverageInput: WebUsersHavingAverageInput;
  WebUsersHavingDistinctCountInput: WebUsersHavingDistinctCountInput;
  WebUsersHavingInput: WebUsersHavingInput;
  WebUsersHavingMaxInput: WebUsersHavingMaxInput;
  WebUsersHavingMinInput: WebUsersHavingMinInput;
  WebUsersHavingStddevPopulationInput: WebUsersHavingStddevPopulationInput;
  WebUsersHavingStddevSampleInput: WebUsersHavingStddevSampleInput;
  WebUsersHavingSumInput: WebUsersHavingSumInput;
  WebUsersHavingVariancePopulationInput: WebUsersHavingVariancePopulationInput;
  WebUsersHavingVarianceSampleInput: WebUsersHavingVarianceSampleInput;
  XpBlock: XpBlock;
  XpBlockAggregates: XpBlockAggregates;
  XpBlockAverageAggregates: XpBlockAverageAggregates;
  XpBlockCondition: XpBlockCondition;
  XpBlockDistinctCountAggregates: XpBlockDistinctCountAggregates;
  XpBlockFilter: XpBlockFilter;
  XpBlockInput: XpBlockInput;
  XpBlockMaxAggregates: XpBlockMaxAggregates;
  XpBlockMinAggregates: XpBlockMinAggregates;
  XpBlockPatch: XpBlockPatch;
  XpBlockStddevPopulationAggregates: XpBlockStddevPopulationAggregates;
  XpBlockStddevSampleAggregates: XpBlockStddevSampleAggregates;
  XpBlockSumAggregates: XpBlockSumAggregates;
  XpBlockVariancePopulationAggregates: XpBlockVariancePopulationAggregates;
  XpBlockVarianceSampleAggregates: XpBlockVarianceSampleAggregates;
  XpBlocksConnection: XpBlocksConnection;
  XpBlocksEdge: XpBlocksEdge;
  XpBlocksHavingAverageInput: XpBlocksHavingAverageInput;
  XpBlocksHavingDistinctCountInput: XpBlocksHavingDistinctCountInput;
  XpBlocksHavingInput: XpBlocksHavingInput;
  XpBlocksHavingMaxInput: XpBlocksHavingMaxInput;
  XpBlocksHavingMinInput: XpBlocksHavingMinInput;
  XpBlocksHavingStddevPopulationInput: XpBlocksHavingStddevPopulationInput;
  XpBlocksHavingStddevSampleInput: XpBlocksHavingStddevSampleInput;
  XpBlocksHavingSumInput: XpBlocksHavingSumInput;
  XpBlocksHavingVariancePopulationInput: XpBlocksHavingVariancePopulationInput;
  XpBlocksHavingVarianceSampleInput: XpBlocksHavingVarianceSampleInput;
};

export type AddRoleMenuRolesPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddRoleMenuRolesPayload'] = ResolversParentTypes['AddRoleMenuRolesPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuRoles?: Resolver<Maybe<Array<ResolversTypes['RoleMenuRole']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigFloatScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigFloat'], any> {
  name: 'BigFloat';
}

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BotStatResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStat'] = ResolversParentTypes['BotStat']> = {
  category?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatAggregates'] = ResolversParentTypes['BotStatAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['BotStatAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['BotStatDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['BotStatMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['BotStatMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['BotStatStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['BotStatStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['BotStatSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['BotStatVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['BotStatVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatAverageAggregates'] = ResolversParentTypes['BotStatAverageAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatDistinctCountAggregates'] = ResolversParentTypes['BotStatDistinctCountAggregates']> = {
  category?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatMaxAggregates'] = ResolversParentTypes['BotStatMaxAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatMinAggregates'] = ResolversParentTypes['BotStatMinAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatStddevPopulationAggregates'] = ResolversParentTypes['BotStatStddevPopulationAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatStddevSampleAggregates'] = ResolversParentTypes['BotStatStddevSampleAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatSumAggregates'] = ResolversParentTypes['BotStatSumAggregates']> = {
  count?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatVariancePopulationAggregates'] = ResolversParentTypes['BotStatVariancePopulationAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatVarianceSampleAggregates'] = ResolversParentTypes['BotStatVarianceSampleAggregates']> = {
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatsConnection'] = ResolversParentTypes['BotStatsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['BotStatAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['BotStatsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['BotStatAggregates']>>, ParentType, ContextType, RequireFields<BotStatsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['BotStat']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BotStatsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BotStatsEdge'] = ResolversParentTypes['BotStatsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['BotStat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkDeleteModLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkDeleteModLogPayload'] = ResolversParentTypes['BulkDeleteModLogPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLogs?: Resolver<Maybe<Array<ResolversTypes['ModLog']>>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkUpdateModLogReasonPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkUpdateModLogReasonPayload'] = ResolversParentTypes['BulkUpdateModLogReasonPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLogs?: Resolver<Maybe<Array<ResolversTypes['ModLog']>>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CachedGuildResolvers<ContextType = any, ParentType extends ResolversParentTypes['CachedGuild'] = ResolversParentTypes['CachedGuild']> = {
  banner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  features?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  guildConfigById?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  splash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  webUserGuildsByGuildId?: Resolver<ResolversTypes['WebUserGuildsConnection'], ParentType, ContextType, RequireFields<CachedGuildWebUserGuildsByGuildIdArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CachedGuildsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CachedGuildsEdge'] = ResolversParentTypes['CachedGuildsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CachedGuild'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CachedUserResolvers<ContextType = any, ParentType extends ResolversParentTypes['CachedUser'] = ResolversParentTypes['CachedUser']> = {
  avatarUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  discriminator?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  lastChecked?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CachedUsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CachedUsersEdge'] = ResolversParentTypes['CachedUsersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CachedUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateBotStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateBotStatPayload'] = ResolversParentTypes['CreateBotStatPayload']> = {
  botStat?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType>;
  botStatEdge?: Resolver<Maybe<ResolversTypes['BotStatsEdge']>, ParentType, ContextType, RequireFields<CreateBotStatPayloadBotStatEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCachedGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCachedGuildPayload'] = ResolversParentTypes['CreateCachedGuildPayload']> = {
  cachedGuild?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  cachedGuildEdge?: Resolver<Maybe<ResolversTypes['CachedGuildsEdge']>, ParentType, ContextType, RequireFields<CreateCachedGuildPayloadCachedGuildEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCachedUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCachedUserPayload'] = ResolversParentTypes['CreateCachedUserPayload']> = {
  cachedUser?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType>;
  cachedUserEdge?: Resolver<Maybe<ResolversTypes['CachedUsersEdge']>, ParentType, ContextType, RequireFields<CreateCachedUserPayloadCachedUserEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateEmojiStickerStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateEmojiStickerStatPayload'] = ResolversParentTypes['CreateEmojiStickerStatPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiStickerStat?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType>;
  emojiStickerStatEdge?: Resolver<Maybe<ResolversTypes['EmojiStickerStatsEdge']>, ParentType, ContextType, RequireFields<CreateEmojiStickerStatPayloadEmojiStickerStatEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFeedItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedItemPayload'] = ResolversParentTypes['CreateFeedItemPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedItem?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType>;
  feedItemEdge?: Resolver<Maybe<ResolversTypes['FeedItemsEdge']>, ParentType, ContextType, RequireFields<CreateFeedItemPayloadFeedItemEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFeedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedPayload'] = ResolversParentTypes['CreateFeedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedEdge?: Resolver<Maybe<ResolversTypes['FeedsEdge']>, ParentType, ContextType, RequireFields<CreateFeedPayloadFeedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFeedSubscriptionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedSubscriptionPayload'] = ResolversParentTypes['CreateFeedSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedSubscription?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType>;
  feedSubscriptionEdge?: Resolver<Maybe<ResolversTypes['FeedSubscriptionsEdge']>, ParentType, ContextType, RequireFields<CreateFeedSubscriptionPayloadFeedSubscriptionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateGuildBanPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateGuildBanPayload'] = ResolversParentTypes['CreateGuildBanPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildBan?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType>;
  guildBanEdge?: Resolver<Maybe<ResolversTypes['GuildBansEdge']>, ParentType, ContextType, RequireFields<CreateGuildBanPayloadGuildBanEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateGuildConfigPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateGuildConfigPayload'] = ResolversParentTypes['CreateGuildConfigPayload']> = {
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildConfig?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  guildConfigEdge?: Resolver<Maybe<ResolversTypes['GuildConfigsEdge']>, ParentType, ContextType, RequireFields<CreateGuildConfigPayloadGuildConfigEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateLevelRoleApplyJobPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateLevelRoleApplyJobPayload'] = ResolversParentTypes['CreateLevelRoleApplyJobPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleApplyJob?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType>;
  levelRoleApplyJobEdge?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobsEdge']>, ParentType, ContextType, RequireFields<CreateLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateLevelRoleOverridePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateLevelRoleOverridePayload'] = ResolversParentTypes['CreateLevelRoleOverridePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleOverride?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType>;
  levelRoleOverrideEdge?: Resolver<Maybe<ResolversTypes['LevelRoleOverridesEdge']>, ParentType, ContextType, RequireFields<CreateLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateLevelRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateLevelRolePayload'] = ResolversParentTypes['CreateLevelRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRole?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType>;
  levelRoleEdge?: Resolver<Maybe<ResolversTypes['LevelRolesEdge']>, ParentType, ContextType, RequireFields<CreateLevelRolePayloadLevelRoleEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateMemberPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateMemberPayload'] = ResolversParentTypes['CreateMemberPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  member?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType>;
  memberEdge?: Resolver<Maybe<ResolversTypes['MembersEdge']>, ParentType, ContextType, RequireFields<CreateMemberPayloadMemberEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateMessagePayload'] = ResolversParentTypes['CreateMessagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<CreateMessagePayloadMessageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateModLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateModLogPayload'] = ResolversParentTypes['CreateModLogPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLog?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  modLogEdge?: Resolver<Maybe<ResolversTypes['ModLogsEdge']>, ParentType, ContextType, RequireFields<CreateModLogPayloadModLogEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateMsgLogBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateMsgLogBlockPayload'] = ResolversParentTypes['CreateMsgLogBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  msgLogBlock?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType>;
  msgLogBlockEdge?: Resolver<Maybe<ResolversTypes['MsgLogBlocksEdge']>, ParentType, ContextType, RequireFields<CreateMsgLogBlockPayloadMsgLogBlockEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateMutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateMutePayload'] = ResolversParentTypes['CreateMutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  mute?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType>;
  muteEdge?: Resolver<Maybe<ResolversTypes['MutesEdge']>, ParentType, ContextType, RequireFields<CreateMutePayloadMuteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateNotificationPayload'] = ResolversParentTypes['CreateNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<CreateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReminderPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReminderPayload'] = ResolversParentTypes['CreateReminderPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reminder?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType>;
  reminderEdge?: Resolver<Maybe<ResolversTypes['RemindersEdge']>, ParentType, ContextType, RequireFields<CreateReminderPayloadReminderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRoleMenuPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateRoleMenuPayload'] = ResolversParentTypes['CreateRoleMenuPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenu?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuEdge?: Resolver<Maybe<ResolversTypes['RoleMenusEdge']>, ParentType, ContextType, RequireFields<CreateRoleMenuPayloadRoleMenuEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRoleMenuRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateRoleMenuRolePayload'] = ResolversParentTypes['CreateRoleMenuRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuRole?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType>;
  roleMenuRoleEdge?: Resolver<Maybe<ResolversTypes['RoleMenuRolesEdge']>, ParentType, ContextType, RequireFields<CreateRoleMenuRolePayloadRoleMenuRoleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTagPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTagPayload'] = ResolversParentTypes['CreateTagPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<CreateTagPayloadTagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserLevelPayload'] = ResolversParentTypes['CreateUserLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userLevel?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType>;
  userLevelEdge?: Resolver<Maybe<ResolversTypes['UserLevelsEdge']>, ParentType, ContextType, RequireFields<CreateUserLevelPayloadUserLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserPayload'] = ResolversParentTypes['CreateUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<CreateUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateWebUserGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateWebUserGuildPayload'] = ResolversParentTypes['CreateWebUserGuildPayload']> = {
  cachedGuildByGuildId?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUserByUserId?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserGuild?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType>;
  webUserGuildEdge?: Resolver<Maybe<ResolversTypes['WebUserGuildsEdge']>, ParentType, ContextType, RequireFields<CreateWebUserGuildPayloadWebUserGuildEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateWebUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateWebUserPayload'] = ResolversParentTypes['CreateWebUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserEdge?: Resolver<Maybe<ResolversTypes['WebUsersEdge']>, ParentType, ContextType, RequireFields<CreateWebUserPayloadWebUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateXpBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateXpBlockPayload'] = ResolversParentTypes['CreateXpBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  xpBlock?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType>;
  xpBlockEdge?: Resolver<Maybe<ResolversTypes['XpBlocksEdge']>, ParentType, ContextType, RequireFields<CreateXpBlockPayloadXpBlockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CurrentUserManagedGuildIdEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CurrentUserManagedGuildIdEdge'] = ResolversParentTypes['CurrentUserManagedGuildIdEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CurrentUserManagedGuildIdsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CurrentUserManagedGuildIdsConnection'] = ResolversParentTypes['CurrentUserManagedGuildIdsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CurrentUserManagedGuildIdEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['BigInt']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {
  name: 'Datetime';
}

export type DeleteBotStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteBotStatPayload'] = ResolversParentTypes['DeleteBotStatPayload']> = {
  botStat?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType>;
  botStatEdge?: Resolver<Maybe<ResolversTypes['BotStatsEdge']>, ParentType, ContextType, RequireFields<DeleteBotStatPayloadBotStatEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedBotStatId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteCachedGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteCachedGuildPayload'] = ResolversParentTypes['DeleteCachedGuildPayload']> = {
  cachedGuild?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  cachedGuildEdge?: Resolver<Maybe<ResolversTypes['CachedGuildsEdge']>, ParentType, ContextType, RequireFields<DeleteCachedGuildPayloadCachedGuildEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedCachedGuildId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteCachedUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteCachedUserPayload'] = ResolversParentTypes['DeleteCachedUserPayload']> = {
  cachedUser?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType>;
  cachedUserEdge?: Resolver<Maybe<ResolversTypes['CachedUsersEdge']>, ParentType, ContextType, RequireFields<DeleteCachedUserPayloadCachedUserEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedCachedUserId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteEmojiStickerStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteEmojiStickerStatPayload'] = ResolversParentTypes['DeleteEmojiStickerStatPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedEmojiStickerStatId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  emojiStickerStat?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType>;
  emojiStickerStatEdge?: Resolver<Maybe<ResolversTypes['EmojiStickerStatsEdge']>, ParentType, ContextType, RequireFields<DeleteEmojiStickerStatPayloadEmojiStickerStatEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFeedItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFeedItemPayload'] = ResolversParentTypes['DeleteFeedItemPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedFeedItemId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  feedItem?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType>;
  feedItemEdge?: Resolver<Maybe<ResolversTypes['FeedItemsEdge']>, ParentType, ContextType, RequireFields<DeleteFeedItemPayloadFeedItemEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFeedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFeedPayload'] = ResolversParentTypes['DeleteFeedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedFeedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedEdge?: Resolver<Maybe<ResolversTypes['FeedsEdge']>, ParentType, ContextType, RequireFields<DeleteFeedPayloadFeedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFeedSubscriptionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFeedSubscriptionPayload'] = ResolversParentTypes['DeleteFeedSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedFeedSubscriptionId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedSubscription?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType>;
  feedSubscriptionEdge?: Resolver<Maybe<ResolversTypes['FeedSubscriptionsEdge']>, ParentType, ContextType, RequireFields<DeleteFeedSubscriptionPayloadFeedSubscriptionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteGuildBanPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteGuildBanPayload'] = ResolversParentTypes['DeleteGuildBanPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedGuildBanId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  guildBan?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType>;
  guildBanEdge?: Resolver<Maybe<ResolversTypes['GuildBansEdge']>, ParentType, ContextType, RequireFields<DeleteGuildBanPayloadGuildBanEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteGuildConfigPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteGuildConfigPayload'] = ResolversParentTypes['DeleteGuildConfigPayload']> = {
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedGuildConfigId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  guildConfig?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  guildConfigEdge?: Resolver<Maybe<ResolversTypes['GuildConfigsEdge']>, ParentType, ContextType, RequireFields<DeleteGuildConfigPayloadGuildConfigEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteLevelRoleApplyJobPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteLevelRoleApplyJobPayload'] = ResolversParentTypes['DeleteLevelRoleApplyJobPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedLevelRoleApplyJobId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  levelRoleApplyJob?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType>;
  levelRoleApplyJobEdge?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobsEdge']>, ParentType, ContextType, RequireFields<DeleteLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteLevelRoleOverridePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteLevelRoleOverridePayload'] = ResolversParentTypes['DeleteLevelRoleOverridePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedLevelRoleOverrideId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  levelRoleOverride?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType>;
  levelRoleOverrideEdge?: Resolver<Maybe<ResolversTypes['LevelRoleOverridesEdge']>, ParentType, ContextType, RequireFields<DeleteLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteLevelRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteLevelRolePayload'] = ResolversParentTypes['DeleteLevelRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedLevelRoleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  levelRole?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType>;
  levelRoleEdge?: Resolver<Maybe<ResolversTypes['LevelRolesEdge']>, ParentType, ContextType, RequireFields<DeleteLevelRolePayloadLevelRoleEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMemberPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMemberPayload'] = ResolversParentTypes['DeleteMemberPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedMemberId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  member?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType>;
  memberEdge?: Resolver<Maybe<ResolversTypes['MembersEdge']>, ParentType, ContextType, RequireFields<DeleteMemberPayloadMemberEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMessagePayload'] = ResolversParentTypes['DeleteMessagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedMessageId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<DeleteMessagePayloadMessageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMessagesBeforePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMessagesBeforePayload'] = ResolversParentTypes['DeleteMessagesBeforePayload']> = {
  bigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteModLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteModLogPayload'] = ResolversParentTypes['DeleteModLogPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedModLogId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  modLog?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  modLogEdge?: Resolver<Maybe<ResolversTypes['ModLogsEdge']>, ParentType, ContextType, RequireFields<DeleteModLogPayloadModLogEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMsgLogBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMsgLogBlockPayload'] = ResolversParentTypes['DeleteMsgLogBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedMsgLogBlockId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  msgLogBlock?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType>;
  msgLogBlockEdge?: Resolver<Maybe<ResolversTypes['MsgLogBlocksEdge']>, ParentType, ContextType, RequireFields<DeleteMsgLogBlockPayloadMsgLogBlockEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMutePayload'] = ResolversParentTypes['DeleteMutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedMuteId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  mute?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType>;
  muteEdge?: Resolver<Maybe<ResolversTypes['MutesEdge']>, ParentType, ContextType, RequireFields<DeleteMutePayloadMuteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteNotificationPayload'] = ResolversParentTypes['DeleteNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedNotificationId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<DeleteNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReminderPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReminderPayload'] = ResolversParentTypes['DeleteReminderPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReminderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reminder?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType>;
  reminderEdge?: Resolver<Maybe<ResolversTypes['RemindersEdge']>, ParentType, ContextType, RequireFields<DeleteReminderPayloadReminderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRoleMenuPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteRoleMenuPayload'] = ResolversParentTypes['DeleteRoleMenuPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedRoleMenuId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenu?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuEdge?: Resolver<Maybe<ResolversTypes['RoleMenusEdge']>, ParentType, ContextType, RequireFields<DeleteRoleMenuPayloadRoleMenuEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRoleMenuRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteRoleMenuRolePayload'] = ResolversParentTypes['DeleteRoleMenuRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedRoleMenuRoleId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuRole?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType>;
  roleMenuRoleEdge?: Resolver<Maybe<ResolversTypes['RoleMenuRolesEdge']>, ParentType, ContextType, RequireFields<DeleteRoleMenuRolePayloadRoleMenuRoleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRoleMenuRolesPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteRoleMenuRolesPayload'] = ResolversParentTypes['DeleteRoleMenuRolesPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuRoles?: Resolver<Maybe<Array<ResolversTypes['RoleMenuRole']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTagPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTagPayload'] = ResolversParentTypes['DeleteTagPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTagId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<DeleteTagPayloadTagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserLevelPayload'] = ResolversParentTypes['DeleteUserLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedUserLevelId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userLevel?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType>;
  userLevelEdge?: Resolver<Maybe<ResolversTypes['UserLevelsEdge']>, ParentType, ContextType, RequireFields<DeleteUserLevelPayloadUserLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserPayload'] = ResolversParentTypes['DeleteUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedUserId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<DeleteUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteWebUserGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteWebUserGuildPayload'] = ResolversParentTypes['DeleteWebUserGuildPayload']> = {
  cachedGuildByGuildId?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedWebUserGuildId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUserByUserId?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserGuild?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType>;
  webUserGuildEdge?: Resolver<Maybe<ResolversTypes['WebUserGuildsEdge']>, ParentType, ContextType, RequireFields<DeleteWebUserGuildPayloadWebUserGuildEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteWebUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteWebUserPayload'] = ResolversParentTypes['DeleteWebUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedWebUserId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserEdge?: Resolver<Maybe<ResolversTypes['WebUsersEdge']>, ParentType, ContextType, RequireFields<DeleteWebUserPayloadWebUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteXpBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteXpBlockPayload'] = ResolversParentTypes['DeleteXpBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedXpBlockId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  xpBlock?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType>;
  xpBlockEdge?: Resolver<Maybe<ResolversTypes['XpBlocksEdge']>, ParentType, ContextType, RequireFields<DeleteXpBlockPayloadXpBlockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EligibleLevelRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['EligibleLevelRole'] = ResolversParentTypes['EligibleLevelRole']> = {
  roleIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['BigInt']>>>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EligibleLevelRolesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EligibleLevelRolesConnection'] = ResolversParentTypes['EligibleLevelRolesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['EligibleLevelRolesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['EligibleLevelRole']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EligibleLevelRolesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EligibleLevelRolesEdge'] = ResolversParentTypes['EligibleLevelRolesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EligibleLevelRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStat'] = ResolversParentTypes['EmojiStickerStat']> = {
  actionType?: Resolver<ResolversTypes['EmojiStickerActionType'], ParentType, ContextType>;
  assetId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  assetType?: Resolver<ResolversTypes['GuildAssetType'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  time?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatAggregates'] = ResolversParentTypes['EmojiStickerStatAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['EmojiStickerStatAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['EmojiStickerStatDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['EmojiStickerStatMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['EmojiStickerStatMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['EmojiStickerStatStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['EmojiStickerStatStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['EmojiStickerStatSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['EmojiStickerStatVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['EmojiStickerStatVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatAverageAggregates'] = ResolversParentTypes['EmojiStickerStatAverageAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatDistinctCountAggregates'] = ResolversParentTypes['EmojiStickerStatDistinctCountAggregates']> = {
  actionType?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  assetId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  assetType?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  time?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatMaxAggregates'] = ResolversParentTypes['EmojiStickerStatMaxAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatMinAggregates'] = ResolversParentTypes['EmojiStickerStatMinAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatStddevPopulationAggregates'] = ResolversParentTypes['EmojiStickerStatStddevPopulationAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatStddevSampleAggregates'] = ResolversParentTypes['EmojiStickerStatStddevSampleAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatSumAggregates'] = ResolversParentTypes['EmojiStickerStatSumAggregates']> = {
  assetId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatVariancePopulationAggregates'] = ResolversParentTypes['EmojiStickerStatVariancePopulationAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatVarianceSampleAggregates'] = ResolversParentTypes['EmojiStickerStatVarianceSampleAggregates']> = {
  assetId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatsConnection'] = ResolversParentTypes['EmojiStickerStatsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['EmojiStickerStatAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['EmojiStickerStatsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['EmojiStickerStatAggregates']>>, ParentType, ContextType, RequireFields<EmojiStickerStatsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmojiStickerStatsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmojiStickerStatsEdge'] = ResolversParentTypes['EmojiStickerStatsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EmojiStickerStat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Feed'] = ResolversParentTypes['Feed']> = {
  feedId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  feedSubscriptionsByFeedId?: Resolver<ResolversTypes['FeedSubscriptionsConnection'], ParentType, ContextType, RequireFields<FeedFeedSubscriptionsByFeedIdArgs, 'orderBy'>>;
  metadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedAggregates'] = ResolversParentTypes['FeedAggregates']> = {
  distinctCount?: Resolver<Maybe<ResolversTypes['FeedDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedDistinctCountAggregates'] = ResolversParentTypes['FeedDistinctCountAggregates']> = {
  feedId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  metadata?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedItem'] = ResolversParentTypes['FeedItem']> = {
  feedId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  itemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedItemAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedItemAggregates'] = ResolversParentTypes['FeedItemAggregates']> = {
  distinctCount?: Resolver<Maybe<ResolversTypes['FeedItemDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedItemDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedItemDistinctCountAggregates'] = ResolversParentTypes['FeedItemDistinctCountAggregates']> = {
  feedId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  itemId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedItemsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedItemsConnection'] = ResolversParentTypes['FeedItemsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['FeedItemAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['FeedItemsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['FeedItemAggregates']>>, ParentType, ContextType, RequireFields<FeedItemsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['FeedItem']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedItemsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedItemsEdge'] = ResolversParentTypes['FeedItemsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['FeedItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscription'] = ResolversParentTypes['FeedSubscription']> = {
  channelId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionAggregates'] = ResolversParentTypes['FeedSubscriptionAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['FeedSubscriptionAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['FeedSubscriptionDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['FeedSubscriptionMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['FeedSubscriptionMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['FeedSubscriptionStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['FeedSubscriptionStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['FeedSubscriptionSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['FeedSubscriptionVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['FeedSubscriptionVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionAverageAggregates'] = ResolversParentTypes['FeedSubscriptionAverageAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionDistinctCountAggregates'] = ResolversParentTypes['FeedSubscriptionDistinctCountAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  feedId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionMaxAggregates'] = ResolversParentTypes['FeedSubscriptionMaxAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionMinAggregates'] = ResolversParentTypes['FeedSubscriptionMinAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionStddevPopulationAggregates'] = ResolversParentTypes['FeedSubscriptionStddevPopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionStddevSampleAggregates'] = ResolversParentTypes['FeedSubscriptionStddevSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionSumAggregates'] = ResolversParentTypes['FeedSubscriptionSumAggregates']> = {
  channelId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  mentionRole?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionVariancePopulationAggregates'] = ResolversParentTypes['FeedSubscriptionVariancePopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionVarianceSampleAggregates'] = ResolversParentTypes['FeedSubscriptionVarianceSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  mentionRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionsConnection'] = ResolversParentTypes['FeedSubscriptionsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['FeedSubscriptionAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['FeedSubscriptionsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['FeedSubscriptionAggregates']>>, ParentType, ContextType, RequireFields<FeedSubscriptionsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['FeedSubscription']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedSubscriptionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedSubscriptionsEdge'] = ResolversParentTypes['FeedSubscriptionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['FeedSubscription'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedsConnection'] = ResolversParentTypes['FeedsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['FeedAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['FeedsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['FeedAggregates']>>, ParentType, ContextType, RequireFields<FeedsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Feed']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedsEdge'] = ResolversParentTypes['FeedsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Feed'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GraphqlPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GraphqlPayload'] = ResolversParentTypes['GraphqlPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  json?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBan'] = ResolversParentTypes['GuildBan']> = {
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanAggregates'] = ResolversParentTypes['GuildBanAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['GuildBanAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['GuildBanDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['GuildBanMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['GuildBanMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['GuildBanStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['GuildBanStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['GuildBanSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['GuildBanVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['GuildBanVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanAverageAggregates'] = ResolversParentTypes['GuildBanAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanDistinctCountAggregates'] = ResolversParentTypes['GuildBanDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanMaxAggregates'] = ResolversParentTypes['GuildBanMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanMinAggregates'] = ResolversParentTypes['GuildBanMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanStddevPopulationAggregates'] = ResolversParentTypes['GuildBanStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanStddevSampleAggregates'] = ResolversParentTypes['GuildBanStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanSumAggregates'] = ResolversParentTypes['GuildBanSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanVariancePopulationAggregates'] = ResolversParentTypes['GuildBanVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBanVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBanVarianceSampleAggregates'] = ResolversParentTypes['GuildBanVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBansConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBansConnection'] = ResolversParentTypes['GuildBansConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['GuildBanAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['GuildBansEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['GuildBanAggregates']>>, ParentType, ContextType, RequireFields<GuildBansConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['GuildBan']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildBansEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildBansEdge'] = ResolversParentTypes['GuildBansEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['GuildBan'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfig'] = ResolversParentTypes['GuildConfig']> = {
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  data?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  disabledChannels?: Resolver<Maybe<Array<Maybe<ResolversTypes['BigInt']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  inviteGuard?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  joinMsg?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  joinMsgEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  joinReact?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  leaveMsg?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  leaveMsgEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMemberEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logModEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMsgEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDmEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  muteDmText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleConfig?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  roleEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  warnDmEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  warnDmText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigAggregates'] = ResolversParentTypes['GuildConfigAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['GuildConfigAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['GuildConfigDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['GuildConfigMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['GuildConfigMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['GuildConfigStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['GuildConfigStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['GuildConfigSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['GuildConfigVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['GuildConfigVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigAverageAggregates'] = ResolversParentTypes['GuildConfigAverageAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigDistinctCountAggregates'] = ResolversParentTypes['GuildConfigDistinctCountAggregates']> = {
  data?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  disabledChannels?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  inviteGuard?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  joinMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  joinMsgEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  joinReact?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  leaveMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  leaveMsgEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMemberEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logModEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMsgEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDmEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDmText?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleConfig?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  warnDmEnabled?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  warnDmText?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigMaxAggregates'] = ResolversParentTypes['GuildConfigMaxAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigMinAggregates'] = ResolversParentTypes['GuildConfigMinAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigStddevPopulationAggregates'] = ResolversParentTypes['GuildConfigStddevPopulationAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigStddevSampleAggregates'] = ResolversParentTypes['GuildConfigStddevSampleAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigSumAggregates'] = ResolversParentTypes['GuildConfigSumAggregates']> = {
  id?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  logMember?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  logMod?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  logMsg?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  maxMention?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgChannel?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  muteDuration?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  muteRole?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  roleChannel?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigVariancePopulationAggregates'] = ResolversParentTypes['GuildConfigVariancePopulationAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigVarianceSampleAggregates'] = ResolversParentTypes['GuildConfigVarianceSampleAggregates']> = {
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMember?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMod?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  logMsg?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxMention?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteDuration?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  muteRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleChannel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigsConnection'] = ResolversParentTypes['GuildConfigsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['GuildConfigAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['GuildConfigsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['GuildConfigAggregates']>>, ParentType, ContextType, RequireFields<GuildConfigsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GuildConfigsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildConfigsEdge'] = ResolversParentTypes['GuildConfigsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['GuildConfig'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IncrementEmojiStickerStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['IncrementEmojiStickerStatPayload'] = ResolversParentTypes['IncrementEmojiStickerStatPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type LevelRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRole'] = ResolversParentTypes['LevelRole']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleAggregates'] = ResolversParentTypes['LevelRoleAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['LevelRoleAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['LevelRoleDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['LevelRoleMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['LevelRoleMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['LevelRoleStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['LevelRoleStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['LevelRoleSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['LevelRoleVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['LevelRoleVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJob'] = ResolversParentTypes['LevelRoleApplyJob']> = {
  channelId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  interactionId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  membersApplied?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  membersNotFound?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  membersSkipped?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  membersTotal?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  membersTotalProcessed?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  messageId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notifyUserId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  requestsProcessed?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobAggregates'] = ResolversParentTypes['LevelRoleApplyJobAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobAverageAggregates'] = ResolversParentTypes['LevelRoleApplyJobAverageAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobDistinctCountAggregates'] = ResolversParentTypes['LevelRoleApplyJobDistinctCountAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobMaxAggregates'] = ResolversParentTypes['LevelRoleApplyJobMaxAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobMinAggregates'] = ResolversParentTypes['LevelRoleApplyJobMinAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobStddevPopulationAggregates'] = ResolversParentTypes['LevelRoleApplyJobStddevPopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobStddevSampleAggregates'] = ResolversParentTypes['LevelRoleApplyJobStddevSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobSumAggregates'] = ResolversParentTypes['LevelRoleApplyJobSumAggregates']> = {
  channelId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  interactionId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  membersApplied?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  membersNotFound?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  membersSkipped?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  membersTotal?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  membersTotalProcessed?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  messageId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  notifyUserId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  requestsProcessed?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  requestsTotal?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobVariancePopulationAggregates'] = ResolversParentTypes['LevelRoleApplyJobVariancePopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobVarianceSampleAggregates'] = ResolversParentTypes['LevelRoleApplyJobVarianceSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersApplied?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersNotFound?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersSkipped?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  membersTotalProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  notifyUserId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsProcessed?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requestsTotal?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobsConnection'] = ResolversParentTypes['LevelRoleApplyJobsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['LevelRoleApplyJobsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['LevelRoleApplyJobAggregates']>>, ParentType, ContextType, RequireFields<LevelRoleApplyJobsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleApplyJobsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleApplyJobsEdge'] = ResolversParentTypes['LevelRoleApplyJobsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['LevelRoleApplyJob'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleAverageAggregates'] = ResolversParentTypes['LevelRoleAverageAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleDistinctCountAggregates'] = ResolversParentTypes['LevelRoleDistinctCountAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleMaxAggregates'] = ResolversParentTypes['LevelRoleMaxAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleMinAggregates'] = ResolversParentTypes['LevelRoleMinAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverride'] = ResolversParentTypes['LevelRoleOverride']> = {
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['LevelRoleOverrideType'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideAggregates'] = ResolversParentTypes['LevelRoleOverrideAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideAverageAggregates'] = ResolversParentTypes['LevelRoleOverrideAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideDistinctCountAggregates'] = ResolversParentTypes['LevelRoleOverrideDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideMaxAggregates'] = ResolversParentTypes['LevelRoleOverrideMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideMinAggregates'] = ResolversParentTypes['LevelRoleOverrideMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideStddevPopulationAggregates'] = ResolversParentTypes['LevelRoleOverrideStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideStddevSampleAggregates'] = ResolversParentTypes['LevelRoleOverrideStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideSumAggregates'] = ResolversParentTypes['LevelRoleOverrideSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideVariancePopulationAggregates'] = ResolversParentTypes['LevelRoleOverrideVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverrideVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverrideVarianceSampleAggregates'] = ResolversParentTypes['LevelRoleOverrideVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverridesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverridesConnection'] = ResolversParentTypes['LevelRoleOverridesConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['LevelRoleOverrideAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['LevelRoleOverridesEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['LevelRoleOverrideAggregates']>>, ParentType, ContextType, RequireFields<LevelRoleOverridesConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleOverridesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleOverridesEdge'] = ResolversParentTypes['LevelRoleOverridesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['LevelRoleOverride'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleStddevPopulationAggregates'] = ResolversParentTypes['LevelRoleStddevPopulationAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleStddevSampleAggregates'] = ResolversParentTypes['LevelRoleStddevSampleAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleSumAggregates'] = ResolversParentTypes['LevelRoleSumAggregates']> = {
  addLevel?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  removeLevel?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleVariancePopulationAggregates'] = ResolversParentTypes['LevelRoleVariancePopulationAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRoleVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRoleVarianceSampleAggregates'] = ResolversParentTypes['LevelRoleVarianceSampleAggregates']> = {
  addLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  removeLevel?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRolesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRolesConnection'] = ResolversParentTypes['LevelRolesConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['LevelRoleAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['LevelRolesEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['LevelRoleAggregates']>>, ParentType, ContextType, RequireFields<LevelRolesConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['LevelRole']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LevelRolesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LevelRolesEdge'] = ResolversParentTypes['LevelRolesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['LevelRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogoutPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogoutPayload'] = ResolversParentTypes['LogoutPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberResolvers<ContextType = any, ParentType extends ResolversParentTypes['Member'] = ResolversParentTypes['Member']> = {
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  joinTime?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberAggregates'] = ResolversParentTypes['MemberAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['MemberAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['MemberDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['MemberMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['MemberMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['MemberStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['MemberStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['MemberSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['MemberVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['MemberVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberAverageAggregates'] = ResolversParentTypes['MemberAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberDistinctCountAggregates'] = ResolversParentTypes['MemberDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  joinTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberMaxAggregates'] = ResolversParentTypes['MemberMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberMinAggregates'] = ResolversParentTypes['MemberMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberStddevPopulationAggregates'] = ResolversParentTypes['MemberStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberStddevSampleAggregates'] = ResolversParentTypes['MemberStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberSumAggregates'] = ResolversParentTypes['MemberSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberVariancePopulationAggregates'] = ResolversParentTypes['MemberVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MemberVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MemberVarianceSampleAggregates'] = ResolversParentTypes['MemberVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MembersConnection'] = ResolversParentTypes['MembersConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['MemberAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MembersEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['MemberAggregates']>>, ParentType, ContextType, RequireFields<MembersConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Member']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MembersEdge'] = ResolversParentTypes['MembersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Member'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Message'] = ResolversParentTypes['Message']> = {
  authorId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  channelId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  messageId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msg?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageAggregates'] = ResolversParentTypes['MessageAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['MessageAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['MessageDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['MessageMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['MessageMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['MessageStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['MessageStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['MessageSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['MessageVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['MessageVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageAverageAggregates'] = ResolversParentTypes['MessageAverageAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageDistinctCountAggregates'] = ResolversParentTypes['MessageDistinctCountAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageMaxAggregates'] = ResolversParentTypes['MessageMaxAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageMinAggregates'] = ResolversParentTypes['MessageMinAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageStddevPopulationAggregates'] = ResolversParentTypes['MessageStddevPopulationAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageStddevSampleAggregates'] = ResolversParentTypes['MessageStddevSampleAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageSumAggregates'] = ResolversParentTypes['MessageSumAggregates']> = {
  authorId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  channelId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  messageId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageVariancePopulationAggregates'] = ResolversParentTypes['MessageVariancePopulationAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageVarianceSampleAggregates'] = ResolversParentTypes['MessageVarianceSampleAggregates']> = {
  authorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  messageId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessagesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagesConnection'] = ResolversParentTypes['MessagesConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['MessageAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MessagesEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['MessageAggregates']>>, ParentType, ContextType, RequireFields<MessagesConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Message']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessagesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagesEdge'] = ResolversParentTypes['MessagesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Message'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLog'] = ResolversParentTypes['ModLog']> = {
  action?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  actionTime?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  attachments?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  caseId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  mutesByGuildIdAndCaseId?: Resolver<ResolversTypes['MutesConnection'], ParentType, ContextType, RequireFields<ModLogMutesByGuildIdAndCaseIdArgs, 'orderBy'>>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  userTag?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogAggregates'] = ResolversParentTypes['ModLogAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['ModLogAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['ModLogDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['ModLogMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['ModLogMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['ModLogStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['ModLogStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['ModLogSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['ModLogVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['ModLogVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogAverageAggregates'] = ResolversParentTypes['ModLogAverageAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogDistinctCountAggregates'] = ResolversParentTypes['ModLogDistinctCountAggregates']> = {
  action?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  actionTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  attachments?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  pending?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userTag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogMaxAggregates'] = ResolversParentTypes['ModLogMaxAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogMinAggregates'] = ResolversParentTypes['ModLogMinAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogStddevPopulationAggregates'] = ResolversParentTypes['ModLogStddevPopulationAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogStddevSampleAggregates'] = ResolversParentTypes['ModLogStddevSampleAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogSumAggregates'] = ResolversParentTypes['ModLogSumAggregates']> = {
  caseId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  executorId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  msgId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogVariancePopulationAggregates'] = ResolversParentTypes['ModLogVariancePopulationAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogVarianceSampleAggregates'] = ResolversParentTypes['ModLogVarianceSampleAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  executorId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogsConnection'] = ResolversParentTypes['ModLogsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['ModLogAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ModLogsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['ModLogAggregates']>>, ParentType, ContextType, RequireFields<ModLogsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['ModLog']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ModLogsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ModLogsEdge'] = ResolversParentTypes['ModLogsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ModLog'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlock'] = ResolversParentTypes['MsgLogBlock']> = {
  blockType?: Resolver<ResolversTypes['MsgLogBlockType'], ParentType, ContextType>;
  channelId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockAggregates'] = ResolversParentTypes['MsgLogBlockAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['MsgLogBlockAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['MsgLogBlockDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['MsgLogBlockMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['MsgLogBlockMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['MsgLogBlockStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['MsgLogBlockStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['MsgLogBlockSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['MsgLogBlockVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['MsgLogBlockVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockAverageAggregates'] = ResolversParentTypes['MsgLogBlockAverageAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockDistinctCountAggregates'] = ResolversParentTypes['MsgLogBlockDistinctCountAggregates']> = {
  blockType?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockMaxAggregates'] = ResolversParentTypes['MsgLogBlockMaxAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockMinAggregates'] = ResolversParentTypes['MsgLogBlockMinAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockStddevPopulationAggregates'] = ResolversParentTypes['MsgLogBlockStddevPopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockStddevSampleAggregates'] = ResolversParentTypes['MsgLogBlockStddevSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockSumAggregates'] = ResolversParentTypes['MsgLogBlockSumAggregates']> = {
  channelId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockVariancePopulationAggregates'] = ResolversParentTypes['MsgLogBlockVariancePopulationAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlockVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlockVarianceSampleAggregates'] = ResolversParentTypes['MsgLogBlockVarianceSampleAggregates']> = {
  channelId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlocksConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlocksConnection'] = ResolversParentTypes['MsgLogBlocksConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['MsgLogBlockAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MsgLogBlocksEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['MsgLogBlockAggregates']>>, ParentType, ContextType, RequireFields<MsgLogBlocksConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['MsgLogBlock']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MsgLogBlocksEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MsgLogBlocksEdge'] = ResolversParentTypes['MsgLogBlocksEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MsgLogBlock'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  addRoleMenuRoles?: Resolver<Maybe<ResolversTypes['AddRoleMenuRolesPayload']>, ParentType, ContextType, RequireFields<MutationAddRoleMenuRolesArgs, 'input'>>;
  bulkDeleteModLog?: Resolver<Maybe<ResolversTypes['BulkDeleteModLogPayload']>, ParentType, ContextType, RequireFields<MutationBulkDeleteModLogArgs, 'input'>>;
  bulkUpdateModLogReason?: Resolver<Maybe<ResolversTypes['BulkUpdateModLogReasonPayload']>, ParentType, ContextType, RequireFields<MutationBulkUpdateModLogReasonArgs, 'input'>>;
  createBotStat?: Resolver<Maybe<ResolversTypes['CreateBotStatPayload']>, ParentType, ContextType, RequireFields<MutationCreateBotStatArgs, 'input'>>;
  createCachedGuild?: Resolver<Maybe<ResolversTypes['CreateCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationCreateCachedGuildArgs, 'input'>>;
  createCachedUser?: Resolver<Maybe<ResolversTypes['CreateCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateCachedUserArgs, 'input'>>;
  createEmojiStickerStat?: Resolver<Maybe<ResolversTypes['CreateEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationCreateEmojiStickerStatArgs, 'input'>>;
  createFeed?: Resolver<Maybe<ResolversTypes['CreateFeedPayload']>, ParentType, ContextType, RequireFields<MutationCreateFeedArgs, 'input'>>;
  createFeedItem?: Resolver<Maybe<ResolversTypes['CreateFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationCreateFeedItemArgs, 'input'>>;
  createFeedSubscription?: Resolver<Maybe<ResolversTypes['CreateFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationCreateFeedSubscriptionArgs, 'input'>>;
  createGuildBan?: Resolver<Maybe<ResolversTypes['CreateGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationCreateGuildBanArgs, 'input'>>;
  createGuildConfig?: Resolver<Maybe<ResolversTypes['CreateGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationCreateGuildConfigArgs, 'input'>>;
  createLevelRole?: Resolver<Maybe<ResolversTypes['CreateLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationCreateLevelRoleArgs, 'input'>>;
  createLevelRoleApplyJob?: Resolver<Maybe<ResolversTypes['CreateLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationCreateLevelRoleApplyJobArgs, 'input'>>;
  createLevelRoleOverride?: Resolver<Maybe<ResolversTypes['CreateLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationCreateLevelRoleOverrideArgs, 'input'>>;
  createMember?: Resolver<Maybe<ResolversTypes['CreateMemberPayload']>, ParentType, ContextType, RequireFields<MutationCreateMemberArgs, 'input'>>;
  createMessage?: Resolver<Maybe<ResolversTypes['CreateMessagePayload']>, ParentType, ContextType, RequireFields<MutationCreateMessageArgs, 'input'>>;
  createModLog?: Resolver<Maybe<ResolversTypes['CreateModLogPayload']>, ParentType, ContextType, RequireFields<MutationCreateModLogArgs, 'input'>>;
  createMsgLogBlock?: Resolver<Maybe<ResolversTypes['CreateMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationCreateMsgLogBlockArgs, 'input'>>;
  createMute?: Resolver<Maybe<ResolversTypes['CreateMutePayload']>, ParentType, ContextType, RequireFields<MutationCreateMuteArgs, 'input'>>;
  createNotification?: Resolver<Maybe<ResolversTypes['CreateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationCreateNotificationArgs, 'input'>>;
  createReminder?: Resolver<Maybe<ResolversTypes['CreateReminderPayload']>, ParentType, ContextType, RequireFields<MutationCreateReminderArgs, 'input'>>;
  createRoleMenu?: Resolver<Maybe<ResolversTypes['CreateRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationCreateRoleMenuArgs, 'input'>>;
  createRoleMenuRole?: Resolver<Maybe<ResolversTypes['CreateRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationCreateRoleMenuRoleArgs, 'input'>>;
  createTag?: Resolver<Maybe<ResolversTypes['CreateTagPayload']>, ParentType, ContextType, RequireFields<MutationCreateTagArgs, 'input'>>;
  createUser?: Resolver<Maybe<ResolversTypes['CreateUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserArgs, 'input'>>;
  createUserLevel?: Resolver<Maybe<ResolversTypes['CreateUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserLevelArgs, 'input'>>;
  createWebUser?: Resolver<Maybe<ResolversTypes['CreateWebUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateWebUserArgs, 'input'>>;
  createWebUserGuild?: Resolver<Maybe<ResolversTypes['CreateWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationCreateWebUserGuildArgs, 'input'>>;
  createXpBlock?: Resolver<Maybe<ResolversTypes['CreateXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationCreateXpBlockArgs, 'input'>>;
  deleteBotStat?: Resolver<Maybe<ResolversTypes['DeleteBotStatPayload']>, ParentType, ContextType, RequireFields<MutationDeleteBotStatArgs, 'input'>>;
  deleteBotStatByNameAndCategory?: Resolver<Maybe<ResolversTypes['DeleteBotStatPayload']>, ParentType, ContextType, RequireFields<MutationDeleteBotStatByNameAndCategoryArgs, 'input'>>;
  deleteCachedGuild?: Resolver<Maybe<ResolversTypes['DeleteCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCachedGuildArgs, 'input'>>;
  deleteCachedGuildById?: Resolver<Maybe<ResolversTypes['DeleteCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCachedGuildByIdArgs, 'input'>>;
  deleteCachedUser?: Resolver<Maybe<ResolversTypes['DeleteCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCachedUserArgs, 'input'>>;
  deleteCachedUserById?: Resolver<Maybe<ResolversTypes['DeleteCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCachedUserByIdArgs, 'input'>>;
  deleteEmojiStickerStat?: Resolver<Maybe<ResolversTypes['DeleteEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationDeleteEmojiStickerStatArgs, 'input'>>;
  deleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Resolver<Maybe<ResolversTypes['DeleteEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationDeleteEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs, 'input'>>;
  deleteFeed?: Resolver<Maybe<ResolversTypes['DeleteFeedPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedArgs, 'input'>>;
  deleteFeedByFeedId?: Resolver<Maybe<ResolversTypes['DeleteFeedPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedByFeedIdArgs, 'input'>>;
  deleteFeedItem?: Resolver<Maybe<ResolversTypes['DeleteFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedItemArgs, 'input'>>;
  deleteFeedItemByFeedIdAndItemId?: Resolver<Maybe<ResolversTypes['DeleteFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedItemByFeedIdAndItemIdArgs, 'input'>>;
  deleteFeedSubscription?: Resolver<Maybe<ResolversTypes['DeleteFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedSubscriptionArgs, 'input'>>;
  deleteFeedSubscriptionByFeedIdAndChannelId?: Resolver<Maybe<ResolversTypes['DeleteFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFeedSubscriptionByFeedIdAndChannelIdArgs, 'input'>>;
  deleteGuildBan?: Resolver<Maybe<ResolversTypes['DeleteGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationDeleteGuildBanArgs, 'input'>>;
  deleteGuildBanByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['DeleteGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationDeleteGuildBanByGuildIdAndUserIdArgs, 'input'>>;
  deleteGuildConfig?: Resolver<Maybe<ResolversTypes['DeleteGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationDeleteGuildConfigArgs, 'input'>>;
  deleteGuildConfigById?: Resolver<Maybe<ResolversTypes['DeleteGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationDeleteGuildConfigByIdArgs, 'input'>>;
  deleteLevelRole?: Resolver<Maybe<ResolversTypes['DeleteLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleArgs, 'input'>>;
  deleteLevelRoleApplyJob?: Resolver<Maybe<ResolversTypes['DeleteLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleApplyJobArgs, 'input'>>;
  deleteLevelRoleApplyJobByGuildId?: Resolver<Maybe<ResolversTypes['DeleteLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleApplyJobByGuildIdArgs, 'input'>>;
  deleteLevelRoleApplyJobByInteractionId?: Resolver<Maybe<ResolversTypes['DeleteLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleApplyJobByInteractionIdArgs, 'input'>>;
  deleteLevelRoleByGuildIdAndRoleId?: Resolver<Maybe<ResolversTypes['DeleteLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleByGuildIdAndRoleIdArgs, 'input'>>;
  deleteLevelRoleOverride?: Resolver<Maybe<ResolversTypes['DeleteLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleOverrideArgs, 'input'>>;
  deleteLevelRoleOverrideByGuildIdAndRoleIdAndUserId?: Resolver<Maybe<ResolversTypes['DeleteLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationDeleteLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs, 'input'>>;
  deleteMember?: Resolver<Maybe<ResolversTypes['DeleteMemberPayload']>, ParentType, ContextType, RequireFields<MutationDeleteMemberArgs, 'input'>>;
  deleteMemberByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['DeleteMemberPayload']>, ParentType, ContextType, RequireFields<MutationDeleteMemberByGuildIdAndUserIdArgs, 'input'>>;
  deleteMessage?: Resolver<Maybe<ResolversTypes['DeleteMessagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteMessageArgs, 'input'>>;
  deleteMessageByMessageId?: Resolver<Maybe<ResolversTypes['DeleteMessagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteMessageByMessageIdArgs, 'input'>>;
  deleteMessagesBefore?: Resolver<Maybe<ResolversTypes['DeleteMessagesBeforePayload']>, ParentType, ContextType, RequireFields<MutationDeleteMessagesBeforeArgs, 'input'>>;
  deleteModLog?: Resolver<Maybe<ResolversTypes['DeleteModLogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteModLogArgs, 'input'>>;
  deleteModLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['DeleteModLogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteModLogByGuildIdAndCaseIdArgs, 'input'>>;
  deleteMsgLogBlock?: Resolver<Maybe<ResolversTypes['DeleteMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationDeleteMsgLogBlockArgs, 'input'>>;
  deleteMsgLogBlockByGuildIdAndChannelId?: Resolver<Maybe<ResolversTypes['DeleteMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationDeleteMsgLogBlockByGuildIdAndChannelIdArgs, 'input'>>;
  deleteMute?: Resolver<Maybe<ResolversTypes['DeleteMutePayload']>, ParentType, ContextType, RequireFields<MutationDeleteMuteArgs, 'input'>>;
  deleteMuteByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['DeleteMutePayload']>, ParentType, ContextType, RequireFields<MutationDeleteMuteByGuildIdAndUserIdArgs, 'input'>>;
  deleteNotification?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationArgs, 'input'>>;
  deleteNotificationByUserIdAndGuildIdAndKeyword?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationByUserIdAndGuildIdAndKeywordArgs, 'input'>>;
  deleteReminder?: Resolver<Maybe<ResolversTypes['DeleteReminderPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReminderArgs, 'input'>>;
  deleteReminderByUserIdAndSetAt?: Resolver<Maybe<ResolversTypes['DeleteReminderPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReminderByUserIdAndSetAtArgs, 'input'>>;
  deleteRoleMenu?: Resolver<Maybe<ResolversTypes['DeleteRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationDeleteRoleMenuArgs, 'input'>>;
  deleteRoleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['DeleteRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationDeleteRoleMenuByGuildIdAndMenuNameArgs, 'input'>>;
  deleteRoleMenuRole?: Resolver<Maybe<ResolversTypes['DeleteRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationDeleteRoleMenuRoleArgs, 'input'>>;
  deleteRoleMenuRoleByGuildIdAndMenuNameAndRoleId?: Resolver<Maybe<ResolversTypes['DeleteRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationDeleteRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs, 'input'>>;
  deleteRoleMenuRoles?: Resolver<Maybe<ResolversTypes['DeleteRoleMenuRolesPayload']>, ParentType, ContextType, RequireFields<MutationDeleteRoleMenuRolesArgs, 'input'>>;
  deleteTag?: Resolver<Maybe<ResolversTypes['DeleteTagPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTagArgs, 'input'>>;
  deleteTagByGuildIdAndTagName?: Resolver<Maybe<ResolversTypes['DeleteTagPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTagByGuildIdAndTagNameArgs, 'input'>>;
  deleteUser?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserArgs, 'input'>>;
  deleteUserById?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserByIdArgs, 'input'>>;
  deleteUserLevel?: Resolver<Maybe<ResolversTypes['DeleteUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserLevelArgs, 'input'>>;
  deleteUserLevelByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['DeleteUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserLevelByUserIdAndGuildIdArgs, 'input'>>;
  deleteWebUser?: Resolver<Maybe<ResolversTypes['DeleteWebUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteWebUserArgs, 'input'>>;
  deleteWebUserById?: Resolver<Maybe<ResolversTypes['DeleteWebUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteWebUserByIdArgs, 'input'>>;
  deleteWebUserGuild?: Resolver<Maybe<ResolversTypes['DeleteWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationDeleteWebUserGuildArgs, 'input'>>;
  deleteWebUserGuildByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['DeleteWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationDeleteWebUserGuildByUserIdAndGuildIdArgs, 'input'>>;
  deleteXpBlock?: Resolver<Maybe<ResolversTypes['DeleteXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationDeleteXpBlockArgs, 'input'>>;
  deleteXpBlockByGuildIdAndBlockId?: Resolver<Maybe<ResolversTypes['DeleteXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationDeleteXpBlockByGuildIdAndBlockIdArgs, 'input'>>;
  graphql?: Resolver<Maybe<ResolversTypes['GraphqlPayload']>, ParentType, ContextType, RequireFields<MutationGraphqlArgs, 'input'>>;
  incrementEmojiStickerStat?: Resolver<Maybe<ResolversTypes['IncrementEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationIncrementEmojiStickerStatArgs, 'input'>>;
  logout?: Resolver<Maybe<ResolversTypes['LogoutPayload']>, ParentType, ContextType, RequireFields<MutationLogoutArgs, 'input'>>;
  setRoleMenuRoleOrder?: Resolver<Maybe<ResolversTypes['SetRoleMenuRoleOrderPayload']>, ParentType, ContextType, RequireFields<MutationSetRoleMenuRoleOrderArgs, 'input'>>;
  updateBotStat?: Resolver<Maybe<ResolversTypes['UpdateBotStatPayload']>, ParentType, ContextType, RequireFields<MutationUpdateBotStatArgs, 'input'>>;
  updateBotStatByNameAndCategory?: Resolver<Maybe<ResolversTypes['UpdateBotStatPayload']>, ParentType, ContextType, RequireFields<MutationUpdateBotStatByNameAndCategoryArgs, 'input'>>;
  updateCachedGuild?: Resolver<Maybe<ResolversTypes['UpdateCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCachedGuildArgs, 'input'>>;
  updateCachedGuildById?: Resolver<Maybe<ResolversTypes['UpdateCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCachedGuildByIdArgs, 'input'>>;
  updateCachedUser?: Resolver<Maybe<ResolversTypes['UpdateCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCachedUserArgs, 'input'>>;
  updateCachedUserById?: Resolver<Maybe<ResolversTypes['UpdateCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCachedUserByIdArgs, 'input'>>;
  updateEmojiStickerStat?: Resolver<Maybe<ResolversTypes['UpdateEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationUpdateEmojiStickerStatArgs, 'input'>>;
  updateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Resolver<Maybe<ResolversTypes['UpdateEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationUpdateEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs, 'input'>>;
  updateFeed?: Resolver<Maybe<ResolversTypes['UpdateFeedPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedArgs, 'input'>>;
  updateFeedByFeedId?: Resolver<Maybe<ResolversTypes['UpdateFeedPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedByFeedIdArgs, 'input'>>;
  updateFeedItem?: Resolver<Maybe<ResolversTypes['UpdateFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedItemArgs, 'input'>>;
  updateFeedItemByFeedIdAndItemId?: Resolver<Maybe<ResolversTypes['UpdateFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedItemByFeedIdAndItemIdArgs, 'input'>>;
  updateFeedSubscription?: Resolver<Maybe<ResolversTypes['UpdateFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedSubscriptionArgs, 'input'>>;
  updateFeedSubscriptionByFeedIdAndChannelId?: Resolver<Maybe<ResolversTypes['UpdateFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFeedSubscriptionByFeedIdAndChannelIdArgs, 'input'>>;
  updateGuildBan?: Resolver<Maybe<ResolversTypes['UpdateGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationUpdateGuildBanArgs, 'input'>>;
  updateGuildBanByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['UpdateGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationUpdateGuildBanByGuildIdAndUserIdArgs, 'input'>>;
  updateGuildConfig?: Resolver<Maybe<ResolversTypes['UpdateGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationUpdateGuildConfigArgs, 'input'>>;
  updateGuildConfigById?: Resolver<Maybe<ResolversTypes['UpdateGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationUpdateGuildConfigByIdArgs, 'input'>>;
  updateLevelRole?: Resolver<Maybe<ResolversTypes['UpdateLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleArgs, 'input'>>;
  updateLevelRoleApplyJob?: Resolver<Maybe<ResolversTypes['UpdateLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleApplyJobArgs, 'input'>>;
  updateLevelRoleApplyJobByGuildId?: Resolver<Maybe<ResolversTypes['UpdateLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleApplyJobByGuildIdArgs, 'input'>>;
  updateLevelRoleApplyJobByInteractionId?: Resolver<Maybe<ResolversTypes['UpdateLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleApplyJobByInteractionIdArgs, 'input'>>;
  updateLevelRoleByGuildIdAndRoleId?: Resolver<Maybe<ResolversTypes['UpdateLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleByGuildIdAndRoleIdArgs, 'input'>>;
  updateLevelRoleOverride?: Resolver<Maybe<ResolversTypes['UpdateLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleOverrideArgs, 'input'>>;
  updateLevelRoleOverrideByGuildIdAndRoleIdAndUserId?: Resolver<Maybe<ResolversTypes['UpdateLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationUpdateLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs, 'input'>>;
  updateMember?: Resolver<Maybe<ResolversTypes['UpdateMemberPayload']>, ParentType, ContextType, RequireFields<MutationUpdateMemberArgs, 'input'>>;
  updateMemberByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['UpdateMemberPayload']>, ParentType, ContextType, RequireFields<MutationUpdateMemberByGuildIdAndUserIdArgs, 'input'>>;
  updateMessage?: Resolver<Maybe<ResolversTypes['UpdateMessagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateMessageArgs, 'input'>>;
  updateMessageByMessageId?: Resolver<Maybe<ResolversTypes['UpdateMessagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateMessageByMessageIdArgs, 'input'>>;
  updateModLog?: Resolver<Maybe<ResolversTypes['UpdateModLogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateModLogArgs, 'input'>>;
  updateModLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['UpdateModLogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateModLogByGuildIdAndCaseIdArgs, 'input'>>;
  updateMsgLogBlock?: Resolver<Maybe<ResolversTypes['UpdateMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpdateMsgLogBlockArgs, 'input'>>;
  updateMsgLogBlockByGuildIdAndChannelId?: Resolver<Maybe<ResolversTypes['UpdateMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpdateMsgLogBlockByGuildIdAndChannelIdArgs, 'input'>>;
  updateMute?: Resolver<Maybe<ResolversTypes['UpdateMutePayload']>, ParentType, ContextType, RequireFields<MutationUpdateMuteArgs, 'input'>>;
  updateMuteByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['UpdateMutePayload']>, ParentType, ContextType, RequireFields<MutationUpdateMuteByGuildIdAndUserIdArgs, 'input'>>;
  updateNotification?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationArgs, 'input'>>;
  updateNotificationByUserIdAndGuildIdAndKeyword?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationByUserIdAndGuildIdAndKeywordArgs, 'input'>>;
  updateReminder?: Resolver<Maybe<ResolversTypes['UpdateReminderPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReminderArgs, 'input'>>;
  updateReminderByUserIdAndSetAt?: Resolver<Maybe<ResolversTypes['UpdateReminderPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReminderByUserIdAndSetAtArgs, 'input'>>;
  updateRoleMenu?: Resolver<Maybe<ResolversTypes['UpdateRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleMenuArgs, 'input'>>;
  updateRoleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['UpdateRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleMenuByGuildIdAndMenuNameArgs, 'input'>>;
  updateRoleMenuRole?: Resolver<Maybe<ResolversTypes['UpdateRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleMenuRoleArgs, 'input'>>;
  updateRoleMenuRoleByGuildIdAndMenuNameAndRoleId?: Resolver<Maybe<ResolversTypes['UpdateRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs, 'input'>>;
  updateTag?: Resolver<Maybe<ResolversTypes['UpdateTagPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTagArgs, 'input'>>;
  updateTagByGuildIdAndTagName?: Resolver<Maybe<ResolversTypes['UpdateTagPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTagByGuildIdAndTagNameArgs, 'input'>>;
  updateUser?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserArgs, 'input'>>;
  updateUserById?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserByIdArgs, 'input'>>;
  updateUserLevel?: Resolver<Maybe<ResolversTypes['UpdateUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserLevelArgs, 'input'>>;
  updateUserLevelByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['UpdateUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserLevelByUserIdAndGuildIdArgs, 'input'>>;
  updateUserXp?: Resolver<Maybe<ResolversTypes['UpdateUserXpPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserXpArgs, 'input'>>;
  updateWebUser?: Resolver<Maybe<ResolversTypes['UpdateWebUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateWebUserArgs, 'input'>>;
  updateWebUserById?: Resolver<Maybe<ResolversTypes['UpdateWebUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateWebUserByIdArgs, 'input'>>;
  updateWebUserGuild?: Resolver<Maybe<ResolversTypes['UpdateWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpdateWebUserGuildArgs, 'input'>>;
  updateWebUserGuildByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['UpdateWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpdateWebUserGuildByUserIdAndGuildIdArgs, 'input'>>;
  updateXpBlock?: Resolver<Maybe<ResolversTypes['UpdateXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpdateXpBlockArgs, 'input'>>;
  updateXpBlockByGuildIdAndBlockId?: Resolver<Maybe<ResolversTypes['UpdateXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpdateXpBlockByGuildIdAndBlockIdArgs, 'input'>>;
  upsertBotStat?: Resolver<Maybe<ResolversTypes['UpsertBotStatPayload']>, ParentType, ContextType, RequireFields<MutationUpsertBotStatArgs, 'input'>>;
  upsertCachedGuild?: Resolver<Maybe<ResolversTypes['UpsertCachedGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpsertCachedGuildArgs, 'input'>>;
  upsertCachedUser?: Resolver<Maybe<ResolversTypes['UpsertCachedUserPayload']>, ParentType, ContextType, RequireFields<MutationUpsertCachedUserArgs, 'input'>>;
  upsertEmojiStickerStat?: Resolver<Maybe<ResolversTypes['UpsertEmojiStickerStatPayload']>, ParentType, ContextType, RequireFields<MutationUpsertEmojiStickerStatArgs, 'input'>>;
  upsertFeed?: Resolver<Maybe<ResolversTypes['UpsertFeedPayload']>, ParentType, ContextType, RequireFields<MutationUpsertFeedArgs, 'input'>>;
  upsertFeedItem?: Resolver<Maybe<ResolversTypes['UpsertFeedItemPayload']>, ParentType, ContextType, RequireFields<MutationUpsertFeedItemArgs, 'input'>>;
  upsertFeedSubscription?: Resolver<Maybe<ResolversTypes['UpsertFeedSubscriptionPayload']>, ParentType, ContextType, RequireFields<MutationUpsertFeedSubscriptionArgs, 'input'>>;
  upsertGuildBan?: Resolver<Maybe<ResolversTypes['UpsertGuildBanPayload']>, ParentType, ContextType, RequireFields<MutationUpsertGuildBanArgs, 'input'>>;
  upsertGuildConfig?: Resolver<Maybe<ResolversTypes['UpsertGuildConfigPayload']>, ParentType, ContextType, RequireFields<MutationUpsertGuildConfigArgs, 'input'>>;
  upsertLevelRole?: Resolver<Maybe<ResolversTypes['UpsertLevelRolePayload']>, ParentType, ContextType, RequireFields<MutationUpsertLevelRoleArgs, 'input'>>;
  upsertLevelRoleApplyJob?: Resolver<Maybe<ResolversTypes['UpsertLevelRoleApplyJobPayload']>, ParentType, ContextType, RequireFields<MutationUpsertLevelRoleApplyJobArgs, 'input'>>;
  upsertLevelRoleOverride?: Resolver<Maybe<ResolversTypes['UpsertLevelRoleOverridePayload']>, ParentType, ContextType, RequireFields<MutationUpsertLevelRoleOverrideArgs, 'input'>>;
  upsertMember?: Resolver<Maybe<ResolversTypes['UpsertMemberPayload']>, ParentType, ContextType, RequireFields<MutationUpsertMemberArgs, 'input'>>;
  upsertMessage?: Resolver<Maybe<ResolversTypes['UpsertMessagePayload']>, ParentType, ContextType, RequireFields<MutationUpsertMessageArgs, 'input'>>;
  upsertModLog?: Resolver<Maybe<ResolversTypes['UpsertModLogPayload']>, ParentType, ContextType, RequireFields<MutationUpsertModLogArgs, 'input'>>;
  upsertMsgLogBlock?: Resolver<Maybe<ResolversTypes['UpsertMsgLogBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpsertMsgLogBlockArgs, 'input'>>;
  upsertMute?: Resolver<Maybe<ResolversTypes['UpsertMutePayload']>, ParentType, ContextType, RequireFields<MutationUpsertMuteArgs, 'input'>>;
  upsertNotification?: Resolver<Maybe<ResolversTypes['UpsertNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpsertNotificationArgs, 'input'>>;
  upsertReminder?: Resolver<Maybe<ResolversTypes['UpsertReminderPayload']>, ParentType, ContextType, RequireFields<MutationUpsertReminderArgs, 'input'>>;
  upsertRoleMenu?: Resolver<Maybe<ResolversTypes['UpsertRoleMenuPayload']>, ParentType, ContextType, RequireFields<MutationUpsertRoleMenuArgs, 'input'>>;
  upsertRoleMenuRole?: Resolver<Maybe<ResolversTypes['UpsertRoleMenuRolePayload']>, ParentType, ContextType, RequireFields<MutationUpsertRoleMenuRoleArgs, 'input'>>;
  upsertTag?: Resolver<Maybe<ResolversTypes['UpsertTagPayload']>, ParentType, ContextType, RequireFields<MutationUpsertTagArgs, 'input'>>;
  upsertUser?: Resolver<Maybe<ResolversTypes['UpsertUserPayload']>, ParentType, ContextType, RequireFields<MutationUpsertUserArgs, 'input'>>;
  upsertUserLevel?: Resolver<Maybe<ResolversTypes['UpsertUserLevelPayload']>, ParentType, ContextType, RequireFields<MutationUpsertUserLevelArgs, 'input'>>;
  upsertWebUser?: Resolver<Maybe<ResolversTypes['UpsertWebUserPayload']>, ParentType, ContextType, RequireFields<MutationUpsertWebUserArgs, 'input'>>;
  upsertWebUserGuild?: Resolver<Maybe<ResolversTypes['UpsertWebUserGuildPayload']>, ParentType, ContextType, RequireFields<MutationUpsertWebUserGuildArgs, 'input'>>;
  upsertXpBlock?: Resolver<Maybe<ResolversTypes['UpsertXpBlockPayload']>, ParentType, ContextType, RequireFields<MutationUpsertXpBlockArgs, 'input'>>;
};

export type MuteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mute'] = ResolversParentTypes['Mute']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  endTime?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  pending?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startTime?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteAggregates'] = ResolversParentTypes['MuteAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['MuteAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['MuteDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['MuteMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['MuteMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['MuteStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['MuteStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['MuteSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['MuteVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['MuteVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteAverageAggregates'] = ResolversParentTypes['MuteAverageAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteDistinctCountAggregates'] = ResolversParentTypes['MuteDistinctCountAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  endTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  pending?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  startTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteMaxAggregates'] = ResolversParentTypes['MuteMaxAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteMinAggregates'] = ResolversParentTypes['MuteMinAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteStddevPopulationAggregates'] = ResolversParentTypes['MuteStddevPopulationAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteStddevSampleAggregates'] = ResolversParentTypes['MuteStddevSampleAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteSumAggregates'] = ResolversParentTypes['MuteSumAggregates']> = {
  caseId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteVariancePopulationAggregates'] = ResolversParentTypes['MuteVariancePopulationAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MuteVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['MuteVarianceSampleAggregates'] = ResolversParentTypes['MuteVarianceSampleAggregates']> = {
  caseId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutesConnection'] = ResolversParentTypes['MutesConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['MuteAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['MutesEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['MuteAggregates']>>, ParentType, ContextType, RequireFields<MutesConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Mute']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutesEdge'] = ResolversParentTypes['MutesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Mute'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'BotStat' | 'CachedGuild' | 'CachedUser' | 'EmojiStickerStat' | 'Feed' | 'FeedItem' | 'FeedSubscription' | 'GuildBan' | 'GuildConfig' | 'LevelRole' | 'LevelRoleApplyJob' | 'LevelRoleOverride' | 'Member' | 'Message' | 'ModLog' | 'MsgLogBlock' | 'Mute' | 'Notification' | 'Query' | 'Reminder' | 'RoleMenu' | 'RoleMenuRole' | 'Tag' | 'User' | 'UserLevel' | 'WebUser' | 'WebUserGuild' | 'XpBlock', ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type NotificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Notification'] = ResolversParentTypes['Notification']> = {
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  keyword?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationAggregates'] = ResolversParentTypes['NotificationAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['NotificationAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['NotificationDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['NotificationMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['NotificationMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['NotificationStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['NotificationStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['NotificationSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['NotificationVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['NotificationVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationAverageAggregates'] = ResolversParentTypes['NotificationAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationDistinctCountAggregates'] = ResolversParentTypes['NotificationDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  keyword?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationMaxAggregates'] = ResolversParentTypes['NotificationMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationMinAggregates'] = ResolversParentTypes['NotificationMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationStddevPopulationAggregates'] = ResolversParentTypes['NotificationStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationStddevSampleAggregates'] = ResolversParentTypes['NotificationStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationSumAggregates'] = ResolversParentTypes['NotificationSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationVariancePopulationAggregates'] = ResolversParentTypes['NotificationVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationVarianceSampleAggregates'] = ResolversParentTypes['NotificationVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsConnection'] = ResolversParentTypes['NotificationsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['NotificationAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['NotificationsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['NotificationAggregates']>>, ParentType, ContextType, RequireFields<NotificationsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Notification']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsEdge'] = ResolversParentTypes['NotificationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Notification'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsStartingWithConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsStartingWithConnection'] = ResolversParentTypes['NotificationsStartingWithConnection']> = {
  edges?: Resolver<Array<ResolversTypes['NotificationsStartingWithEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsStartingWithEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsStartingWithEdge'] = ResolversParentTypes['NotificationsStartingWithEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  allBotStats?: Resolver<Maybe<ResolversTypes['BotStatsConnection']>, ParentType, ContextType, RequireFields<QueryAllBotStatsArgs, 'orderBy'>>;
  allEmojiStickerStats?: Resolver<Maybe<ResolversTypes['EmojiStickerStatsConnection']>, ParentType, ContextType, RequireFields<QueryAllEmojiStickerStatsArgs, 'orderBy'>>;
  allFeedItems?: Resolver<Maybe<ResolversTypes['FeedItemsConnection']>, ParentType, ContextType, RequireFields<QueryAllFeedItemsArgs, 'orderBy'>>;
  allFeedSubscriptions?: Resolver<Maybe<ResolversTypes['FeedSubscriptionsConnection']>, ParentType, ContextType, RequireFields<QueryAllFeedSubscriptionsArgs, 'orderBy'>>;
  allFeeds?: Resolver<Maybe<ResolversTypes['FeedsConnection']>, ParentType, ContextType, RequireFields<QueryAllFeedsArgs, 'orderBy'>>;
  allGuildBans?: Resolver<Maybe<ResolversTypes['GuildBansConnection']>, ParentType, ContextType, RequireFields<QueryAllGuildBansArgs, 'orderBy'>>;
  allGuildConfigs?: Resolver<Maybe<ResolversTypes['GuildConfigsConnection']>, ParentType, ContextType, RequireFields<QueryAllGuildConfigsArgs, 'orderBy'>>;
  allLevelRoleApplyJobs?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobsConnection']>, ParentType, ContextType, RequireFields<QueryAllLevelRoleApplyJobsArgs, 'orderBy'>>;
  allLevelRoleOverrides?: Resolver<Maybe<ResolversTypes['LevelRoleOverridesConnection']>, ParentType, ContextType, RequireFields<QueryAllLevelRoleOverridesArgs, 'orderBy'>>;
  allLevelRoles?: Resolver<Maybe<ResolversTypes['LevelRolesConnection']>, ParentType, ContextType, RequireFields<QueryAllLevelRolesArgs, 'orderBy'>>;
  allMembers?: Resolver<Maybe<ResolversTypes['MembersConnection']>, ParentType, ContextType, RequireFields<QueryAllMembersArgs, 'orderBy'>>;
  allMessages?: Resolver<Maybe<ResolversTypes['MessagesConnection']>, ParentType, ContextType, RequireFields<QueryAllMessagesArgs, 'orderBy'>>;
  allModLogs?: Resolver<Maybe<ResolversTypes['ModLogsConnection']>, ParentType, ContextType, RequireFields<QueryAllModLogsArgs, 'orderBy'>>;
  allMsgLogBlocks?: Resolver<Maybe<ResolversTypes['MsgLogBlocksConnection']>, ParentType, ContextType, RequireFields<QueryAllMsgLogBlocksArgs, 'orderBy'>>;
  allMutes?: Resolver<Maybe<ResolversTypes['MutesConnection']>, ParentType, ContextType, RequireFields<QueryAllMutesArgs, 'orderBy'>>;
  allNotifications?: Resolver<Maybe<ResolversTypes['NotificationsConnection']>, ParentType, ContextType, RequireFields<QueryAllNotificationsArgs, 'orderBy'>>;
  allRedisGuildIds?: Resolver<Array<ResolversTypes['BigInt']>, ParentType, ContextType>;
  allReminders?: Resolver<Maybe<ResolversTypes['RemindersConnection']>, ParentType, ContextType, RequireFields<QueryAllRemindersArgs, 'orderBy'>>;
  allRoleMenuRoles?: Resolver<Maybe<ResolversTypes['RoleMenuRolesConnection']>, ParentType, ContextType, RequireFields<QueryAllRoleMenuRolesArgs, 'orderBy'>>;
  allRoleMenus?: Resolver<Maybe<ResolversTypes['RoleMenusConnection']>, ParentType, ContextType, RequireFields<QueryAllRoleMenusArgs, 'orderBy'>>;
  allTags?: Resolver<Maybe<ResolversTypes['TagsConnection']>, ParentType, ContextType, RequireFields<QueryAllTagsArgs, 'orderBy'>>;
  allUserLevels?: Resolver<Maybe<ResolversTypes['UserLevelsConnection']>, ParentType, ContextType, RequireFields<QueryAllUserLevelsArgs, 'orderBy'>>;
  allUsers?: Resolver<Maybe<ResolversTypes['UsersConnection']>, ParentType, ContextType, RequireFields<QueryAllUsersArgs, 'orderBy'>>;
  allWebUserGuilds?: Resolver<Maybe<ResolversTypes['WebUserGuildsConnection']>, ParentType, ContextType, RequireFields<QueryAllWebUserGuildsArgs, 'orderBy'>>;
  allWebUsers?: Resolver<Maybe<ResolversTypes['WebUsersConnection']>, ParentType, ContextType, RequireFields<QueryAllWebUsersArgs, 'orderBy'>>;
  allXpBlocks?: Resolver<Maybe<ResolversTypes['XpBlocksConnection']>, ParentType, ContextType, RequireFields<QueryAllXpBlocksArgs, 'orderBy'>>;
  botStat?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType, RequireFields<QueryBotStatArgs, 'nodeId'>>;
  botStatByNameAndCategory?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType, RequireFields<QueryBotStatByNameAndCategoryArgs, 'category' | 'name'>>;
  cachedGuild?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType, RequireFields<QueryCachedGuildArgs, 'nodeId'>>;
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType, RequireFields<QueryCachedGuildByIdArgs, 'id'>>;
  cachedUser?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType, RequireFields<QueryCachedUserArgs, 'nodeId'>>;
  cachedUserById?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType, RequireFields<QueryCachedUserByIdArgs, 'id'>>;
  currentSessionId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  currentUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  currentUserDiscordId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currentUserId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currentUserManagedGuildIds?: Resolver<Maybe<ResolversTypes['CurrentUserManagedGuildIdsConnection']>, ParentType, ContextType, Partial<QueryCurrentUserManagedGuildIdsArgs>>;
  emojiStickerStat?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType, RequireFields<QueryEmojiStickerStatArgs, 'nodeId'>>;
  emojiStickerStatByTimeAndGuildIdAndAssetIdAndActionType?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType, RequireFields<QueryEmojiStickerStatByTimeAndGuildIdAndAssetIdAndActionTypeArgs, 'actionType' | 'assetId' | 'guildId' | 'time'>>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType, RequireFields<QueryFeedArgs, 'nodeId'>>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType, RequireFields<QueryFeedByFeedIdArgs, 'feedId'>>;
  feedItem?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType, RequireFields<QueryFeedItemArgs, 'nodeId'>>;
  feedItemByFeedIdAndItemId?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType, RequireFields<QueryFeedItemByFeedIdAndItemIdArgs, 'feedId' | 'itemId'>>;
  feedSubscription?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType, RequireFields<QueryFeedSubscriptionArgs, 'nodeId'>>;
  feedSubscriptionByFeedIdAndChannelId?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType, RequireFields<QueryFeedSubscriptionByFeedIdAndChannelIdArgs, 'channelId' | 'feedId'>>;
  getEligibleLevelRoles?: Resolver<Maybe<ResolversTypes['EligibleLevelRolesConnection']>, ParentType, ContextType, Partial<QueryGetEligibleLevelRolesArgs>>;
  guildBan?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType, RequireFields<QueryGuildBanArgs, 'nodeId'>>;
  guildBanByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType, RequireFields<QueryGuildBanByGuildIdAndUserIdArgs, 'guildId' | 'userId'>>;
  guildConfig?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType, RequireFields<QueryGuildConfigArgs, 'nodeId'>>;
  guildConfigById?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType, RequireFields<QueryGuildConfigByIdArgs, 'id'>>;
  levelRole?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType, RequireFields<QueryLevelRoleArgs, 'nodeId'>>;
  levelRoleApplyJob?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType, RequireFields<QueryLevelRoleApplyJobArgs, 'nodeId'>>;
  levelRoleApplyJobByGuildId?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType, RequireFields<QueryLevelRoleApplyJobByGuildIdArgs, 'guildId'>>;
  levelRoleApplyJobByInteractionId?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType, RequireFields<QueryLevelRoleApplyJobByInteractionIdArgs, 'interactionId'>>;
  levelRoleByGuildIdAndRoleId?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType, RequireFields<QueryLevelRoleByGuildIdAndRoleIdArgs, 'guildId' | 'roleId'>>;
  levelRoleOverride?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType, RequireFields<QueryLevelRoleOverrideArgs, 'nodeId'>>;
  levelRoleOverrideByGuildIdAndRoleIdAndUserId?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType, RequireFields<QueryLevelRoleOverrideByGuildIdAndRoleIdAndUserIdArgs, 'guildId' | 'roleId' | 'userId'>>;
  member?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType, RequireFields<QueryMemberArgs, 'nodeId'>>;
  memberByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType, RequireFields<QueryMemberByGuildIdAndUserIdArgs, 'guildId' | 'userId'>>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType, RequireFields<QueryMessageArgs, 'nodeId'>>;
  messageByMessageId?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType, RequireFields<QueryMessageByMessageIdArgs, 'messageId'>>;
  modLog?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType, RequireFields<QueryModLogArgs, 'nodeId'>>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType, RequireFields<QueryModLogByGuildIdAndCaseIdArgs, 'caseId' | 'guildId'>>;
  msgLogBlock?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType, RequireFields<QueryMsgLogBlockArgs, 'nodeId'>>;
  msgLogBlockByGuildIdAndChannelId?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType, RequireFields<QueryMsgLogBlockByGuildIdAndChannelIdArgs, 'channelId' | 'guildId'>>;
  mute?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType, RequireFields<QueryMuteArgs, 'nodeId'>>;
  muteByGuildIdAndUserId?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType, RequireFields<QueryMuteByGuildIdAndUserIdArgs, 'guildId' | 'userId'>>;
  nextCaseId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QueryNextCaseIdArgs>>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'nodeId'>>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationArgs, 'nodeId'>>;
  notificationByUserIdAndGuildIdAndKeyword?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationByUserIdAndGuildIdAndKeywordArgs, 'guildId' | 'keyword' | 'userId'>>;
  notificationsStartingWith?: Resolver<Maybe<ResolversTypes['NotificationsStartingWithConnection']>, ParentType, ContextType, Partial<QueryNotificationsStartingWithArgs>>;
  query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  randomTag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType, Partial<QueryRandomTagArgs>>;
  redisGuildByGuildId?: Resolver<Maybe<ResolversTypes['RedisGuild']>, ParentType, ContextType, RequireFields<QueryRedisGuildByGuildIdArgs, 'guild_id'>>;
  reminder?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType, RequireFields<QueryReminderArgs, 'nodeId'>>;
  reminderByUserIdAndSetAt?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType, RequireFields<QueryReminderByUserIdAndSetAtArgs, 'setAt' | 'userId'>>;
  roleMenu?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType, RequireFields<QueryRoleMenuArgs, 'nodeId'>>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType, RequireFields<QueryRoleMenuByGuildIdAndMenuNameArgs, 'guildId' | 'menuName'>>;
  roleMenuRole?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType, RequireFields<QueryRoleMenuRoleArgs, 'nodeId'>>;
  roleMenuRoleByGuildIdAndMenuNameAndRoleId?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType, RequireFields<QueryRoleMenuRoleByGuildIdAndMenuNameAndRoleIdArgs, 'guildId' | 'menuName' | 'roleId'>>;
  searchModLogs?: Resolver<Maybe<ResolversTypes['ModLogsConnection']>, ParentType, ContextType, RequireFields<QuerySearchModLogsArgs, 'guildId' | 'searchCaseId'>>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType, RequireFields<QueryTagArgs, 'nodeId'>>;
  tagByGuildIdAndTagName?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType, RequireFields<QueryTagByGuildIdAndTagNameArgs, 'guildId' | 'tagName'>>;
  timeframeUserLevels?: Resolver<Maybe<ResolversTypes['TimeframeUserLevelsConnection']>, ParentType, ContextType, Partial<QueryTimeframeUserLevelsArgs>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'nodeId'>>;
  userById?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserByIdArgs, 'id'>>;
  userGuildRank?: Resolver<Maybe<ResolversTypes['UserGuildRankResult']>, ParentType, ContextType, RequireFields<QueryUserGuildRankArgs, 'guildId' | 'userId'>>;
  userLevel?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType, RequireFields<QueryUserLevelArgs, 'nodeId'>>;
  userLevelByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType, RequireFields<QueryUserLevelByUserIdAndGuildIdArgs, 'guildId' | 'userId'>>;
  webUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType, RequireFields<QueryWebUserArgs, 'nodeId'>>;
  webUserById?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType, RequireFields<QueryWebUserByIdArgs, 'id'>>;
  webUserGuild?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType, RequireFields<QueryWebUserGuildArgs, 'nodeId'>>;
  webUserGuildByUserIdAndGuildId?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType, RequireFields<QueryWebUserGuildByUserIdAndGuildIdArgs, 'guildId' | 'userId'>>;
  xpBlock?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType, RequireFields<QueryXpBlockArgs, 'nodeId'>>;
  xpBlockByGuildIdAndBlockId?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType, RequireFields<QueryXpBlockByGuildIdAndBlockIdArgs, 'blockId' | 'guildId'>>;
};

export type RedisGuildResolvers<ContextType = any, ParentType extends ResolversParentTypes['RedisGuild'] = ResolversParentTypes['RedisGuild']> = {
  afkChannelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  afkTimeout?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  banner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  defaultMessageNotifications?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discoverySplash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojis?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  explicitContentFilter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  features?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  joinedAt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  large?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  maxMembers?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maxVideoChannelUsers?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  memberCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  members?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  mfaLevel?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nsfwLevel?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preferredLocale?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  premiumSubscriptionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  premiumTier?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  presences?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['RedisGuildRole']>, ParentType, ContextType>;
  rulesChannelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  splash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  systemChannelFlags?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  systemChannelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unavailable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  vanityUrlCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verificationLevel?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  voiceStates?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RedisGuildRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['RedisGuildRole'] = ResolversParentTypes['RedisGuildRole']> = {
  color?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hoist?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  managed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mentionable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  tags?: Resolver<Maybe<ResolversTypes['RedisRoleTags']>, ParentType, ContextType>;
  unicode_emoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RedisRoleTagsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RedisRoleTags'] = ResolversParentTypes['RedisRoleTags']> = {
  bot_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  integration_id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Reminder'] = ResolversParentTypes['Reminder']> = {
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expireAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  setAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderAggregates'] = ResolversParentTypes['ReminderAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['ReminderAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['ReminderDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['ReminderMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['ReminderMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['ReminderStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['ReminderStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['ReminderSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['ReminderVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['ReminderVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderAverageAggregates'] = ResolversParentTypes['ReminderAverageAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderDistinctCountAggregates'] = ResolversParentTypes['ReminderDistinctCountAggregates']> = {
  description?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  expireAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  setAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderMaxAggregates'] = ResolversParentTypes['ReminderMaxAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderMinAggregates'] = ResolversParentTypes['ReminderMinAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderStddevPopulationAggregates'] = ResolversParentTypes['ReminderStddevPopulationAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderStddevSampleAggregates'] = ResolversParentTypes['ReminderStddevSampleAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderSumAggregates'] = ResolversParentTypes['ReminderSumAggregates']> = {
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderVariancePopulationAggregates'] = ResolversParentTypes['ReminderVariancePopulationAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReminderVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReminderVarianceSampleAggregates'] = ResolversParentTypes['ReminderVarianceSampleAggregates']> = {
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemindersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemindersConnection'] = ResolversParentTypes['RemindersConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['ReminderAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RemindersEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['ReminderAggregates']>>, ParentType, ContextType, RequireFields<RemindersConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Reminder']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemindersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemindersEdge'] = ResolversParentTypes['RemindersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Reminder'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenu'] = ResolversParentTypes['RoleMenu']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  menuName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleMenuRolesByGuildIdAndMenuName?: Resolver<ResolversTypes['RoleMenuRolesConnection'], ParentType, ContextType, RequireFields<RoleMenuRoleMenuRolesByGuildIdAndMenuNameArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuAggregates'] = ResolversParentTypes['RoleMenuAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['RoleMenuAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['RoleMenuDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['RoleMenuMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['RoleMenuMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['RoleMenuStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['RoleMenuStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['RoleMenuSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['RoleMenuVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['RoleMenuVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuAverageAggregates'] = ResolversParentTypes['RoleMenuAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuDistinctCountAggregates'] = ResolversParentTypes['RoleMenuDistinctCountAggregates']> = {
  description?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  menuName?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuMaxAggregates'] = ResolversParentTypes['RoleMenuMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuMinAggregates'] = ResolversParentTypes['RoleMenuMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRole'] = ResolversParentTypes['RoleMenuRole']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  menuName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleAggregates'] = ResolversParentTypes['RoleMenuRoleAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['RoleMenuRoleAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['RoleMenuRoleDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['RoleMenuRoleMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['RoleMenuRoleMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['RoleMenuRoleStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['RoleMenuRoleStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['RoleMenuRoleSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['RoleMenuRoleVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['RoleMenuRoleVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleAverageAggregates'] = ResolversParentTypes['RoleMenuRoleAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleDistinctCountAggregates'] = ResolversParentTypes['RoleMenuRoleDistinctCountAggregates']> = {
  description?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  emoji?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  menuName?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleMaxAggregates'] = ResolversParentTypes['RoleMenuRoleMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleMinAggregates'] = ResolversParentTypes['RoleMenuRoleMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleStddevPopulationAggregates'] = ResolversParentTypes['RoleMenuRoleStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleStddevSampleAggregates'] = ResolversParentTypes['RoleMenuRoleStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleSumAggregates'] = ResolversParentTypes['RoleMenuRoleSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  position?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  roleId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleVariancePopulationAggregates'] = ResolversParentTypes['RoleMenuRoleVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRoleVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRoleVarianceSampleAggregates'] = ResolversParentTypes['RoleMenuRoleVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  roleId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRolesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRolesConnection'] = ResolversParentTypes['RoleMenuRolesConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['RoleMenuRoleAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RoleMenuRolesEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['RoleMenuRoleAggregates']>>, ParentType, ContextType, RequireFields<RoleMenuRolesConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['RoleMenuRole']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuRolesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuRolesEdge'] = ResolversParentTypes['RoleMenuRolesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['RoleMenuRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuStddevPopulationAggregates'] = ResolversParentTypes['RoleMenuStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuStddevSampleAggregates'] = ResolversParentTypes['RoleMenuStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuSumAggregates'] = ResolversParentTypes['RoleMenuSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  maxCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  requiredRole?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuVariancePopulationAggregates'] = ResolversParentTypes['RoleMenuVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenuVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenuVarianceSampleAggregates'] = ResolversParentTypes['RoleMenuVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  maxCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  requiredRole?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenusConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenusConnection'] = ResolversParentTypes['RoleMenusConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['RoleMenuAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['RoleMenusEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['RoleMenuAggregates']>>, ParentType, ContextType, RequireFields<RoleMenusConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleMenusEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleMenusEdge'] = ResolversParentTypes['RoleMenusEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['RoleMenu'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetRoleMenuRoleOrderPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetRoleMenuRoleOrderPayload'] = ResolversParentTypes['SetRoleMenuRoleOrderPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuRoles?: Resolver<Maybe<Array<ResolversTypes['RoleMenuRole']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagResolvers<ContextType = any, ParentType extends ResolversParentTypes['Tag'] = ResolversParentTypes['Tag']> = {
  attachment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  content?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  tagName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  useCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagAggregates'] = ResolversParentTypes['TagAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['TagAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['TagDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['TagMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['TagMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['TagStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['TagStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['TagSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['TagVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['TagVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagAverageAggregates'] = ResolversParentTypes['TagAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagDistinctCountAggregates'] = ResolversParentTypes['TagDistinctCountAggregates']> = {
  attachment?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  tagName?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagMaxAggregates'] = ResolversParentTypes['TagMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagMinAggregates'] = ResolversParentTypes['TagMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagStddevPopulationAggregates'] = ResolversParentTypes['TagStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagStddevSampleAggregates'] = ResolversParentTypes['TagStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagSumAggregates'] = ResolversParentTypes['TagSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  ownerId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  useCount?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagVariancePopulationAggregates'] = ResolversParentTypes['TagVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagVarianceSampleAggregates'] = ResolversParentTypes['TagVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  ownerId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  useCount?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagsConnection'] = ResolversParentTypes['TagsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['TagAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TagsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['TagAggregates']>>, ParentType, ContextType, RequireFields<TagsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['Tag']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagsEdge'] = ResolversParentTypes['TagsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Tag'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeframeUserLevelEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeframeUserLevelEdge'] = ResolversParentTypes['TimeframeUserLevelEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['TimeframeUserLevelsRecord'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeframeUserLevelsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeframeUserLevelsConnection'] = ResolversParentTypes['TimeframeUserLevelsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TimeframeUserLevelEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['TimeframeUserLevelsRecord']>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeframeUserLevelsRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeframeUserLevelsRecord'] = ResolversParentTypes['TimeframeUserLevelsRecord']> = {
  avatarUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currentLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  discriminator?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  gainedLevels?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nextLevelXpProgress?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nextLevelXpRequired?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  xp?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  xpDiff?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UuidScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UUID'], any> {
  name: 'UUID';
}

export type UpdateBotStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateBotStatPayload'] = ResolversParentTypes['UpdateBotStatPayload']> = {
  botStat?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType>;
  botStatEdge?: Resolver<Maybe<ResolversTypes['BotStatsEdge']>, ParentType, ContextType, RequireFields<UpdateBotStatPayloadBotStatEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCachedGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCachedGuildPayload'] = ResolversParentTypes['UpdateCachedGuildPayload']> = {
  cachedGuild?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  cachedGuildEdge?: Resolver<Maybe<ResolversTypes['CachedGuildsEdge']>, ParentType, ContextType, RequireFields<UpdateCachedGuildPayloadCachedGuildEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCachedUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCachedUserPayload'] = ResolversParentTypes['UpdateCachedUserPayload']> = {
  cachedUser?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType>;
  cachedUserEdge?: Resolver<Maybe<ResolversTypes['CachedUsersEdge']>, ParentType, ContextType, RequireFields<UpdateCachedUserPayloadCachedUserEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateEmojiStickerStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateEmojiStickerStatPayload'] = ResolversParentTypes['UpdateEmojiStickerStatPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiStickerStat?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType>;
  emojiStickerStatEdge?: Resolver<Maybe<ResolversTypes['EmojiStickerStatsEdge']>, ParentType, ContextType, RequireFields<UpdateEmojiStickerStatPayloadEmojiStickerStatEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFeedItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFeedItemPayload'] = ResolversParentTypes['UpdateFeedItemPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedItem?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType>;
  feedItemEdge?: Resolver<Maybe<ResolversTypes['FeedItemsEdge']>, ParentType, ContextType, RequireFields<UpdateFeedItemPayloadFeedItemEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFeedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFeedPayload'] = ResolversParentTypes['UpdateFeedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedEdge?: Resolver<Maybe<ResolversTypes['FeedsEdge']>, ParentType, ContextType, RequireFields<UpdateFeedPayloadFeedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFeedSubscriptionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFeedSubscriptionPayload'] = ResolversParentTypes['UpdateFeedSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedSubscription?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType>;
  feedSubscriptionEdge?: Resolver<Maybe<ResolversTypes['FeedSubscriptionsEdge']>, ParentType, ContextType, RequireFields<UpdateFeedSubscriptionPayloadFeedSubscriptionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateGuildBanPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateGuildBanPayload'] = ResolversParentTypes['UpdateGuildBanPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildBan?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType>;
  guildBanEdge?: Resolver<Maybe<ResolversTypes['GuildBansEdge']>, ParentType, ContextType, RequireFields<UpdateGuildBanPayloadGuildBanEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateGuildConfigPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateGuildConfigPayload'] = ResolversParentTypes['UpdateGuildConfigPayload']> = {
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildConfig?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  guildConfigEdge?: Resolver<Maybe<ResolversTypes['GuildConfigsEdge']>, ParentType, ContextType, RequireFields<UpdateGuildConfigPayloadGuildConfigEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateLevelRoleApplyJobPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateLevelRoleApplyJobPayload'] = ResolversParentTypes['UpdateLevelRoleApplyJobPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleApplyJob?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType>;
  levelRoleApplyJobEdge?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobsEdge']>, ParentType, ContextType, RequireFields<UpdateLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateLevelRoleOverridePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateLevelRoleOverridePayload'] = ResolversParentTypes['UpdateLevelRoleOverridePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleOverride?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType>;
  levelRoleOverrideEdge?: Resolver<Maybe<ResolversTypes['LevelRoleOverridesEdge']>, ParentType, ContextType, RequireFields<UpdateLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateLevelRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateLevelRolePayload'] = ResolversParentTypes['UpdateLevelRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRole?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType>;
  levelRoleEdge?: Resolver<Maybe<ResolversTypes['LevelRolesEdge']>, ParentType, ContextType, RequireFields<UpdateLevelRolePayloadLevelRoleEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateMemberPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateMemberPayload'] = ResolversParentTypes['UpdateMemberPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  member?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType>;
  memberEdge?: Resolver<Maybe<ResolversTypes['MembersEdge']>, ParentType, ContextType, RequireFields<UpdateMemberPayloadMemberEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateMessagePayload'] = ResolversParentTypes['UpdateMessagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<UpdateMessagePayloadMessageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateModLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateModLogPayload'] = ResolversParentTypes['UpdateModLogPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLog?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  modLogEdge?: Resolver<Maybe<ResolversTypes['ModLogsEdge']>, ParentType, ContextType, RequireFields<UpdateModLogPayloadModLogEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateMsgLogBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateMsgLogBlockPayload'] = ResolversParentTypes['UpdateMsgLogBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  msgLogBlock?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType>;
  msgLogBlockEdge?: Resolver<Maybe<ResolversTypes['MsgLogBlocksEdge']>, ParentType, ContextType, RequireFields<UpdateMsgLogBlockPayloadMsgLogBlockEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateMutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateMutePayload'] = ResolversParentTypes['UpdateMutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  mute?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType>;
  muteEdge?: Resolver<Maybe<ResolversTypes['MutesEdge']>, ParentType, ContextType, RequireFields<UpdateMutePayloadMuteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateNotificationPayload'] = ResolversParentTypes['UpdateNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<UpdateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReminderPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReminderPayload'] = ResolversParentTypes['UpdateReminderPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reminder?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType>;
  reminderEdge?: Resolver<Maybe<ResolversTypes['RemindersEdge']>, ParentType, ContextType, RequireFields<UpdateReminderPayloadReminderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRoleMenuPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateRoleMenuPayload'] = ResolversParentTypes['UpdateRoleMenuPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenu?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuEdge?: Resolver<Maybe<ResolversTypes['RoleMenusEdge']>, ParentType, ContextType, RequireFields<UpdateRoleMenuPayloadRoleMenuEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRoleMenuRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateRoleMenuRolePayload'] = ResolversParentTypes['UpdateRoleMenuRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuRole?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType>;
  roleMenuRoleEdge?: Resolver<Maybe<ResolversTypes['RoleMenuRolesEdge']>, ParentType, ContextType, RequireFields<UpdateRoleMenuRolePayloadRoleMenuRoleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTagPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTagPayload'] = ResolversParentTypes['UpdateTagPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<UpdateTagPayloadTagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserLevelPayload'] = ResolversParentTypes['UpdateUserLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userLevel?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType>;
  userLevelEdge?: Resolver<Maybe<ResolversTypes['UserLevelsEdge']>, ParentType, ContextType, RequireFields<UpdateUserLevelPayloadUserLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserPayload'] = ResolversParentTypes['UpdateUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<UpdateUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserXpPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserXpPayload'] = ResolversParentTypes['UpdateUserXpPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userXpUpdateResult?: Resolver<Maybe<ResolversTypes['UserXpUpdateResult']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateWebUserGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateWebUserGuildPayload'] = ResolversParentTypes['UpdateWebUserGuildPayload']> = {
  cachedGuildByGuildId?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUserByUserId?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserGuild?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType>;
  webUserGuildEdge?: Resolver<Maybe<ResolversTypes['WebUserGuildsEdge']>, ParentType, ContextType, RequireFields<UpdateWebUserGuildPayloadWebUserGuildEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateWebUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateWebUserPayload'] = ResolversParentTypes['UpdateWebUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserEdge?: Resolver<Maybe<ResolversTypes['WebUsersEdge']>, ParentType, ContextType, RequireFields<UpdateWebUserPayloadWebUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateXpBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateXpBlockPayload'] = ResolversParentTypes['UpdateXpBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  xpBlock?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType>;
  xpBlockEdge?: Resolver<Maybe<ResolversTypes['XpBlocksEdge']>, ParentType, ContextType, RequireFields<UpdateXpBlockPayloadXpBlockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertBotStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertBotStatPayload'] = ResolversParentTypes['UpsertBotStatPayload']> = {
  botStat?: Resolver<Maybe<ResolversTypes['BotStat']>, ParentType, ContextType>;
  botStatEdge?: Resolver<Maybe<ResolversTypes['BotStatsEdge']>, ParentType, ContextType, RequireFields<UpsertBotStatPayloadBotStatEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertCachedGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertCachedGuildPayload'] = ResolversParentTypes['UpsertCachedGuildPayload']> = {
  cachedGuild?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  cachedGuildEdge?: Resolver<Maybe<ResolversTypes['CachedGuildsEdge']>, ParentType, ContextType, RequireFields<UpsertCachedGuildPayloadCachedGuildEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertCachedUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertCachedUserPayload'] = ResolversParentTypes['UpsertCachedUserPayload']> = {
  cachedUser?: Resolver<Maybe<ResolversTypes['CachedUser']>, ParentType, ContextType>;
  cachedUserEdge?: Resolver<Maybe<ResolversTypes['CachedUsersEdge']>, ParentType, ContextType, RequireFields<UpsertCachedUserPayloadCachedUserEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertEmojiStickerStatPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertEmojiStickerStatPayload'] = ResolversParentTypes['UpsertEmojiStickerStatPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emojiStickerStat?: Resolver<Maybe<ResolversTypes['EmojiStickerStat']>, ParentType, ContextType>;
  emojiStickerStatEdge?: Resolver<Maybe<ResolversTypes['EmojiStickerStatsEdge']>, ParentType, ContextType, RequireFields<UpsertEmojiStickerStatPayloadEmojiStickerStatEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertFeedItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertFeedItemPayload'] = ResolversParentTypes['UpsertFeedItemPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedItem?: Resolver<Maybe<ResolversTypes['FeedItem']>, ParentType, ContextType>;
  feedItemEdge?: Resolver<Maybe<ResolversTypes['FeedItemsEdge']>, ParentType, ContextType, RequireFields<UpsertFeedItemPayloadFeedItemEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertFeedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertFeedPayload'] = ResolversParentTypes['UpsertFeedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feed?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedEdge?: Resolver<Maybe<ResolversTypes['FeedsEdge']>, ParentType, ContextType, RequireFields<UpsertFeedPayloadFeedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertFeedSubscriptionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertFeedSubscriptionPayload'] = ResolversParentTypes['UpsertFeedSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  feedByFeedId?: Resolver<Maybe<ResolversTypes['Feed']>, ParentType, ContextType>;
  feedSubscription?: Resolver<Maybe<ResolversTypes['FeedSubscription']>, ParentType, ContextType>;
  feedSubscriptionEdge?: Resolver<Maybe<ResolversTypes['FeedSubscriptionsEdge']>, ParentType, ContextType, RequireFields<UpsertFeedSubscriptionPayloadFeedSubscriptionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertGuildBanPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertGuildBanPayload'] = ResolversParentTypes['UpsertGuildBanPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildBan?: Resolver<Maybe<ResolversTypes['GuildBan']>, ParentType, ContextType>;
  guildBanEdge?: Resolver<Maybe<ResolversTypes['GuildBansEdge']>, ParentType, ContextType, RequireFields<UpsertGuildBanPayloadGuildBanEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertGuildConfigPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertGuildConfigPayload'] = ResolversParentTypes['UpsertGuildConfigPayload']> = {
  cachedGuildById?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  guildConfig?: Resolver<Maybe<ResolversTypes['GuildConfig']>, ParentType, ContextType>;
  guildConfigEdge?: Resolver<Maybe<ResolversTypes['GuildConfigsEdge']>, ParentType, ContextType, RequireFields<UpsertGuildConfigPayloadGuildConfigEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertLevelRoleApplyJobPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertLevelRoleApplyJobPayload'] = ResolversParentTypes['UpsertLevelRoleApplyJobPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleApplyJob?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJob']>, ParentType, ContextType>;
  levelRoleApplyJobEdge?: Resolver<Maybe<ResolversTypes['LevelRoleApplyJobsEdge']>, ParentType, ContextType, RequireFields<UpsertLevelRoleApplyJobPayloadLevelRoleApplyJobEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertLevelRoleOverridePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertLevelRoleOverridePayload'] = ResolversParentTypes['UpsertLevelRoleOverridePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRoleOverride?: Resolver<Maybe<ResolversTypes['LevelRoleOverride']>, ParentType, ContextType>;
  levelRoleOverrideEdge?: Resolver<Maybe<ResolversTypes['LevelRoleOverridesEdge']>, ParentType, ContextType, RequireFields<UpsertLevelRoleOverridePayloadLevelRoleOverrideEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertLevelRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertLevelRolePayload'] = ResolversParentTypes['UpsertLevelRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  levelRole?: Resolver<Maybe<ResolversTypes['LevelRole']>, ParentType, ContextType>;
  levelRoleEdge?: Resolver<Maybe<ResolversTypes['LevelRolesEdge']>, ParentType, ContextType, RequireFields<UpsertLevelRolePayloadLevelRoleEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertMemberPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertMemberPayload'] = ResolversParentTypes['UpsertMemberPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  member?: Resolver<Maybe<ResolversTypes['Member']>, ParentType, ContextType>;
  memberEdge?: Resolver<Maybe<ResolversTypes['MembersEdge']>, ParentType, ContextType, RequireFields<UpsertMemberPayloadMemberEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertMessagePayload'] = ResolversParentTypes['UpsertMessagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType>;
  messageEdge?: Resolver<Maybe<ResolversTypes['MessagesEdge']>, ParentType, ContextType, RequireFields<UpsertMessagePayloadMessageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertModLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertModLogPayload'] = ResolversParentTypes['UpsertModLogPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLog?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  modLogEdge?: Resolver<Maybe<ResolversTypes['ModLogsEdge']>, ParentType, ContextType, RequireFields<UpsertModLogPayloadModLogEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertMsgLogBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertMsgLogBlockPayload'] = ResolversParentTypes['UpsertMsgLogBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  msgLogBlock?: Resolver<Maybe<ResolversTypes['MsgLogBlock']>, ParentType, ContextType>;
  msgLogBlockEdge?: Resolver<Maybe<ResolversTypes['MsgLogBlocksEdge']>, ParentType, ContextType, RequireFields<UpsertMsgLogBlockPayloadMsgLogBlockEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertMutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertMutePayload'] = ResolversParentTypes['UpsertMutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  modLogByGuildIdAndCaseId?: Resolver<Maybe<ResolversTypes['ModLog']>, ParentType, ContextType>;
  mute?: Resolver<Maybe<ResolversTypes['Mute']>, ParentType, ContextType>;
  muteEdge?: Resolver<Maybe<ResolversTypes['MutesEdge']>, ParentType, ContextType, RequireFields<UpsertMutePayloadMuteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertNotificationPayload'] = ResolversParentTypes['UpsertNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<UpsertNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertReminderPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertReminderPayload'] = ResolversParentTypes['UpsertReminderPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reminder?: Resolver<Maybe<ResolversTypes['Reminder']>, ParentType, ContextType>;
  reminderEdge?: Resolver<Maybe<ResolversTypes['RemindersEdge']>, ParentType, ContextType, RequireFields<UpsertReminderPayloadReminderEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertRoleMenuPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertRoleMenuPayload'] = ResolversParentTypes['UpsertRoleMenuPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenu?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuEdge?: Resolver<Maybe<ResolversTypes['RoleMenusEdge']>, ParentType, ContextType, RequireFields<UpsertRoleMenuPayloadRoleMenuEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertRoleMenuRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertRoleMenuRolePayload'] = ResolversParentTypes['UpsertRoleMenuRolePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  roleMenuByGuildIdAndMenuName?: Resolver<Maybe<ResolversTypes['RoleMenu']>, ParentType, ContextType>;
  roleMenuRole?: Resolver<Maybe<ResolversTypes['RoleMenuRole']>, ParentType, ContextType>;
  roleMenuRoleEdge?: Resolver<Maybe<ResolversTypes['RoleMenuRolesEdge']>, ParentType, ContextType, RequireFields<UpsertRoleMenuRolePayloadRoleMenuRoleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertTagPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertTagPayload'] = ResolversParentTypes['UpsertTagPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  tag?: Resolver<Maybe<ResolversTypes['Tag']>, ParentType, ContextType>;
  tagEdge?: Resolver<Maybe<ResolversTypes['TagsEdge']>, ParentType, ContextType, RequireFields<UpsertTagPayloadTagEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertUserLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertUserLevelPayload'] = ResolversParentTypes['UpsertUserLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userLevel?: Resolver<Maybe<ResolversTypes['UserLevel']>, ParentType, ContextType>;
  userLevelEdge?: Resolver<Maybe<ResolversTypes['UserLevelsEdge']>, ParentType, ContextType, RequireFields<UpsertUserLevelPayloadUserLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertUserPayload'] = ResolversParentTypes['UpsertUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<UpsertUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertWebUserGuildPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertWebUserGuildPayload'] = ResolversParentTypes['UpsertWebUserGuildPayload']> = {
  cachedGuildByGuildId?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUserByUserId?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserGuild?: Resolver<Maybe<ResolversTypes['WebUserGuild']>, ParentType, ContextType>;
  webUserGuildEdge?: Resolver<Maybe<ResolversTypes['WebUserGuildsEdge']>, ParentType, ContextType, RequireFields<UpsertWebUserGuildPayloadWebUserGuildEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertWebUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertWebUserPayload'] = ResolversParentTypes['UpsertWebUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  webUser?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  webUserEdge?: Resolver<Maybe<ResolversTypes['WebUsersEdge']>, ParentType, ContextType, RequireFields<UpsertWebUserPayloadWebUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpsertXpBlockPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertXpBlockPayload'] = ResolversParentTypes['UpsertXpBlockPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  xpBlock?: Resolver<Maybe<ResolversTypes['XpBlock']>, ParentType, ContextType>;
  xpBlockEdge?: Resolver<Maybe<ResolversTypes['XpBlocksEdge']>, ParentType, ContextType, RequireFields<UpsertXpBlockPayloadXpBlockEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  fishies?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  isPatron?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastFishies?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  lastRep?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  lastfmUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  patronEmoji?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  profileData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  rep?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAggregates'] = ResolversParentTypes['UserAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['UserAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['UserDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['UserMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['UserMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['UserStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['UserStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['UserSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['UserVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['UserVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAverageAggregates'] = ResolversParentTypes['UserAverageAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserDistinctCountAggregates'] = ResolversParentTypes['UserDistinctCountAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  isPatron?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastFishies?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastRep?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastfmUsername?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  patronEmoji?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  profileData?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGuildRankResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGuildRankResult'] = ResolversParentTypes['UserGuildRankResult']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastMsg?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgAllTimeRank?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgAllTimeTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDayRank?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDayTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonthRank?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonthTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeekRank?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeekTotal?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevel'] = ResolversParentTypes['UserLevel']> = {
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  lastMsg?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgAllTime?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgDay?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgMonth?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  msgWeek?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelAggregates'] = ResolversParentTypes['UserLevelAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['UserLevelAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['UserLevelDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['UserLevelMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['UserLevelMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['UserLevelStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['UserLevelStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['UserLevelSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['UserLevelVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['UserLevelVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelAverageAggregates'] = ResolversParentTypes['UserLevelAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelDistinctCountAggregates'] = ResolversParentTypes['UserLevelDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastMsg?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelMaxAggregates'] = ResolversParentTypes['UserLevelMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelMinAggregates'] = ResolversParentTypes['UserLevelMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelStddevPopulationAggregates'] = ResolversParentTypes['UserLevelStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelStddevSampleAggregates'] = ResolversParentTypes['UserLevelStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelSumAggregates'] = ResolversParentTypes['UserLevelSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  msgAllTime?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  msgDay?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  msgMonth?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  msgWeek?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelVariancePopulationAggregates'] = ResolversParentTypes['UserLevelVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelVarianceSampleAggregates'] = ResolversParentTypes['UserLevelVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgAllTime?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgDay?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgMonth?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  msgWeek?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelsConnection'] = ResolversParentTypes['UserLevelsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['UserLevelAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UserLevelsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['UserLevelAggregates']>>, ParentType, ContextType, RequireFields<UserLevelsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['UserLevel']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserLevelsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserLevelsEdge'] = ResolversParentTypes['UserLevelsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserLevel'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserMaxAggregates'] = ResolversParentTypes['UserMaxAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserMinAggregates'] = ResolversParentTypes['UserMinAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserStddevPopulationAggregates'] = ResolversParentTypes['UserStddevPopulationAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserStddevSampleAggregates'] = ResolversParentTypes['UserStddevSampleAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSumAggregates'] = ResolversParentTypes['UserSumAggregates']> = {
  fishies?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  rep?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserVariancePopulationAggregates'] = ResolversParentTypes['UserVariancePopulationAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserVarianceSampleAggregates'] = ResolversParentTypes['UserVarianceSampleAggregates']> = {
  fishies?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  rep?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserXpUpdateResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserXpUpdateResult'] = ResolversParentTypes['UserXpUpdateResult']> = {
  addRoleIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['BigInt']>>>, ParentType, ContextType>;
  newLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  oldLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  removeRoleIds?: Resolver<Maybe<Array<Maybe<ResolversTypes['BigInt']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersConnection'] = ResolversParentTypes['UsersConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['UserAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UsersEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['UserAggregates']>>, ParentType, ContextType, RequireFields<UsersConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersEdge'] = ResolversParentTypes['UsersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUser'] = ResolversParentTypes['WebUser']> = {
  avatar?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  details?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  discriminator?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  isAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  webUserGuildsByUserId?: Resolver<ResolversTypes['WebUserGuildsConnection'], ParentType, ContextType, RequireFields<WebUserWebUserGuildsByUserIdArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserAggregates'] = ResolversParentTypes['WebUserAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['WebUserAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['WebUserDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['WebUserMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['WebUserMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['WebUserStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['WebUserStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['WebUserSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['WebUserVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['WebUserVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserAverageAggregates'] = ResolversParentTypes['WebUserAverageAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserDistinctCountAggregates'] = ResolversParentTypes['WebUserDistinctCountAggregates']> = {
  avatar?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  details?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  discriminator?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  isAdmin?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuild'] = ResolversParentTypes['WebUserGuild']> = {
  cachedGuildByGuildId?: Resolver<Maybe<ResolversTypes['CachedGuild']>, ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  manageGuild?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  webUserByUserId?: Resolver<Maybe<ResolversTypes['WebUser']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildAggregates'] = ResolversParentTypes['WebUserGuildAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['WebUserGuildAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['WebUserGuildDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['WebUserGuildMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['WebUserGuildMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['WebUserGuildStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['WebUserGuildStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['WebUserGuildSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['WebUserGuildVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['WebUserGuildVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildAverageAggregates'] = ResolversParentTypes['WebUserGuildAverageAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildDistinctCountAggregates'] = ResolversParentTypes['WebUserGuildDistinctCountAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  manageGuild?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildMaxAggregates'] = ResolversParentTypes['WebUserGuildMaxAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildMinAggregates'] = ResolversParentTypes['WebUserGuildMinAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildStddevPopulationAggregates'] = ResolversParentTypes['WebUserGuildStddevPopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildStddevSampleAggregates'] = ResolversParentTypes['WebUserGuildStddevSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildSumAggregates'] = ResolversParentTypes['WebUserGuildSumAggregates']> = {
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildVariancePopulationAggregates'] = ResolversParentTypes['WebUserGuildVariancePopulationAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildVarianceSampleAggregates'] = ResolversParentTypes['WebUserGuildVarianceSampleAggregates']> = {
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildsConnection'] = ResolversParentTypes['WebUserGuildsConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['WebUserGuildAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WebUserGuildsEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['WebUserGuildAggregates']>>, ParentType, ContextType, RequireFields<WebUserGuildsConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['WebUserGuild']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserGuildsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserGuildsEdge'] = ResolversParentTypes['WebUserGuildsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['WebUserGuild'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserMaxAggregates'] = ResolversParentTypes['WebUserMaxAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserMinAggregates'] = ResolversParentTypes['WebUserMinAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserStddevPopulationAggregates'] = ResolversParentTypes['WebUserStddevPopulationAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserStddevSampleAggregates'] = ResolversParentTypes['WebUserStddevSampleAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserSumAggregates'] = ResolversParentTypes['WebUserSumAggregates']> = {
  discriminator?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserVariancePopulationAggregates'] = ResolversParentTypes['WebUserVariancePopulationAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUserVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUserVarianceSampleAggregates'] = ResolversParentTypes['WebUserVarianceSampleAggregates']> = {
  discriminator?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUsersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUsersConnection'] = ResolversParentTypes['WebUsersConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['WebUserAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['WebUsersEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['WebUserAggregates']>>, ParentType, ContextType, RequireFields<WebUsersConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['WebUser']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebUsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebUsersEdge'] = ResolversParentTypes['WebUsersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['WebUser'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlock'] = ResolversParentTypes['XpBlock']> = {
  blockId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  blockType?: Resolver<ResolversTypes['BlockType'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockAggregates'] = ResolversParentTypes['XpBlockAggregates']> = {
  average?: Resolver<Maybe<ResolversTypes['XpBlockAverageAggregates']>, ParentType, ContextType>;
  distinctCount?: Resolver<Maybe<ResolversTypes['XpBlockDistinctCountAggregates']>, ParentType, ContextType>;
  keys?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  max?: Resolver<Maybe<ResolversTypes['XpBlockMaxAggregates']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['XpBlockMinAggregates']>, ParentType, ContextType>;
  stddevPopulation?: Resolver<Maybe<ResolversTypes['XpBlockStddevPopulationAggregates']>, ParentType, ContextType>;
  stddevSample?: Resolver<Maybe<ResolversTypes['XpBlockStddevSampleAggregates']>, ParentType, ContextType>;
  sum?: Resolver<Maybe<ResolversTypes['XpBlockSumAggregates']>, ParentType, ContextType>;
  variancePopulation?: Resolver<Maybe<ResolversTypes['XpBlockVariancePopulationAggregates']>, ParentType, ContextType>;
  varianceSample?: Resolver<Maybe<ResolversTypes['XpBlockVarianceSampleAggregates']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockAverageAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockAverageAggregates'] = ResolversParentTypes['XpBlockAverageAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockDistinctCountAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockDistinctCountAggregates'] = ResolversParentTypes['XpBlockDistinctCountAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  blockType?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockMaxAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockMaxAggregates'] = ResolversParentTypes['XpBlockMaxAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockMinAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockMinAggregates'] = ResolversParentTypes['XpBlockMinAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockStddevPopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockStddevPopulationAggregates'] = ResolversParentTypes['XpBlockStddevPopulationAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockStddevSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockStddevSampleAggregates'] = ResolversParentTypes['XpBlockStddevSampleAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockSumAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockSumAggregates'] = ResolversParentTypes['XpBlockSumAggregates']> = {
  blockId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  guildId?: Resolver<ResolversTypes['BigFloat'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockVariancePopulationAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockVariancePopulationAggregates'] = ResolversParentTypes['XpBlockVariancePopulationAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlockVarianceSampleAggregatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlockVarianceSampleAggregates'] = ResolversParentTypes['XpBlockVarianceSampleAggregates']> = {
  blockId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  guildId?: Resolver<Maybe<ResolversTypes['BigFloat']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlocksConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlocksConnection'] = ResolversParentTypes['XpBlocksConnection']> = {
  aggregates?: Resolver<Maybe<ResolversTypes['XpBlockAggregates']>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['XpBlocksEdge']>, ParentType, ContextType>;
  groupedAggregates?: Resolver<Maybe<Array<ResolversTypes['XpBlockAggregates']>>, ParentType, ContextType, RequireFields<XpBlocksConnectionGroupedAggregatesArgs, 'groupBy'>>;
  nodes?: Resolver<Array<ResolversTypes['XpBlock']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XpBlocksEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpBlocksEdge'] = ResolversParentTypes['XpBlocksEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<ResolversTypes['XpBlock'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AddRoleMenuRolesPayload?: AddRoleMenuRolesPayloadResolvers<ContextType>;
  BigFloat?: GraphQLScalarType;
  BigInt?: GraphQLScalarType;
  BotStat?: BotStatResolvers<ContextType>;
  BotStatAggregates?: BotStatAggregatesResolvers<ContextType>;
  BotStatAverageAggregates?: BotStatAverageAggregatesResolvers<ContextType>;
  BotStatDistinctCountAggregates?: BotStatDistinctCountAggregatesResolvers<ContextType>;
  BotStatMaxAggregates?: BotStatMaxAggregatesResolvers<ContextType>;
  BotStatMinAggregates?: BotStatMinAggregatesResolvers<ContextType>;
  BotStatStddevPopulationAggregates?: BotStatStddevPopulationAggregatesResolvers<ContextType>;
  BotStatStddevSampleAggregates?: BotStatStddevSampleAggregatesResolvers<ContextType>;
  BotStatSumAggregates?: BotStatSumAggregatesResolvers<ContextType>;
  BotStatVariancePopulationAggregates?: BotStatVariancePopulationAggregatesResolvers<ContextType>;
  BotStatVarianceSampleAggregates?: BotStatVarianceSampleAggregatesResolvers<ContextType>;
  BotStatsConnection?: BotStatsConnectionResolvers<ContextType>;
  BotStatsEdge?: BotStatsEdgeResolvers<ContextType>;
  BulkDeleteModLogPayload?: BulkDeleteModLogPayloadResolvers<ContextType>;
  BulkUpdateModLogReasonPayload?: BulkUpdateModLogReasonPayloadResolvers<ContextType>;
  CachedGuild?: CachedGuildResolvers<ContextType>;
  CachedGuildsEdge?: CachedGuildsEdgeResolvers<ContextType>;
  CachedUser?: CachedUserResolvers<ContextType>;
  CachedUsersEdge?: CachedUsersEdgeResolvers<ContextType>;
  CreateBotStatPayload?: CreateBotStatPayloadResolvers<ContextType>;
  CreateCachedGuildPayload?: CreateCachedGuildPayloadResolvers<ContextType>;
  CreateCachedUserPayload?: CreateCachedUserPayloadResolvers<ContextType>;
  CreateEmojiStickerStatPayload?: CreateEmojiStickerStatPayloadResolvers<ContextType>;
  CreateFeedItemPayload?: CreateFeedItemPayloadResolvers<ContextType>;
  CreateFeedPayload?: CreateFeedPayloadResolvers<ContextType>;
  CreateFeedSubscriptionPayload?: CreateFeedSubscriptionPayloadResolvers<ContextType>;
  CreateGuildBanPayload?: CreateGuildBanPayloadResolvers<ContextType>;
  CreateGuildConfigPayload?: CreateGuildConfigPayloadResolvers<ContextType>;
  CreateLevelRoleApplyJobPayload?: CreateLevelRoleApplyJobPayloadResolvers<ContextType>;
  CreateLevelRoleOverridePayload?: CreateLevelRoleOverridePayloadResolvers<ContextType>;
  CreateLevelRolePayload?: CreateLevelRolePayloadResolvers<ContextType>;
  CreateMemberPayload?: CreateMemberPayloadResolvers<ContextType>;
  CreateMessagePayload?: CreateMessagePayloadResolvers<ContextType>;
  CreateModLogPayload?: CreateModLogPayloadResolvers<ContextType>;
  CreateMsgLogBlockPayload?: CreateMsgLogBlockPayloadResolvers<ContextType>;
  CreateMutePayload?: CreateMutePayloadResolvers<ContextType>;
  CreateNotificationPayload?: CreateNotificationPayloadResolvers<ContextType>;
  CreateReminderPayload?: CreateReminderPayloadResolvers<ContextType>;
  CreateRoleMenuPayload?: CreateRoleMenuPayloadResolvers<ContextType>;
  CreateRoleMenuRolePayload?: CreateRoleMenuRolePayloadResolvers<ContextType>;
  CreateTagPayload?: CreateTagPayloadResolvers<ContextType>;
  CreateUserLevelPayload?: CreateUserLevelPayloadResolvers<ContextType>;
  CreateUserPayload?: CreateUserPayloadResolvers<ContextType>;
  CreateWebUserGuildPayload?: CreateWebUserGuildPayloadResolvers<ContextType>;
  CreateWebUserPayload?: CreateWebUserPayloadResolvers<ContextType>;
  CreateXpBlockPayload?: CreateXpBlockPayloadResolvers<ContextType>;
  CurrentUserManagedGuildIdEdge?: CurrentUserManagedGuildIdEdgeResolvers<ContextType>;
  CurrentUserManagedGuildIdsConnection?: CurrentUserManagedGuildIdsConnectionResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  Datetime?: GraphQLScalarType;
  DeleteBotStatPayload?: DeleteBotStatPayloadResolvers<ContextType>;
  DeleteCachedGuildPayload?: DeleteCachedGuildPayloadResolvers<ContextType>;
  DeleteCachedUserPayload?: DeleteCachedUserPayloadResolvers<ContextType>;
  DeleteEmojiStickerStatPayload?: DeleteEmojiStickerStatPayloadResolvers<ContextType>;
  DeleteFeedItemPayload?: DeleteFeedItemPayloadResolvers<ContextType>;
  DeleteFeedPayload?: DeleteFeedPayloadResolvers<ContextType>;
  DeleteFeedSubscriptionPayload?: DeleteFeedSubscriptionPayloadResolvers<ContextType>;
  DeleteGuildBanPayload?: DeleteGuildBanPayloadResolvers<ContextType>;
  DeleteGuildConfigPayload?: DeleteGuildConfigPayloadResolvers<ContextType>;
  DeleteLevelRoleApplyJobPayload?: DeleteLevelRoleApplyJobPayloadResolvers<ContextType>;
  DeleteLevelRoleOverridePayload?: DeleteLevelRoleOverridePayloadResolvers<ContextType>;
  DeleteLevelRolePayload?: DeleteLevelRolePayloadResolvers<ContextType>;
  DeleteMemberPayload?: DeleteMemberPayloadResolvers<ContextType>;
  DeleteMessagePayload?: DeleteMessagePayloadResolvers<ContextType>;
  DeleteMessagesBeforePayload?: DeleteMessagesBeforePayloadResolvers<ContextType>;
  DeleteModLogPayload?: DeleteModLogPayloadResolvers<ContextType>;
  DeleteMsgLogBlockPayload?: DeleteMsgLogBlockPayloadResolvers<ContextType>;
  DeleteMutePayload?: DeleteMutePayloadResolvers<ContextType>;
  DeleteNotificationPayload?: DeleteNotificationPayloadResolvers<ContextType>;
  DeleteReminderPayload?: DeleteReminderPayloadResolvers<ContextType>;
  DeleteRoleMenuPayload?: DeleteRoleMenuPayloadResolvers<ContextType>;
  DeleteRoleMenuRolePayload?: DeleteRoleMenuRolePayloadResolvers<ContextType>;
  DeleteRoleMenuRolesPayload?: DeleteRoleMenuRolesPayloadResolvers<ContextType>;
  DeleteTagPayload?: DeleteTagPayloadResolvers<ContextType>;
  DeleteUserLevelPayload?: DeleteUserLevelPayloadResolvers<ContextType>;
  DeleteUserPayload?: DeleteUserPayloadResolvers<ContextType>;
  DeleteWebUserGuildPayload?: DeleteWebUserGuildPayloadResolvers<ContextType>;
  DeleteWebUserPayload?: DeleteWebUserPayloadResolvers<ContextType>;
  DeleteXpBlockPayload?: DeleteXpBlockPayloadResolvers<ContextType>;
  EligibleLevelRole?: EligibleLevelRoleResolvers<ContextType>;
  EligibleLevelRolesConnection?: EligibleLevelRolesConnectionResolvers<ContextType>;
  EligibleLevelRolesEdge?: EligibleLevelRolesEdgeResolvers<ContextType>;
  EmojiStickerStat?: EmojiStickerStatResolvers<ContextType>;
  EmojiStickerStatAggregates?: EmojiStickerStatAggregatesResolvers<ContextType>;
  EmojiStickerStatAverageAggregates?: EmojiStickerStatAverageAggregatesResolvers<ContextType>;
  EmojiStickerStatDistinctCountAggregates?: EmojiStickerStatDistinctCountAggregatesResolvers<ContextType>;
  EmojiStickerStatMaxAggregates?: EmojiStickerStatMaxAggregatesResolvers<ContextType>;
  EmojiStickerStatMinAggregates?: EmojiStickerStatMinAggregatesResolvers<ContextType>;
  EmojiStickerStatStddevPopulationAggregates?: EmojiStickerStatStddevPopulationAggregatesResolvers<ContextType>;
  EmojiStickerStatStddevSampleAggregates?: EmojiStickerStatStddevSampleAggregatesResolvers<ContextType>;
  EmojiStickerStatSumAggregates?: EmojiStickerStatSumAggregatesResolvers<ContextType>;
  EmojiStickerStatVariancePopulationAggregates?: EmojiStickerStatVariancePopulationAggregatesResolvers<ContextType>;
  EmojiStickerStatVarianceSampleAggregates?: EmojiStickerStatVarianceSampleAggregatesResolvers<ContextType>;
  EmojiStickerStatsConnection?: EmojiStickerStatsConnectionResolvers<ContextType>;
  EmojiStickerStatsEdge?: EmojiStickerStatsEdgeResolvers<ContextType>;
  Feed?: FeedResolvers<ContextType>;
  FeedAggregates?: FeedAggregatesResolvers<ContextType>;
  FeedDistinctCountAggregates?: FeedDistinctCountAggregatesResolvers<ContextType>;
  FeedItem?: FeedItemResolvers<ContextType>;
  FeedItemAggregates?: FeedItemAggregatesResolvers<ContextType>;
  FeedItemDistinctCountAggregates?: FeedItemDistinctCountAggregatesResolvers<ContextType>;
  FeedItemsConnection?: FeedItemsConnectionResolvers<ContextType>;
  FeedItemsEdge?: FeedItemsEdgeResolvers<ContextType>;
  FeedSubscription?: FeedSubscriptionResolvers<ContextType>;
  FeedSubscriptionAggregates?: FeedSubscriptionAggregatesResolvers<ContextType>;
  FeedSubscriptionAverageAggregates?: FeedSubscriptionAverageAggregatesResolvers<ContextType>;
  FeedSubscriptionDistinctCountAggregates?: FeedSubscriptionDistinctCountAggregatesResolvers<ContextType>;
  FeedSubscriptionMaxAggregates?: FeedSubscriptionMaxAggregatesResolvers<ContextType>;
  FeedSubscriptionMinAggregates?: FeedSubscriptionMinAggregatesResolvers<ContextType>;
  FeedSubscriptionStddevPopulationAggregates?: FeedSubscriptionStddevPopulationAggregatesResolvers<ContextType>;
  FeedSubscriptionStddevSampleAggregates?: FeedSubscriptionStddevSampleAggregatesResolvers<ContextType>;
  FeedSubscriptionSumAggregates?: FeedSubscriptionSumAggregatesResolvers<ContextType>;
  FeedSubscriptionVariancePopulationAggregates?: FeedSubscriptionVariancePopulationAggregatesResolvers<ContextType>;
  FeedSubscriptionVarianceSampleAggregates?: FeedSubscriptionVarianceSampleAggregatesResolvers<ContextType>;
  FeedSubscriptionsConnection?: FeedSubscriptionsConnectionResolvers<ContextType>;
  FeedSubscriptionsEdge?: FeedSubscriptionsEdgeResolvers<ContextType>;
  FeedsConnection?: FeedsConnectionResolvers<ContextType>;
  FeedsEdge?: FeedsEdgeResolvers<ContextType>;
  GraphqlPayload?: GraphqlPayloadResolvers<ContextType>;
  GuildBan?: GuildBanResolvers<ContextType>;
  GuildBanAggregates?: GuildBanAggregatesResolvers<ContextType>;
  GuildBanAverageAggregates?: GuildBanAverageAggregatesResolvers<ContextType>;
  GuildBanDistinctCountAggregates?: GuildBanDistinctCountAggregatesResolvers<ContextType>;
  GuildBanMaxAggregates?: GuildBanMaxAggregatesResolvers<ContextType>;
  GuildBanMinAggregates?: GuildBanMinAggregatesResolvers<ContextType>;
  GuildBanStddevPopulationAggregates?: GuildBanStddevPopulationAggregatesResolvers<ContextType>;
  GuildBanStddevSampleAggregates?: GuildBanStddevSampleAggregatesResolvers<ContextType>;
  GuildBanSumAggregates?: GuildBanSumAggregatesResolvers<ContextType>;
  GuildBanVariancePopulationAggregates?: GuildBanVariancePopulationAggregatesResolvers<ContextType>;
  GuildBanVarianceSampleAggregates?: GuildBanVarianceSampleAggregatesResolvers<ContextType>;
  GuildBansConnection?: GuildBansConnectionResolvers<ContextType>;
  GuildBansEdge?: GuildBansEdgeResolvers<ContextType>;
  GuildConfig?: GuildConfigResolvers<ContextType>;
  GuildConfigAggregates?: GuildConfigAggregatesResolvers<ContextType>;
  GuildConfigAverageAggregates?: GuildConfigAverageAggregatesResolvers<ContextType>;
  GuildConfigDistinctCountAggregates?: GuildConfigDistinctCountAggregatesResolvers<ContextType>;
  GuildConfigMaxAggregates?: GuildConfigMaxAggregatesResolvers<ContextType>;
  GuildConfigMinAggregates?: GuildConfigMinAggregatesResolvers<ContextType>;
  GuildConfigStddevPopulationAggregates?: GuildConfigStddevPopulationAggregatesResolvers<ContextType>;
  GuildConfigStddevSampleAggregates?: GuildConfigStddevSampleAggregatesResolvers<ContextType>;
  GuildConfigSumAggregates?: GuildConfigSumAggregatesResolvers<ContextType>;
  GuildConfigVariancePopulationAggregates?: GuildConfigVariancePopulationAggregatesResolvers<ContextType>;
  GuildConfigVarianceSampleAggregates?: GuildConfigVarianceSampleAggregatesResolvers<ContextType>;
  GuildConfigsConnection?: GuildConfigsConnectionResolvers<ContextType>;
  GuildConfigsEdge?: GuildConfigsEdgeResolvers<ContextType>;
  IncrementEmojiStickerStatPayload?: IncrementEmojiStickerStatPayloadResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  LevelRole?: LevelRoleResolvers<ContextType>;
  LevelRoleAggregates?: LevelRoleAggregatesResolvers<ContextType>;
  LevelRoleApplyJob?: LevelRoleApplyJobResolvers<ContextType>;
  LevelRoleApplyJobAggregates?: LevelRoleApplyJobAggregatesResolvers<ContextType>;
  LevelRoleApplyJobAverageAggregates?: LevelRoleApplyJobAverageAggregatesResolvers<ContextType>;
  LevelRoleApplyJobDistinctCountAggregates?: LevelRoleApplyJobDistinctCountAggregatesResolvers<ContextType>;
  LevelRoleApplyJobMaxAggregates?: LevelRoleApplyJobMaxAggregatesResolvers<ContextType>;
  LevelRoleApplyJobMinAggregates?: LevelRoleApplyJobMinAggregatesResolvers<ContextType>;
  LevelRoleApplyJobStddevPopulationAggregates?: LevelRoleApplyJobStddevPopulationAggregatesResolvers<ContextType>;
  LevelRoleApplyJobStddevSampleAggregates?: LevelRoleApplyJobStddevSampleAggregatesResolvers<ContextType>;
  LevelRoleApplyJobSumAggregates?: LevelRoleApplyJobSumAggregatesResolvers<ContextType>;
  LevelRoleApplyJobVariancePopulationAggregates?: LevelRoleApplyJobVariancePopulationAggregatesResolvers<ContextType>;
  LevelRoleApplyJobVarianceSampleAggregates?: LevelRoleApplyJobVarianceSampleAggregatesResolvers<ContextType>;
  LevelRoleApplyJobsConnection?: LevelRoleApplyJobsConnectionResolvers<ContextType>;
  LevelRoleApplyJobsEdge?: LevelRoleApplyJobsEdgeResolvers<ContextType>;
  LevelRoleAverageAggregates?: LevelRoleAverageAggregatesResolvers<ContextType>;
  LevelRoleDistinctCountAggregates?: LevelRoleDistinctCountAggregatesResolvers<ContextType>;
  LevelRoleMaxAggregates?: LevelRoleMaxAggregatesResolvers<ContextType>;
  LevelRoleMinAggregates?: LevelRoleMinAggregatesResolvers<ContextType>;
  LevelRoleOverride?: LevelRoleOverrideResolvers<ContextType>;
  LevelRoleOverrideAggregates?: LevelRoleOverrideAggregatesResolvers<ContextType>;
  LevelRoleOverrideAverageAggregates?: LevelRoleOverrideAverageAggregatesResolvers<ContextType>;
  LevelRoleOverrideDistinctCountAggregates?: LevelRoleOverrideDistinctCountAggregatesResolvers<ContextType>;
  LevelRoleOverrideMaxAggregates?: LevelRoleOverrideMaxAggregatesResolvers<ContextType>;
  LevelRoleOverrideMinAggregates?: LevelRoleOverrideMinAggregatesResolvers<ContextType>;
  LevelRoleOverrideStddevPopulationAggregates?: LevelRoleOverrideStddevPopulationAggregatesResolvers<ContextType>;
  LevelRoleOverrideStddevSampleAggregates?: LevelRoleOverrideStddevSampleAggregatesResolvers<ContextType>;
  LevelRoleOverrideSumAggregates?: LevelRoleOverrideSumAggregatesResolvers<ContextType>;
  LevelRoleOverrideVariancePopulationAggregates?: LevelRoleOverrideVariancePopulationAggregatesResolvers<ContextType>;
  LevelRoleOverrideVarianceSampleAggregates?: LevelRoleOverrideVarianceSampleAggregatesResolvers<ContextType>;
  LevelRoleOverridesConnection?: LevelRoleOverridesConnectionResolvers<ContextType>;
  LevelRoleOverridesEdge?: LevelRoleOverridesEdgeResolvers<ContextType>;
  LevelRoleStddevPopulationAggregates?: LevelRoleStddevPopulationAggregatesResolvers<ContextType>;
  LevelRoleStddevSampleAggregates?: LevelRoleStddevSampleAggregatesResolvers<ContextType>;
  LevelRoleSumAggregates?: LevelRoleSumAggregatesResolvers<ContextType>;
  LevelRoleVariancePopulationAggregates?: LevelRoleVariancePopulationAggregatesResolvers<ContextType>;
  LevelRoleVarianceSampleAggregates?: LevelRoleVarianceSampleAggregatesResolvers<ContextType>;
  LevelRolesConnection?: LevelRolesConnectionResolvers<ContextType>;
  LevelRolesEdge?: LevelRolesEdgeResolvers<ContextType>;
  LogoutPayload?: LogoutPayloadResolvers<ContextType>;
  Member?: MemberResolvers<ContextType>;
  MemberAggregates?: MemberAggregatesResolvers<ContextType>;
  MemberAverageAggregates?: MemberAverageAggregatesResolvers<ContextType>;
  MemberDistinctCountAggregates?: MemberDistinctCountAggregatesResolvers<ContextType>;
  MemberMaxAggregates?: MemberMaxAggregatesResolvers<ContextType>;
  MemberMinAggregates?: MemberMinAggregatesResolvers<ContextType>;
  MemberStddevPopulationAggregates?: MemberStddevPopulationAggregatesResolvers<ContextType>;
  MemberStddevSampleAggregates?: MemberStddevSampleAggregatesResolvers<ContextType>;
  MemberSumAggregates?: MemberSumAggregatesResolvers<ContextType>;
  MemberVariancePopulationAggregates?: MemberVariancePopulationAggregatesResolvers<ContextType>;
  MemberVarianceSampleAggregates?: MemberVarianceSampleAggregatesResolvers<ContextType>;
  MembersConnection?: MembersConnectionResolvers<ContextType>;
  MembersEdge?: MembersEdgeResolvers<ContextType>;
  Message?: MessageResolvers<ContextType>;
  MessageAggregates?: MessageAggregatesResolvers<ContextType>;
  MessageAverageAggregates?: MessageAverageAggregatesResolvers<ContextType>;
  MessageDistinctCountAggregates?: MessageDistinctCountAggregatesResolvers<ContextType>;
  MessageMaxAggregates?: MessageMaxAggregatesResolvers<ContextType>;
  MessageMinAggregates?: MessageMinAggregatesResolvers<ContextType>;
  MessageStddevPopulationAggregates?: MessageStddevPopulationAggregatesResolvers<ContextType>;
  MessageStddevSampleAggregates?: MessageStddevSampleAggregatesResolvers<ContextType>;
  MessageSumAggregates?: MessageSumAggregatesResolvers<ContextType>;
  MessageVariancePopulationAggregates?: MessageVariancePopulationAggregatesResolvers<ContextType>;
  MessageVarianceSampleAggregates?: MessageVarianceSampleAggregatesResolvers<ContextType>;
  MessagesConnection?: MessagesConnectionResolvers<ContextType>;
  MessagesEdge?: MessagesEdgeResolvers<ContextType>;
  ModLog?: ModLogResolvers<ContextType>;
  ModLogAggregates?: ModLogAggregatesResolvers<ContextType>;
  ModLogAverageAggregates?: ModLogAverageAggregatesResolvers<ContextType>;
  ModLogDistinctCountAggregates?: ModLogDistinctCountAggregatesResolvers<ContextType>;
  ModLogMaxAggregates?: ModLogMaxAggregatesResolvers<ContextType>;
  ModLogMinAggregates?: ModLogMinAggregatesResolvers<ContextType>;
  ModLogStddevPopulationAggregates?: ModLogStddevPopulationAggregatesResolvers<ContextType>;
  ModLogStddevSampleAggregates?: ModLogStddevSampleAggregatesResolvers<ContextType>;
  ModLogSumAggregates?: ModLogSumAggregatesResolvers<ContextType>;
  ModLogVariancePopulationAggregates?: ModLogVariancePopulationAggregatesResolvers<ContextType>;
  ModLogVarianceSampleAggregates?: ModLogVarianceSampleAggregatesResolvers<ContextType>;
  ModLogsConnection?: ModLogsConnectionResolvers<ContextType>;
  ModLogsEdge?: ModLogsEdgeResolvers<ContextType>;
  MsgLogBlock?: MsgLogBlockResolvers<ContextType>;
  MsgLogBlockAggregates?: MsgLogBlockAggregatesResolvers<ContextType>;
  MsgLogBlockAverageAggregates?: MsgLogBlockAverageAggregatesResolvers<ContextType>;
  MsgLogBlockDistinctCountAggregates?: MsgLogBlockDistinctCountAggregatesResolvers<ContextType>;
  MsgLogBlockMaxAggregates?: MsgLogBlockMaxAggregatesResolvers<ContextType>;
  MsgLogBlockMinAggregates?: MsgLogBlockMinAggregatesResolvers<ContextType>;
  MsgLogBlockStddevPopulationAggregates?: MsgLogBlockStddevPopulationAggregatesResolvers<ContextType>;
  MsgLogBlockStddevSampleAggregates?: MsgLogBlockStddevSampleAggregatesResolvers<ContextType>;
  MsgLogBlockSumAggregates?: MsgLogBlockSumAggregatesResolvers<ContextType>;
  MsgLogBlockVariancePopulationAggregates?: MsgLogBlockVariancePopulationAggregatesResolvers<ContextType>;
  MsgLogBlockVarianceSampleAggregates?: MsgLogBlockVarianceSampleAggregatesResolvers<ContextType>;
  MsgLogBlocksConnection?: MsgLogBlocksConnectionResolvers<ContextType>;
  MsgLogBlocksEdge?: MsgLogBlocksEdgeResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Mute?: MuteResolvers<ContextType>;
  MuteAggregates?: MuteAggregatesResolvers<ContextType>;
  MuteAverageAggregates?: MuteAverageAggregatesResolvers<ContextType>;
  MuteDistinctCountAggregates?: MuteDistinctCountAggregatesResolvers<ContextType>;
  MuteMaxAggregates?: MuteMaxAggregatesResolvers<ContextType>;
  MuteMinAggregates?: MuteMinAggregatesResolvers<ContextType>;
  MuteStddevPopulationAggregates?: MuteStddevPopulationAggregatesResolvers<ContextType>;
  MuteStddevSampleAggregates?: MuteStddevSampleAggregatesResolvers<ContextType>;
  MuteSumAggregates?: MuteSumAggregatesResolvers<ContextType>;
  MuteVariancePopulationAggregates?: MuteVariancePopulationAggregatesResolvers<ContextType>;
  MuteVarianceSampleAggregates?: MuteVarianceSampleAggregatesResolvers<ContextType>;
  MutesConnection?: MutesConnectionResolvers<ContextType>;
  MutesEdge?: MutesEdgeResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  Notification?: NotificationResolvers<ContextType>;
  NotificationAggregates?: NotificationAggregatesResolvers<ContextType>;
  NotificationAverageAggregates?: NotificationAverageAggregatesResolvers<ContextType>;
  NotificationDistinctCountAggregates?: NotificationDistinctCountAggregatesResolvers<ContextType>;
  NotificationMaxAggregates?: NotificationMaxAggregatesResolvers<ContextType>;
  NotificationMinAggregates?: NotificationMinAggregatesResolvers<ContextType>;
  NotificationStddevPopulationAggregates?: NotificationStddevPopulationAggregatesResolvers<ContextType>;
  NotificationStddevSampleAggregates?: NotificationStddevSampleAggregatesResolvers<ContextType>;
  NotificationSumAggregates?: NotificationSumAggregatesResolvers<ContextType>;
  NotificationVariancePopulationAggregates?: NotificationVariancePopulationAggregatesResolvers<ContextType>;
  NotificationVarianceSampleAggregates?: NotificationVarianceSampleAggregatesResolvers<ContextType>;
  NotificationsConnection?: NotificationsConnectionResolvers<ContextType>;
  NotificationsEdge?: NotificationsEdgeResolvers<ContextType>;
  NotificationsStartingWithConnection?: NotificationsStartingWithConnectionResolvers<ContextType>;
  NotificationsStartingWithEdge?: NotificationsStartingWithEdgeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RedisGuild?: RedisGuildResolvers<ContextType>;
  RedisGuildRole?: RedisGuildRoleResolvers<ContextType>;
  RedisRoleTags?: RedisRoleTagsResolvers<ContextType>;
  Reminder?: ReminderResolvers<ContextType>;
  ReminderAggregates?: ReminderAggregatesResolvers<ContextType>;
  ReminderAverageAggregates?: ReminderAverageAggregatesResolvers<ContextType>;
  ReminderDistinctCountAggregates?: ReminderDistinctCountAggregatesResolvers<ContextType>;
  ReminderMaxAggregates?: ReminderMaxAggregatesResolvers<ContextType>;
  ReminderMinAggregates?: ReminderMinAggregatesResolvers<ContextType>;
  ReminderStddevPopulationAggregates?: ReminderStddevPopulationAggregatesResolvers<ContextType>;
  ReminderStddevSampleAggregates?: ReminderStddevSampleAggregatesResolvers<ContextType>;
  ReminderSumAggregates?: ReminderSumAggregatesResolvers<ContextType>;
  ReminderVariancePopulationAggregates?: ReminderVariancePopulationAggregatesResolvers<ContextType>;
  ReminderVarianceSampleAggregates?: ReminderVarianceSampleAggregatesResolvers<ContextType>;
  RemindersConnection?: RemindersConnectionResolvers<ContextType>;
  RemindersEdge?: RemindersEdgeResolvers<ContextType>;
  RoleMenu?: RoleMenuResolvers<ContextType>;
  RoleMenuAggregates?: RoleMenuAggregatesResolvers<ContextType>;
  RoleMenuAverageAggregates?: RoleMenuAverageAggregatesResolvers<ContextType>;
  RoleMenuDistinctCountAggregates?: RoleMenuDistinctCountAggregatesResolvers<ContextType>;
  RoleMenuMaxAggregates?: RoleMenuMaxAggregatesResolvers<ContextType>;
  RoleMenuMinAggregates?: RoleMenuMinAggregatesResolvers<ContextType>;
  RoleMenuRole?: RoleMenuRoleResolvers<ContextType>;
  RoleMenuRoleAggregates?: RoleMenuRoleAggregatesResolvers<ContextType>;
  RoleMenuRoleAverageAggregates?: RoleMenuRoleAverageAggregatesResolvers<ContextType>;
  RoleMenuRoleDistinctCountAggregates?: RoleMenuRoleDistinctCountAggregatesResolvers<ContextType>;
  RoleMenuRoleMaxAggregates?: RoleMenuRoleMaxAggregatesResolvers<ContextType>;
  RoleMenuRoleMinAggregates?: RoleMenuRoleMinAggregatesResolvers<ContextType>;
  RoleMenuRoleStddevPopulationAggregates?: RoleMenuRoleStddevPopulationAggregatesResolvers<ContextType>;
  RoleMenuRoleStddevSampleAggregates?: RoleMenuRoleStddevSampleAggregatesResolvers<ContextType>;
  RoleMenuRoleSumAggregates?: RoleMenuRoleSumAggregatesResolvers<ContextType>;
  RoleMenuRoleVariancePopulationAggregates?: RoleMenuRoleVariancePopulationAggregatesResolvers<ContextType>;
  RoleMenuRoleVarianceSampleAggregates?: RoleMenuRoleVarianceSampleAggregatesResolvers<ContextType>;
  RoleMenuRolesConnection?: RoleMenuRolesConnectionResolvers<ContextType>;
  RoleMenuRolesEdge?: RoleMenuRolesEdgeResolvers<ContextType>;
  RoleMenuStddevPopulationAggregates?: RoleMenuStddevPopulationAggregatesResolvers<ContextType>;
  RoleMenuStddevSampleAggregates?: RoleMenuStddevSampleAggregatesResolvers<ContextType>;
  RoleMenuSumAggregates?: RoleMenuSumAggregatesResolvers<ContextType>;
  RoleMenuVariancePopulationAggregates?: RoleMenuVariancePopulationAggregatesResolvers<ContextType>;
  RoleMenuVarianceSampleAggregates?: RoleMenuVarianceSampleAggregatesResolvers<ContextType>;
  RoleMenusConnection?: RoleMenusConnectionResolvers<ContextType>;
  RoleMenusEdge?: RoleMenusEdgeResolvers<ContextType>;
  SetRoleMenuRoleOrderPayload?: SetRoleMenuRoleOrderPayloadResolvers<ContextType>;
  Tag?: TagResolvers<ContextType>;
  TagAggregates?: TagAggregatesResolvers<ContextType>;
  TagAverageAggregates?: TagAverageAggregatesResolvers<ContextType>;
  TagDistinctCountAggregates?: TagDistinctCountAggregatesResolvers<ContextType>;
  TagMaxAggregates?: TagMaxAggregatesResolvers<ContextType>;
  TagMinAggregates?: TagMinAggregatesResolvers<ContextType>;
  TagStddevPopulationAggregates?: TagStddevPopulationAggregatesResolvers<ContextType>;
  TagStddevSampleAggregates?: TagStddevSampleAggregatesResolvers<ContextType>;
  TagSumAggregates?: TagSumAggregatesResolvers<ContextType>;
  TagVariancePopulationAggregates?: TagVariancePopulationAggregatesResolvers<ContextType>;
  TagVarianceSampleAggregates?: TagVarianceSampleAggregatesResolvers<ContextType>;
  TagsConnection?: TagsConnectionResolvers<ContextType>;
  TagsEdge?: TagsEdgeResolvers<ContextType>;
  TimeframeUserLevelEdge?: TimeframeUserLevelEdgeResolvers<ContextType>;
  TimeframeUserLevelsConnection?: TimeframeUserLevelsConnectionResolvers<ContextType>;
  TimeframeUserLevelsRecord?: TimeframeUserLevelsRecordResolvers<ContextType>;
  UUID?: GraphQLScalarType;
  UpdateBotStatPayload?: UpdateBotStatPayloadResolvers<ContextType>;
  UpdateCachedGuildPayload?: UpdateCachedGuildPayloadResolvers<ContextType>;
  UpdateCachedUserPayload?: UpdateCachedUserPayloadResolvers<ContextType>;
  UpdateEmojiStickerStatPayload?: UpdateEmojiStickerStatPayloadResolvers<ContextType>;
  UpdateFeedItemPayload?: UpdateFeedItemPayloadResolvers<ContextType>;
  UpdateFeedPayload?: UpdateFeedPayloadResolvers<ContextType>;
  UpdateFeedSubscriptionPayload?: UpdateFeedSubscriptionPayloadResolvers<ContextType>;
  UpdateGuildBanPayload?: UpdateGuildBanPayloadResolvers<ContextType>;
  UpdateGuildConfigPayload?: UpdateGuildConfigPayloadResolvers<ContextType>;
  UpdateLevelRoleApplyJobPayload?: UpdateLevelRoleApplyJobPayloadResolvers<ContextType>;
  UpdateLevelRoleOverridePayload?: UpdateLevelRoleOverridePayloadResolvers<ContextType>;
  UpdateLevelRolePayload?: UpdateLevelRolePayloadResolvers<ContextType>;
  UpdateMemberPayload?: UpdateMemberPayloadResolvers<ContextType>;
  UpdateMessagePayload?: UpdateMessagePayloadResolvers<ContextType>;
  UpdateModLogPayload?: UpdateModLogPayloadResolvers<ContextType>;
  UpdateMsgLogBlockPayload?: UpdateMsgLogBlockPayloadResolvers<ContextType>;
  UpdateMutePayload?: UpdateMutePayloadResolvers<ContextType>;
  UpdateNotificationPayload?: UpdateNotificationPayloadResolvers<ContextType>;
  UpdateReminderPayload?: UpdateReminderPayloadResolvers<ContextType>;
  UpdateRoleMenuPayload?: UpdateRoleMenuPayloadResolvers<ContextType>;
  UpdateRoleMenuRolePayload?: UpdateRoleMenuRolePayloadResolvers<ContextType>;
  UpdateTagPayload?: UpdateTagPayloadResolvers<ContextType>;
  UpdateUserLevelPayload?: UpdateUserLevelPayloadResolvers<ContextType>;
  UpdateUserPayload?: UpdateUserPayloadResolvers<ContextType>;
  UpdateUserXpPayload?: UpdateUserXpPayloadResolvers<ContextType>;
  UpdateWebUserGuildPayload?: UpdateWebUserGuildPayloadResolvers<ContextType>;
  UpdateWebUserPayload?: UpdateWebUserPayloadResolvers<ContextType>;
  UpdateXpBlockPayload?: UpdateXpBlockPayloadResolvers<ContextType>;
  UpsertBotStatPayload?: UpsertBotStatPayloadResolvers<ContextType>;
  UpsertCachedGuildPayload?: UpsertCachedGuildPayloadResolvers<ContextType>;
  UpsertCachedUserPayload?: UpsertCachedUserPayloadResolvers<ContextType>;
  UpsertEmojiStickerStatPayload?: UpsertEmojiStickerStatPayloadResolvers<ContextType>;
  UpsertFeedItemPayload?: UpsertFeedItemPayloadResolvers<ContextType>;
  UpsertFeedPayload?: UpsertFeedPayloadResolvers<ContextType>;
  UpsertFeedSubscriptionPayload?: UpsertFeedSubscriptionPayloadResolvers<ContextType>;
  UpsertGuildBanPayload?: UpsertGuildBanPayloadResolvers<ContextType>;
  UpsertGuildConfigPayload?: UpsertGuildConfigPayloadResolvers<ContextType>;
  UpsertLevelRoleApplyJobPayload?: UpsertLevelRoleApplyJobPayloadResolvers<ContextType>;
  UpsertLevelRoleOverridePayload?: UpsertLevelRoleOverridePayloadResolvers<ContextType>;
  UpsertLevelRolePayload?: UpsertLevelRolePayloadResolvers<ContextType>;
  UpsertMemberPayload?: UpsertMemberPayloadResolvers<ContextType>;
  UpsertMessagePayload?: UpsertMessagePayloadResolvers<ContextType>;
  UpsertModLogPayload?: UpsertModLogPayloadResolvers<ContextType>;
  UpsertMsgLogBlockPayload?: UpsertMsgLogBlockPayloadResolvers<ContextType>;
  UpsertMutePayload?: UpsertMutePayloadResolvers<ContextType>;
  UpsertNotificationPayload?: UpsertNotificationPayloadResolvers<ContextType>;
  UpsertReminderPayload?: UpsertReminderPayloadResolvers<ContextType>;
  UpsertRoleMenuPayload?: UpsertRoleMenuPayloadResolvers<ContextType>;
  UpsertRoleMenuRolePayload?: UpsertRoleMenuRolePayloadResolvers<ContextType>;
  UpsertTagPayload?: UpsertTagPayloadResolvers<ContextType>;
  UpsertUserLevelPayload?: UpsertUserLevelPayloadResolvers<ContextType>;
  UpsertUserPayload?: UpsertUserPayloadResolvers<ContextType>;
  UpsertWebUserGuildPayload?: UpsertWebUserGuildPayloadResolvers<ContextType>;
  UpsertWebUserPayload?: UpsertWebUserPayloadResolvers<ContextType>;
  UpsertXpBlockPayload?: UpsertXpBlockPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserAggregates?: UserAggregatesResolvers<ContextType>;
  UserAverageAggregates?: UserAverageAggregatesResolvers<ContextType>;
  UserDistinctCountAggregates?: UserDistinctCountAggregatesResolvers<ContextType>;
  UserGuildRankResult?: UserGuildRankResultResolvers<ContextType>;
  UserLevel?: UserLevelResolvers<ContextType>;
  UserLevelAggregates?: UserLevelAggregatesResolvers<ContextType>;
  UserLevelAverageAggregates?: UserLevelAverageAggregatesResolvers<ContextType>;
  UserLevelDistinctCountAggregates?: UserLevelDistinctCountAggregatesResolvers<ContextType>;
  UserLevelMaxAggregates?: UserLevelMaxAggregatesResolvers<ContextType>;
  UserLevelMinAggregates?: UserLevelMinAggregatesResolvers<ContextType>;
  UserLevelStddevPopulationAggregates?: UserLevelStddevPopulationAggregatesResolvers<ContextType>;
  UserLevelStddevSampleAggregates?: UserLevelStddevSampleAggregatesResolvers<ContextType>;
  UserLevelSumAggregates?: UserLevelSumAggregatesResolvers<ContextType>;
  UserLevelVariancePopulationAggregates?: UserLevelVariancePopulationAggregatesResolvers<ContextType>;
  UserLevelVarianceSampleAggregates?: UserLevelVarianceSampleAggregatesResolvers<ContextType>;
  UserLevelsConnection?: UserLevelsConnectionResolvers<ContextType>;
  UserLevelsEdge?: UserLevelsEdgeResolvers<ContextType>;
  UserMaxAggregates?: UserMaxAggregatesResolvers<ContextType>;
  UserMinAggregates?: UserMinAggregatesResolvers<ContextType>;
  UserStddevPopulationAggregates?: UserStddevPopulationAggregatesResolvers<ContextType>;
  UserStddevSampleAggregates?: UserStddevSampleAggregatesResolvers<ContextType>;
  UserSumAggregates?: UserSumAggregatesResolvers<ContextType>;
  UserVariancePopulationAggregates?: UserVariancePopulationAggregatesResolvers<ContextType>;
  UserVarianceSampleAggregates?: UserVarianceSampleAggregatesResolvers<ContextType>;
  UserXpUpdateResult?: UserXpUpdateResultResolvers<ContextType>;
  UsersConnection?: UsersConnectionResolvers<ContextType>;
  UsersEdge?: UsersEdgeResolvers<ContextType>;
  WebUser?: WebUserResolvers<ContextType>;
  WebUserAggregates?: WebUserAggregatesResolvers<ContextType>;
  WebUserAverageAggregates?: WebUserAverageAggregatesResolvers<ContextType>;
  WebUserDistinctCountAggregates?: WebUserDistinctCountAggregatesResolvers<ContextType>;
  WebUserGuild?: WebUserGuildResolvers<ContextType>;
  WebUserGuildAggregates?: WebUserGuildAggregatesResolvers<ContextType>;
  WebUserGuildAverageAggregates?: WebUserGuildAverageAggregatesResolvers<ContextType>;
  WebUserGuildDistinctCountAggregates?: WebUserGuildDistinctCountAggregatesResolvers<ContextType>;
  WebUserGuildMaxAggregates?: WebUserGuildMaxAggregatesResolvers<ContextType>;
  WebUserGuildMinAggregates?: WebUserGuildMinAggregatesResolvers<ContextType>;
  WebUserGuildStddevPopulationAggregates?: WebUserGuildStddevPopulationAggregatesResolvers<ContextType>;
  WebUserGuildStddevSampleAggregates?: WebUserGuildStddevSampleAggregatesResolvers<ContextType>;
  WebUserGuildSumAggregates?: WebUserGuildSumAggregatesResolvers<ContextType>;
  WebUserGuildVariancePopulationAggregates?: WebUserGuildVariancePopulationAggregatesResolvers<ContextType>;
  WebUserGuildVarianceSampleAggregates?: WebUserGuildVarianceSampleAggregatesResolvers<ContextType>;
  WebUserGuildsConnection?: WebUserGuildsConnectionResolvers<ContextType>;
  WebUserGuildsEdge?: WebUserGuildsEdgeResolvers<ContextType>;
  WebUserMaxAggregates?: WebUserMaxAggregatesResolvers<ContextType>;
  WebUserMinAggregates?: WebUserMinAggregatesResolvers<ContextType>;
  WebUserStddevPopulationAggregates?: WebUserStddevPopulationAggregatesResolvers<ContextType>;
  WebUserStddevSampleAggregates?: WebUserStddevSampleAggregatesResolvers<ContextType>;
  WebUserSumAggregates?: WebUserSumAggregatesResolvers<ContextType>;
  WebUserVariancePopulationAggregates?: WebUserVariancePopulationAggregatesResolvers<ContextType>;
  WebUserVarianceSampleAggregates?: WebUserVarianceSampleAggregatesResolvers<ContextType>;
  WebUsersConnection?: WebUsersConnectionResolvers<ContextType>;
  WebUsersEdge?: WebUsersEdgeResolvers<ContextType>;
  XpBlock?: XpBlockResolvers<ContextType>;
  XpBlockAggregates?: XpBlockAggregatesResolvers<ContextType>;
  XpBlockAverageAggregates?: XpBlockAverageAggregatesResolvers<ContextType>;
  XpBlockDistinctCountAggregates?: XpBlockDistinctCountAggregatesResolvers<ContextType>;
  XpBlockMaxAggregates?: XpBlockMaxAggregatesResolvers<ContextType>;
  XpBlockMinAggregates?: XpBlockMinAggregatesResolvers<ContextType>;
  XpBlockStddevPopulationAggregates?: XpBlockStddevPopulationAggregatesResolvers<ContextType>;
  XpBlockStddevSampleAggregates?: XpBlockStddevSampleAggregatesResolvers<ContextType>;
  XpBlockSumAggregates?: XpBlockSumAggregatesResolvers<ContextType>;
  XpBlockVariancePopulationAggregates?: XpBlockVariancePopulationAggregatesResolvers<ContextType>;
  XpBlockVarianceSampleAggregates?: XpBlockVarianceSampleAggregatesResolvers<ContextType>;
  XpBlocksConnection?: XpBlocksConnectionResolvers<ContextType>;
  XpBlocksEdge?: XpBlocksEdgeResolvers<ContextType>;
};


export type BanDataFragment = { __typename?: 'GuildBan', guildId: string, nodeId: string, userId: string };

export type GetUserBansQueryVariables = Exact<{
  userId: Scalars['BigInt'];
}>;


export type GetUserBansQuery = { __typename?: 'Query', allGuildBans?: { __typename?: 'GuildBansConnection', totalCount: number, nodes: Array<{ __typename?: 'GuildBan', guildId: string, nodeId: string, userId: string }> } | null };

export type GetRedisGuildQueryVariables = Exact<{
  guild_id: Scalars['BigInt'];
}>;


export type GetRedisGuildQuery = { __typename?: 'Query', redisGuildByGuildId?: { __typename?: 'RedisGuild', afkChannelId?: string | null, afkTimeout: number, applicationId?: string | null, banner?: string | null, channels?: Array<string | null> | null, defaultMessageNotifications?: number | null, description?: string | null, discoverySplash?: string | null, explicitContentFilter?: number | null, features?: Array<string | null> | null, icon?: string | null, id: string, joinedAt?: string | null, large?: boolean | null, maxMembers?: number | null, maxVideoChannelUsers?: number | null, memberCount?: number | null, members?: Array<string | null> | null, mfaLevel?: number | null, name: string, nsfwLevel: number, ownerId: string, preferredLocale?: string | null, premiumSubscriptionCount?: number | null, premiumTier: number, presences?: Array<string | null> | null, rulesChannelId?: string | null, splash?: string | null, systemChannelFlags?: number | null, systemChannelId?: string | null, unavailable?: boolean | null, vanityUrlCode?: string | null, verificationLevel?: number | null, voiceStates?: Array<string | null> | null, roles: Array<{ __typename?: 'RedisGuildRole', id: string, color: number, hoist: boolean, icon?: string | null, managed: boolean, mentionable: boolean, position: number, name: string, permissions: string, unicode_emoji?: string | null }> } | null };

export type GuildConfigByIdQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GuildConfigByIdQuery = { __typename?: 'Query', guildConfigById?: { __typename?: 'GuildConfig', disabledChannels?: Array<string | null> | null, inviteGuard: boolean, joinMsg?: string | null, joinMsgEnabled: boolean, joinReact?: string | null, leaveMsg?: string | null, leaveMsgEnabled: boolean, logMember?: string | null, logMemberEnabled: boolean, logModEnabled: boolean, logMod?: string | null, logMsg?: string | null, logMsgEnabled: boolean, maxMention?: number | null, msgChannel?: string | null, muteDmEnabled: boolean, muteDmText?: string | null, muteDuration?: string | null, muteRole?: string | null, prefix?: string | null, roleChannel?: string | null, roleConfig?: { [key: string]: any } | null, roleEnabled: boolean, warnDmEnabled: boolean, warnDmText?: string | null } | null };

export type GuildConfigDataFragment = { __typename?: 'GuildConfig', disabledChannels?: Array<string | null> | null, inviteGuard: boolean, joinMsg?: string | null, joinMsgEnabled: boolean, joinReact?: string | null, leaveMsg?: string | null, leaveMsgEnabled: boolean, logMember?: string | null, logMemberEnabled: boolean, logModEnabled: boolean, logMod?: string | null, logMsg?: string | null, logMsgEnabled: boolean, maxMention?: number | null, msgChannel?: string | null, muteDmEnabled: boolean, muteDmText?: string | null, muteDuration?: string | null, muteRole?: string | null, prefix?: string | null, roleChannel?: string | null, roleConfig?: { [key: string]: any } | null, roleEnabled: boolean, warnDmEnabled: boolean, warnDmText?: string | null };

export type UpdateGuildConfigMutationVariables = Exact<{
  id: Scalars['BigInt'];
  patch: GuildConfigPatch;
}>;


export type UpdateGuildConfigMutation = { __typename?: 'Mutation', updateGuildConfigById?: { __typename?: 'UpdateGuildConfigPayload', guildConfig?: { __typename?: 'GuildConfig', disabledChannels?: Array<string | null> | null, inviteGuard: boolean, joinMsg?: string | null, joinMsgEnabled: boolean, joinReact?: string | null, leaveMsg?: string | null, leaveMsgEnabled: boolean, logMember?: string | null, logMemberEnabled: boolean, logModEnabled: boolean, logMod?: string | null, logMsg?: string | null, logMsgEnabled: boolean, maxMention?: number | null, msgChannel?: string | null, muteDmEnabled: boolean, muteDmText?: string | null, muteDuration?: string | null, muteRole?: string | null, prefix?: string | null, roleChannel?: string | null, roleConfig?: { [key: string]: any } | null, roleEnabled: boolean, warnDmEnabled: boolean, warnDmText?: string | null } | null } | null };

export type CreateLevelRoleApplyJobMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  interactionId: Scalars['BigInt'];
  notifyUserId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  messageId: Scalars['BigInt'];
  requestsTotal: Scalars['BigInt'];
  membersTotal: Scalars['BigInt'];
}>;


export type CreateLevelRoleApplyJobMutation = { __typename?: 'Mutation', createLevelRoleApplyJob?: { __typename?: 'CreateLevelRoleApplyJobPayload', levelRoleApplyJob?: { __typename?: 'LevelRoleApplyJob', guildId: string, interactionId: string, notifyUserId: string, channelId: string, messageId: string, requestsProcessed: string, requestsTotal?: string | null, membersTotal: string, membersSkipped: string, membersApplied: string, membersNotFound: string, membersTotalProcessed: string, createdAt: string, updatedAt: string } | null } | null };

export type DeleteLevelRoleApplyJobMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type DeleteLevelRoleApplyJobMutation = { __typename?: 'Mutation', deleteLevelRoleApplyJobByGuildId?: { __typename?: 'DeleteLevelRoleApplyJobPayload', levelRoleApplyJob?: { __typename?: 'LevelRoleApplyJob', guildId: string, interactionId: string, notifyUserId: string, channelId: string, messageId: string, requestsProcessed: string, requestsTotal?: string | null, membersTotal: string, membersSkipped: string, membersApplied: string, membersNotFound: string, membersTotalProcessed: string, createdAt: string, updatedAt: string } | null } | null };

export type GetLevelRoleApplyJobByGuildIdQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetLevelRoleApplyJobByGuildIdQuery = { __typename?: 'Query', levelRoleApplyJobByGuildId?: { __typename?: 'LevelRoleApplyJob', guildId: string, interactionId: string, notifyUserId: string, channelId: string, messageId: string, requestsProcessed: string, requestsTotal?: string | null, membersTotal: string, membersSkipped: string, membersApplied: string, membersNotFound: string, membersTotalProcessed: string, createdAt: string, updatedAt: string } | null };

export type LevelRoleApplyJobDataFragment = { __typename?: 'LevelRoleApplyJob', guildId: string, interactionId: string, notifyUserId: string, channelId: string, messageId: string, requestsProcessed: string, requestsTotal?: string | null, membersTotal: string, membersSkipped: string, membersApplied: string, membersNotFound: string, membersTotalProcessed: string, createdAt: string, updatedAt: string };

export type UpdateLevelRoleApplyJobMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  levelRoleApplyJobPatch: LevelRoleApplyJobPatch;
}>;


export type UpdateLevelRoleApplyJobMutation = { __typename?: 'Mutation', updateLevelRoleApplyJobByGuildId?: { __typename?: 'UpdateLevelRoleApplyJobPayload', levelRoleApplyJob?: { __typename?: 'LevelRoleApplyJob', guildId: string, interactionId: string, notifyUserId: string, channelId: string, messageId: string, requestsProcessed: string, requestsTotal?: string | null, membersTotal: string, membersSkipped: string, membersApplied: string, membersNotFound: string, membersTotalProcessed: string, createdAt: string, updatedAt: string } | null } | null };

export type DeleteLevelRoleMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
}>;


export type DeleteLevelRoleMutation = { __typename?: 'Mutation', deleteLevelRoleByGuildIdAndRoleId?: { __typename?: 'DeleteLevelRolePayload', levelRole?: { __typename?: 'LevelRole', guildId: string, roleId: string, addLevel?: string | null, removeLevel?: string | null } | null } | null };

export type GetEligibleLevelRolesQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  userIds?: InputMaybe<Array<Scalars['BigInt']> | Scalars['BigInt']>;
}>;


export type GetEligibleLevelRolesQuery = { __typename?: 'Query', getEligibleLevelRoles?: { __typename?: 'EligibleLevelRolesConnection', nodes: Array<{ __typename?: 'EligibleLevelRole', roleIds?: Array<string | null> | null, userId?: string | null }> } | null };

export type GetLevelRoleQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
}>;


export type GetLevelRoleQuery = { __typename?: 'Query', levelRoleByGuildIdAndRoleId?: { __typename?: 'LevelRole', guildId: string, roleId: string, addLevel?: string | null, removeLevel?: string | null } | null };

export type GetLevelRolesQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetLevelRolesQuery = { __typename?: 'Query', allLevelRoles?: { __typename?: 'LevelRolesConnection', nodes: Array<{ __typename?: 'LevelRole', guildId: string, roleId: string, addLevel?: string | null, removeLevel?: string | null }> } | null };

export type LevelRoleDataFragment = { __typename?: 'LevelRole', guildId: string, roleId: string, addLevel?: string | null, removeLevel?: string | null };

export type UpsertLevelRoleMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  roleId: Scalars['BigInt'];
  removeLevel?: InputMaybe<Scalars['BigInt']>;
  addLevel?: InputMaybe<Scalars['BigInt']>;
}>;


export type UpsertLevelRoleMutation = { __typename?: 'Mutation', upsertLevelRole?: { __typename?: 'UpsertLevelRolePayload', levelRole?: { __typename?: 'LevelRole', guildId: string, roleId: string, addLevel?: string | null, removeLevel?: string | null } | null } | null };

export type BulkDeleteModLogMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  startCaseId: Scalars['BigInt'];
  endCaseId: Scalars['BigInt'];
}>;


export type BulkDeleteModLogMutation = { __typename?: 'Mutation', bulkDeleteModLog?: { __typename?: 'BulkDeleteModLogPayload', modLogs?: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> | null } | null };

export type BulkUpdateModLogReasonMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  startCaseId: Scalars['BigInt'];
  endCaseId: Scalars['BigInt'];
  executorId: Scalars['BigInt'];
  reason: Scalars['String'];
  onlyEmptyReason: Scalars['Boolean'];
}>;


export type BulkUpdateModLogReasonMutation = { __typename?: 'Mutation', bulkUpdateModLogReason?: { __typename?: 'BulkUpdateModLogReasonPayload', modLogs?: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> | null } | null };

export type CreateModLogMutationVariables = Exact<{
  modLog: ModLogInput;
}>;


export type CreateModLogMutation = { __typename?: 'Mutation', createModLog?: { __typename?: 'CreateModLogPayload', modLog?: { __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string } | null } | null };

export type DeleteModLogMutationVariables = Exact<{
  caseId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
}>;


export type DeleteModLogMutation = { __typename?: 'Mutation', deleteModLogByGuildIdAndCaseId?: { __typename?: 'DeleteModLogPayload', modLog?: { __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string } | null } | null };

export type GetModLogQueryVariables = Exact<{
  caseId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
}>;


export type GetModLogQuery = { __typename?: 'Query', modLogByGuildIdAndCaseId?: { __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string } | null };

export type GetRecentModLogsQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetRecentModLogsQuery = { __typename?: 'Query', allModLogs?: { __typename?: 'ModLogsConnection', nodes: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> } | null };

export type GetModLogsInRangeQueryVariables = Exact<{
  greaterThanOrEqualTo: Scalars['BigInt'];
  lessThanOrEqualTo: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
}>;


export type GetModLogsInRangeQuery = { __typename?: 'Query', allModLogs?: { __typename?: 'ModLogsConnection', nodes: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> } | null };

export type GetNextCaseIdQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetNextCaseIdQuery = { __typename?: 'Query', nextCaseId?: string | null };

export type GetPendingModLogQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  action: Scalars['String'];
}>;


export type GetPendingModLogQuery = { __typename?: 'Query', allModLogs?: { __typename?: 'ModLogsConnection', nodes: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> } | null };

export type GetUserModLogHistoryQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
}>;


export type GetUserModLogHistoryQuery = { __typename?: 'Query', allModLogs?: { __typename?: 'ModLogsConnection', totalCount: number, nodes: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> } | null };

export type ModLogDataFragment = { __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string };

export type SearchModLogsQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  searchCaseId: Scalars['BigInt'];
}>;


export type SearchModLogsQuery = { __typename?: 'Query', searchModLogs?: { __typename?: 'ModLogsConnection', nodes: Array<{ __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string }> } | null };

export type UpdateModLogMutationVariables = Exact<{
  caseId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
  modLogPatch: ModLogPatch;
}>;


export type UpdateModLogMutation = { __typename?: 'Mutation', updateModLogByGuildIdAndCaseId?: { __typename?: 'UpdateModLogPayload', modLog?: { __typename?: 'ModLog', action: string, actionTime: string, attachments: Array<string | null>, caseId: string, executorId?: string | null, guildId: string, msgId?: string | null, pending: boolean, reason?: string | null, userId: string, userTag: string } | null } | null };

export type DeleteMessagesBeforeMutationVariables = Exact<{
  before: Scalars['Datetime'];
}>;


export type DeleteMessagesBeforeMutation = { __typename?: 'Mutation', deleteMessagesBefore?: { __typename?: 'DeleteMessagesBeforePayload', bigInt?: string | null } | null };

export type GetMessagesQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  in: Array<Scalars['BigInt']> | Scalars['BigInt'];
}>;


export type GetMessagesQuery = { __typename?: 'Query', allMessages?: { __typename?: 'MessagesConnection', nodes: Array<{ __typename?: 'Message', guildId: string, channelId: string, authorId: string, messageId: string, content: string, msg: { [key: string]: any }, created: string, nodeId: string }> } | null };

export type MessageDataFragment = { __typename?: 'Message', guildId: string, channelId: string, authorId: string, messageId: string, content: string, msg: { [key: string]: any }, created: string, nodeId: string };

export type UpsertMessageMutationVariables = Exact<{
  message: MessageInput;
}>;


export type UpsertMessageMutation = { __typename?: 'Mutation', upsertMessage?: { __typename?: 'UpsertMessagePayload', message?: { __typename?: 'Message', guildId: string, channelId: string, authorId: string, messageId: string, content: string, msg: { [key: string]: any }, created: string, nodeId: string } | null } | null };

export type MsgLogBlockDataFragment = { __typename?: 'MsgLogBlock', guildId: string, channelId: string, blockType: MsgLogBlockType };

export type DeleteMsgLogBlockMutationVariables = Exact<{
  channelId: Scalars['BigInt'];
  guildId: Scalars['BigInt'];
}>;


export type DeleteMsgLogBlockMutation = { __typename?: 'Mutation', deleteMsgLogBlockByGuildIdAndChannelId?: { __typename?: 'DeleteMsgLogBlockPayload', msgLogBlock?: { __typename?: 'MsgLogBlock', guildId: string, channelId: string, blockType: MsgLogBlockType } | null } | null };

export type GetMsgLogBlockQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
}>;


export type GetMsgLogBlockQuery = { __typename?: 'Query', msgLogBlockByGuildIdAndChannelId?: { __typename?: 'MsgLogBlock', guildId: string, channelId: string, blockType: MsgLogBlockType } | null };

export type GetMsgLogBlocksQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetMsgLogBlocksQuery = { __typename?: 'Query', allMsgLogBlocks?: { __typename?: 'MsgLogBlocksConnection', nodes: Array<{ __typename?: 'MsgLogBlock', guildId: string, channelId: string, blockType: MsgLogBlockType }> } | null };

export type UpsertMsgLogBlockMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  blockType: MsgLogBlockType;
}>;


export type UpsertMsgLogBlockMutation = { __typename?: 'Mutation', upsertMsgLogBlock?: { __typename?: 'UpsertMsgLogBlockPayload', msgLogBlock?: { __typename?: 'MsgLogBlock', guildId: string, channelId: string, blockType: MsgLogBlockType } | null } | null };

export type CreateNotificationMutationVariables = Exact<{
  notification: NotificationInput;
}>;


export type CreateNotificationMutation = { __typename?: 'Mutation', createNotification?: { __typename?: 'CreateNotificationPayload', notification?: { __typename?: 'Notification', guildId: string, keyword: string, nodeId: string, userId: string } | null } | null };

export type DeleteNotificationMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  keyword: Scalars['String'];
}>;


export type DeleteNotificationMutation = { __typename?: 'Mutation', deleteNotificationByUserIdAndGuildIdAndKeyword?: { __typename?: 'DeleteNotificationPayload', notification?: { __typename?: 'Notification', guildId: string, keyword: string, nodeId: string, userId: string } | null } | null };

export type GetUserNotificationsQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
}>;


export type GetUserNotificationsQuery = { __typename?: 'Query', allNotifications?: { __typename?: 'NotificationsConnection', nodes: Array<{ __typename?: 'Notification', guildId: string, keyword: string, nodeId: string, userId: string }> } | null };

export type NotificationDataFragment = { __typename?: 'Notification', guildId: string, keyword: string, nodeId: string, userId: string };

export type SearchNotificationsStartingWithQueryVariables = Exact<{
  userId: Scalars['BigInt'];
  query: Scalars['String'];
}>;


export type SearchNotificationsStartingWithQuery = { __typename?: 'Query', notificationsStartingWith?: { __typename?: 'NotificationsStartingWithConnection', nodes: Array<string | null>, totalCount: number } | null };

export type CreateReminderMutationVariables = Exact<{
  reminder: ReminderInput;
}>;


export type CreateReminderMutation = { __typename?: 'Mutation', createReminder?: { __typename?: 'CreateReminderPayload', reminder?: { __typename?: 'Reminder', userId: string, description: string, expireAt: string, setAt: string } | null } | null };

export type DeleteReminderMutationVariables = Exact<{
  userId: Scalars['BigInt'];
  setAt: Scalars['Datetime'];
}>;


export type DeleteReminderMutation = { __typename?: 'Mutation', deleteReminderByUserIdAndSetAt?: { __typename?: 'DeleteReminderPayload', reminder?: { __typename?: 'Reminder', userId: string, description: string, expireAt: string, setAt: string } | null } | null };

export type GetUserRemindersQueryVariables = Exact<{
  userId: Scalars['BigInt'];
}>;


export type GetUserRemindersQuery = { __typename?: 'Query', allReminders?: { __typename?: 'RemindersConnection', totalCount: number, nodes: Array<{ __typename?: 'Reminder', userId: string, description: string, expireAt: string, setAt: string }> } | null };

export type ReminderDataFragment = { __typename?: 'Reminder', userId: string, description: string, expireAt: string, setAt: string };

export type AddRoleMenuRolesMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleIds: Array<InputMaybe<Scalars['BigInt']>> | InputMaybe<Scalars['BigInt']>;
}>;


export type AddRoleMenuRolesMutation = { __typename?: 'Mutation', addRoleMenuRoles?: { __typename?: 'AddRoleMenuRolesPayload', roleMenuRoles?: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> | null } | null };

export type CreateRoleMenuMutationVariables = Exact<{
  roleMenu: RoleMenuInput;
}>;


export type CreateRoleMenuMutation = { __typename?: 'Mutation', createRoleMenu?: { __typename?: 'CreateRoleMenuPayload', roleMenu?: { __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } } | null } | null };

export type DeleteRoleMenuMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
}>;


export type DeleteRoleMenuMutation = { __typename?: 'Mutation', deleteRoleMenuByGuildIdAndMenuName?: { __typename?: 'DeleteRoleMenuPayload', roleMenu?: { __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } } | null } | null };

export type DeleteRoleMenuRolesMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleIds: Array<InputMaybe<Scalars['BigInt']>> | InputMaybe<Scalars['BigInt']>;
}>;


export type DeleteRoleMenuRolesMutation = { __typename?: 'Mutation', deleteRoleMenuRoles?: { __typename?: 'DeleteRoleMenuRolesPayload', roleMenuRoles?: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> | null } | null };

export type GetRoleMenuQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
}>;


export type GetRoleMenuQuery = { __typename?: 'Query', roleMenuByGuildIdAndMenuName?: { __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } } | null };

export type ListRoleMenusQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type ListRoleMenusQuery = { __typename?: 'Query', allRoleMenus?: { __typename?: 'RoleMenusConnection', totalCount: number, nodes: Array<{ __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } }> } | null };

export type RoleMenuDataFragment = { __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } };

export type RoleMenuRoleDataFragment = { __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null };

export type SearchRoleMenuStartingWithQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuNameStartsWith: Scalars['String'];
}>;


export type SearchRoleMenuStartingWithQuery = { __typename?: 'Query', allRoleMenus?: { __typename?: 'RoleMenusConnection', totalCount: number, nodes: Array<{ __typename?: 'RoleMenu', menuName: string }> } | null };

export type SetRoleMenuRoleOrderMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleIds: Array<InputMaybe<Scalars['BigInt']>> | InputMaybe<Scalars['BigInt']>;
}>;


export type SetRoleMenuRoleOrderMutation = { __typename?: 'Mutation', setRoleMenuRoleOrder?: { __typename?: 'SetRoleMenuRoleOrderPayload', roleMenuRoles?: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> | null } | null };

export type UpdateRoleMenuMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleMenuPatch: RoleMenuPatch;
}>;


export type UpdateRoleMenuMutation = { __typename?: 'Mutation', updateRoleMenuByGuildIdAndMenuName?: { __typename?: 'UpdateRoleMenuPayload', roleMenu?: { __typename?: 'RoleMenu', guildId: string, menuName: string, description?: string | null, maxCount?: number | null, requiredRole?: string | null, roleMenuRolesByGuildIdAndMenuName: { __typename?: 'RoleMenuRolesConnection', nodes: Array<{ __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null }> } } | null } | null };

export type UpsertRoleMenuRoleMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  menuName: Scalars['String'];
  roleId: Scalars['BigInt'];
  emoji?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
}>;


export type UpsertRoleMenuRoleMutation = { __typename?: 'Mutation', upsertRoleMenuRole?: { __typename?: 'UpsertRoleMenuRolePayload', roleMenuRole?: { __typename?: 'RoleMenuRole', guildId: string, menuName: string, roleId: string, emoji?: string | null, description?: string | null, position?: number | null } | null } | null };

export type CreateTagMutationVariables = Exact<{
  tag: TagInput;
}>;


export type CreateTagMutation = { __typename?: 'Mutation', createTag?: { __typename?: 'CreateTagPayload', tag?: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } | null } | null };

export type DeleteTagMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
}>;


export type DeleteTagMutation = { __typename?: 'Mutation', deleteTagByGuildIdAndTagName?: { __typename?: 'DeleteTagPayload', tag?: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } | null } | null };

export type GetRandomTagQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  ownerId?: InputMaybe<Scalars['BigInt']>;
  query?: InputMaybe<Scalars['String']>;
  startsWith?: InputMaybe<Scalars['Boolean']>;
}>;


export type GetRandomTagQuery = { __typename?: 'Query', randomTag?: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } | null };

export type GetTagQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
}>;


export type GetTagQuery = { __typename?: 'Query', tagByGuildIdAndTagName?: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } | null };

export type ListGuildTagsQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type ListGuildTagsQuery = { __typename?: 'Query', allTags?: { __typename?: 'TagsConnection', totalCount: number, edges: Array<{ __typename?: 'TagsEdge', cursor?: any | null, node: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } }>, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null, hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null } } | null };

export type SearchTagsQueryVariables = Exact<{
  guildId?: InputMaybe<Scalars['BigInt']>;
  ownerId?: InputMaybe<Scalars['BigInt']>;
  filter?: InputMaybe<TagFilter>;
}>;


export type SearchTagsQuery = { __typename?: 'Query', allTags?: { __typename?: 'TagsConnection', totalCount: number, edges: Array<{ __typename?: 'TagsEdge', node: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } }> } | null };

export type TagDataFragment = { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string };

export type UpdateTagMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  tagName: Scalars['String'];
  tagPatch: TagPatch;
}>;


export type UpdateTagMutation = { __typename?: 'Mutation', updateTagByGuildIdAndTagName?: { __typename?: 'UpdateTagPayload', tag?: { __typename?: 'Tag', content: string, attachment?: string | null, created: string, guildId: string, tagName: string, ownerId: string, useCount: string } | null } | null };

export type CreateUserMutationVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type CreateUserMutation = { __typename?: 'Mutation', createUser?: { __typename?: 'CreateUserPayload', user?: { __typename?: 'User', id: string, isPatron: boolean, rep: string, lastRep?: string | null, fishies: string, lastFishies?: string | null, lastfmUsername?: string | null, patronEmoji?: string | null, profileData?: { [key: string]: any } | null } | null } | null };

export type UserByIdQueryVariables = Exact<{
  id: Scalars['BigInt'];
}>;


export type UserByIdQuery = { __typename?: 'Query', userById?: { __typename?: 'User', id: string, isPatron: boolean, rep: string, lastRep?: string | null, fishies: string, lastFishies?: string | null, lastfmUsername?: string | null, patronEmoji?: string | null, profileData?: { [key: string]: any } | null } | null };

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['BigInt'];
  userPatch: UserPatch;
}>;


export type UpdateUserMutation = { __typename?: 'Mutation', updateUserById?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', id: string, isPatron: boolean, rep: string, lastRep?: string | null, fishies: string, lastFishies?: string | null, lastfmUsername?: string | null, patronEmoji?: string | null, profileData?: { [key: string]: any } | null } | null } | null };

export type UserDataFragment = { __typename?: 'User', id: string, isPatron: boolean, rep: string, lastRep?: string | null, fishies: string, lastFishies?: string | null, lastfmUsername?: string | null, patronEmoji?: string | null, profileData?: { [key: string]: any } | null };

export type UserGlobalLevelQueryVariables = Exact<{
  userId: Scalars['BigInt'];
}>;


export type UserGlobalLevelQuery = { __typename?: 'Query', allUserLevels?: { __typename?: 'UserLevelsConnection', aggregates?: { __typename?: 'UserLevelAggregates', sum?: { __typename?: 'UserLevelSumAggregates', msgAllTime: any, msgDay: any, msgMonth: any, msgWeek: any } | null } | null, nodes: Array<{ __typename?: 'UserLevel', lastMsg: string }> } | null };

export type UserGuildLevelAndRankQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
}>;


export type UserGuildLevelAndRankQuery = { __typename?: 'Query', userGuildRank?: { __typename?: 'UserGuildRankResult', lastMsg?: string | null, guildId?: string | null, msgAllTime?: string | null, msgAllTimeRank?: string | null, msgDay?: string | null, msgWeekRank?: string | null, msgWeekTotal?: string | null, msgWeek?: string | null, msgMonthTotal?: string | null, msgMonthRank?: string | null, msgMonth?: string | null, msgDayTotal?: string | null, msgDayRank?: string | null, msgAllTimeTotal?: string | null } | null };

export type AddXpBlockMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  blockId: Scalars['BigInt'];
  blockType: BlockType;
}>;


export type AddXpBlockMutation = { __typename?: 'Mutation', createXpBlock?: { __typename?: 'CreateXpBlockPayload', xpBlock?: { __typename?: 'XpBlock', guildId: string, blockId: string, blockType: BlockType } | null } | null };

export type DeleteXpBlockMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  blockId: Scalars['BigInt'];
}>;


export type DeleteXpBlockMutation = { __typename?: 'Mutation', deleteXpBlockByGuildIdAndBlockId?: { __typename?: 'DeleteXpBlockPayload', xpBlock?: { __typename?: 'XpBlock', guildId: string, blockId: string, blockType: BlockType } | null } | null };

export type GetXpBlocksQueryVariables = Exact<{
  guildId: Scalars['BigInt'];
}>;


export type GetXpBlocksQuery = { __typename?: 'Query', allXpBlocks?: { __typename?: 'XpBlocksConnection', nodes: Array<{ __typename?: 'XpBlock', guildId: string, blockId: string, blockType: BlockType }> } | null };

export type UpdateUserXpMutationVariables = Exact<{
  guildId: Scalars['BigInt'];
  channelId: Scalars['BigInt'];
  userId: Scalars['BigInt'];
  roleIds: Array<Scalars['BigInt']> | Scalars['BigInt'];
}>;


export type UpdateUserXpMutation = { __typename?: 'Mutation', updateUserXp?: { __typename?: 'UpdateUserXpPayload', userXpUpdateResult?: { __typename?: 'UserXpUpdateResult', addRoleIds?: Array<string | null> | null, newLevel?: string | null, oldLevel?: string | null, removeRoleIds?: Array<string | null> | null } | null } | null };

export type XpBlockDataFragment = { __typename?: 'XpBlock', guildId: string, blockId: string, blockType: BlockType };

export const BanDataFragmentDoc = gql`
    fragment BanData on GuildBan {
  guildId
  nodeId
  userId
}
    `;
export const GuildConfigDataFragmentDoc = gql`
    fragment GuildConfigData on GuildConfig {
  disabledChannels
  inviteGuard
  joinMsg
  joinMsgEnabled
  joinReact
  leaveMsg
  leaveMsgEnabled
  logMember
  logMemberEnabled
  logModEnabled
  logMod
  logMsg
  logMsgEnabled
  maxMention
  msgChannel
  muteDmEnabled
  muteDmText
  muteDuration
  muteRole
  prefix
  roleChannel
  roleConfig
  roleEnabled
  warnDmEnabled
  warnDmText
}
    `;
export const LevelRoleApplyJobDataFragmentDoc = gql`
    fragment LevelRoleApplyJobData on LevelRoleApplyJob {
  guildId
  interactionId
  notifyUserId
  channelId
  messageId
  requestsProcessed
  requestsTotal
  membersTotal
  membersSkipped
  membersApplied
  membersNotFound
  membersTotalProcessed
  createdAt
  updatedAt
}
    `;
export const LevelRoleDataFragmentDoc = gql`
    fragment LevelRoleData on LevelRole {
  guildId
  roleId
  addLevel
  removeLevel
}
    `;
export const ModLogDataFragmentDoc = gql`
    fragment ModLogData on ModLog {
  action
  actionTime
  attachments
  caseId
  executorId
  guildId
  msgId
  pending
  reason
  userId
  userTag
}
    `;
export const MessageDataFragmentDoc = gql`
    fragment MessageData on Message {
  guildId
  channelId
  authorId
  messageId
  content
  msg
  created
  nodeId
}
    `;
export const MsgLogBlockDataFragmentDoc = gql`
    fragment MsgLogBlockData on MsgLogBlock {
  guildId
  channelId
  blockType
}
    `;
export const NotificationDataFragmentDoc = gql`
    fragment NotificationData on Notification {
  guildId
  keyword
  nodeId
  userId
}
    `;
export const ReminderDataFragmentDoc = gql`
    fragment ReminderData on Reminder {
  userId
  description
  expireAt
  setAt
}
    `;
export const RoleMenuRoleDataFragmentDoc = gql`
    fragment RoleMenuRoleData on RoleMenuRole {
  guildId
  menuName
  roleId
  emoji
  description
  position
}
    `;
export const RoleMenuDataFragmentDoc = gql`
    fragment RoleMenuData on RoleMenu {
  guildId
  menuName
  description
  maxCount
  requiredRole
  roleMenuRolesByGuildIdAndMenuName {
    nodes {
      ...RoleMenuRoleData
    }
  }
}
    ${RoleMenuRoleDataFragmentDoc}`;
export const TagDataFragmentDoc = gql`
    fragment TagData on Tag {
  content
  attachment
  created
  guildId
  tagName
  ownerId
  useCount
}
    `;
export const UserDataFragmentDoc = gql`
    fragment UserData on User {
  id
  isPatron
  rep
  lastRep
  fishies
  lastFishies
  lastfmUsername
  patronEmoji
  profileData
}
    `;
export const XpBlockDataFragmentDoc = gql`
    fragment XpBlockData on XpBlock {
  guildId
  blockId
  blockType
}
    `;
export const GetUserBansDocument = gql`
    query getUserBans($userId: BigInt!) {
  allGuildBans(condition: {userId: $userId}) {
    nodes {
      ...BanData
    }
    totalCount
  }
}
    ${BanDataFragmentDoc}`;
export const GetRedisGuildDocument = gql`
    query getRedisGuild($guild_id: BigInt!) {
  redisGuildByGuildId(guild_id: $guild_id) {
    afkChannelId
    afkTimeout
    applicationId
    banner
    channels
    defaultMessageNotifications
    description
    discoverySplash
    explicitContentFilter
    features
    icon
    id
    joinedAt
    large
    maxMembers
    maxVideoChannelUsers
    memberCount
    members
    mfaLevel
    name
    nsfwLevel
    ownerId
    preferredLocale
    premiumSubscriptionCount
    premiumTier
    presences
    roles {
      id
      color
      hoist
      icon
      managed
      mentionable
      position
      name
      permissions
      unicode_emoji
    }
    rulesChannelId
    splash
    systemChannelFlags
    systemChannelId
    unavailable
    vanityUrlCode
    verificationLevel
    voiceStates
  }
}
    `;
export const GuildConfigByIdDocument = gql`
    query guildConfigByID($guildId: BigInt!) {
  guildConfigById(id: $guildId) {
    ...GuildConfigData
  }
}
    ${GuildConfigDataFragmentDoc}`;
export const UpdateGuildConfigDocument = gql`
    mutation updateGuildConfig($id: BigInt!, $patch: GuildConfigPatch!) {
  updateGuildConfigById(input: {guildConfigPatch: $patch, id: $id}) {
    guildConfig {
      ...GuildConfigData
    }
  }
}
    ${GuildConfigDataFragmentDoc}`;
export const CreateLevelRoleApplyJobDocument = gql`
    mutation createLevelRoleApplyJob($guildId: BigInt!, $interactionId: BigInt!, $notifyUserId: BigInt!, $channelId: BigInt!, $messageId: BigInt!, $requestsTotal: BigInt!, $membersTotal: BigInt!) {
  createLevelRoleApplyJob(
    input: {levelRoleApplyJob: {guildId: $guildId, interactionId: $interactionId, notifyUserId: $notifyUserId, channelId: $channelId, messageId: $messageId, requestsTotal: $requestsTotal, membersTotal: $membersTotal}}
  ) {
    levelRoleApplyJob {
      ...LevelRoleApplyJobData
    }
  }
}
    ${LevelRoleApplyJobDataFragmentDoc}`;
export const DeleteLevelRoleApplyJobDocument = gql`
    mutation deleteLevelRoleApplyJob($guildId: BigInt!) {
  deleteLevelRoleApplyJobByGuildId(input: {guildId: $guildId}) {
    levelRoleApplyJob {
      ...LevelRoleApplyJobData
    }
  }
}
    ${LevelRoleApplyJobDataFragmentDoc}`;
export const GetLevelRoleApplyJobByGuildIdDocument = gql`
    query getLevelRoleApplyJobByGuildId($guildId: BigInt!) {
  levelRoleApplyJobByGuildId(guildId: $guildId) {
    ...LevelRoleApplyJobData
  }
}
    ${LevelRoleApplyJobDataFragmentDoc}`;
export const UpdateLevelRoleApplyJobDocument = gql`
    mutation updateLevelRoleApplyJob($guildId: BigInt!, $levelRoleApplyJobPatch: LevelRoleApplyJobPatch!) {
  updateLevelRoleApplyJobByGuildId(
    input: {levelRoleApplyJobPatch: $levelRoleApplyJobPatch, guildId: $guildId}
  ) {
    levelRoleApplyJob {
      ...LevelRoleApplyJobData
    }
  }
}
    ${LevelRoleApplyJobDataFragmentDoc}`;
export const DeleteLevelRoleDocument = gql`
    mutation deleteLevelRole($guildId: BigInt!, $roleId: BigInt!) {
  deleteLevelRoleByGuildIdAndRoleId(input: {guildId: $guildId, roleId: $roleId}) {
    levelRole {
      ...LevelRoleData
    }
  }
}
    ${LevelRoleDataFragmentDoc}`;
export const GetEligibleLevelRolesDocument = gql`
    query getEligibleLevelRoles($guildId: BigInt!, $userIds: [BigInt!]) {
  getEligibleLevelRoles(guildId: $guildId, userIds: $userIds) {
    nodes {
      roleIds
      userId
    }
  }
}
    `;
export const GetLevelRoleDocument = gql`
    query getLevelRole($guildId: BigInt!, $roleId: BigInt!) {
  levelRoleByGuildIdAndRoleId(guildId: $guildId, roleId: $roleId) {
    ...LevelRoleData
  }
}
    ${LevelRoleDataFragmentDoc}`;
export const GetLevelRolesDocument = gql`
    query getLevelRoles($guildId: BigInt!) {
  allLevelRoles(condition: {guildId: $guildId}) {
    nodes {
      ...LevelRoleData
    }
  }
}
    ${LevelRoleDataFragmentDoc}`;
export const UpsertLevelRoleDocument = gql`
    mutation upsertLevelRole($guildId: BigInt!, $roleId: BigInt!, $removeLevel: BigInt, $addLevel: BigInt) {
  upsertLevelRole(
    input: {levelRole: {guildId: $guildId, roleId: $roleId, addLevel: $addLevel, removeLevel: $removeLevel}}
  ) {
    levelRole {
      ...LevelRoleData
    }
  }
}
    ${LevelRoleDataFragmentDoc}`;
export const BulkDeleteModLogDocument = gql`
    mutation bulkDeleteModLog($guildId: BigInt!, $startCaseId: BigInt!, $endCaseId: BigInt!) {
  bulkDeleteModLog(
    input: {guildId: $guildId, startCaseId: $startCaseId, endCaseId: $endCaseId}
  ) {
    modLogs {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const BulkUpdateModLogReasonDocument = gql`
    mutation bulkUpdateModLogReason($guildId: BigInt!, $startCaseId: BigInt!, $endCaseId: BigInt!, $executorId: BigInt!, $reason: String!, $onlyEmptyReason: Boolean!) {
  bulkUpdateModLogReason(
    input: {guildId: $guildId, startCaseId: $startCaseId, endCaseId: $endCaseId, executorId: $executorId, reason: $reason, onlyEmptyReason: $onlyEmptyReason}
  ) {
    modLogs {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const CreateModLogDocument = gql`
    mutation createModLog($modLog: ModLogInput!) {
  createModLog(input: {modLog: $modLog}) {
    modLog {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const DeleteModLogDocument = gql`
    mutation deleteModLog($caseId: BigInt!, $guildId: BigInt!) {
  deleteModLogByGuildIdAndCaseId(input: {guildId: $guildId, caseId: $caseId}) {
    modLog {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const GetModLogDocument = gql`
    query getModLog($caseId: BigInt!, $guildId: BigInt!) {
  modLogByGuildIdAndCaseId(caseId: $caseId, guildId: $guildId) {
    ...ModLogData
  }
}
    ${ModLogDataFragmentDoc}`;
export const GetRecentModLogsDocument = gql`
    query getRecentModLogs($guildId: BigInt!) {
  allModLogs(
    condition: {guildId: $guildId, pending: false}
    first: 25
    orderBy: CASE_ID_DESC
  ) {
    nodes {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const GetModLogsInRangeDocument = gql`
    query getModLogsInRange($greaterThanOrEqualTo: BigInt!, $lessThanOrEqualTo: BigInt!, $guildId: BigInt!) {
  allModLogs(
    orderBy: CASE_ID_DESC
    condition: {guildId: $guildId, pending: false}
    filter: {caseId: {greaterThanOrEqualTo: $greaterThanOrEqualTo, lessThanOrEqualTo: $lessThanOrEqualTo}}
  ) {
    nodes {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const GetNextCaseIdDocument = gql`
    query getNextCaseID($guildId: BigInt!) {
  nextCaseId(guildId: $guildId)
}
    `;
export const GetPendingModLogDocument = gql`
    query getPendingModLog($guildId: BigInt!, $userId: BigInt!, $action: String!) {
  allModLogs(
    condition: {guildId: $guildId, userId: $userId, pending: true, action: $action}
    orderBy: ACTION_TIME_DESC
  ) {
    nodes {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const GetUserModLogHistoryDocument = gql`
    query getUserModLogHistory($guildId: BigInt!, $userId: BigInt!) {
  allModLogs(condition: {guildId: $guildId, userId: $userId}) {
    nodes {
      ...ModLogData
    }
    totalCount
  }
}
    ${ModLogDataFragmentDoc}`;
export const SearchModLogsDocument = gql`
    query searchModLogs($guildId: BigInt!, $searchCaseId: BigInt!) {
  searchModLogs(guildId: $guildId, searchCaseId: $searchCaseId, maxResults: 25) {
    nodes {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const UpdateModLogDocument = gql`
    mutation updateModLog($caseId: BigInt!, $guildId: BigInt!, $modLogPatch: ModLogPatch!) {
  updateModLogByGuildIdAndCaseId(
    input: {modLogPatch: $modLogPatch, guildId: $guildId, caseId: $caseId}
  ) {
    modLog {
      ...ModLogData
    }
  }
}
    ${ModLogDataFragmentDoc}`;
export const DeleteMessagesBeforeDocument = gql`
    mutation deleteMessagesBefore($before: Datetime!) {
  deleteMessagesBefore(input: {before: $before}) {
    bigInt
  }
}
    `;
export const GetMessagesDocument = gql`
    query getMessages($guildId: BigInt!, $channelId: BigInt!, $in: [BigInt!]!) {
  allMessages(
    condition: {guildId: $guildId, channelId: $channelId}
    orderBy: CREATED_DESC
    filter: {messageId: {in: $in}}
  ) {
    nodes {
      ...MessageData
    }
  }
}
    ${MessageDataFragmentDoc}`;
export const UpsertMessageDocument = gql`
    mutation upsertMessage($message: MessageInput!) {
  upsertMessage(input: {message: $message}) {
    message {
      ...MessageData
    }
  }
}
    ${MessageDataFragmentDoc}`;
export const DeleteMsgLogBlockDocument = gql`
    mutation deleteMsgLogBlock($channelId: BigInt!, $guildId: BigInt!) {
  deleteMsgLogBlockByGuildIdAndChannelId(
    input: {guildId: $guildId, channelId: $channelId}
  ) {
    msgLogBlock {
      ...MsgLogBlockData
    }
  }
}
    ${MsgLogBlockDataFragmentDoc}`;
export const GetMsgLogBlockDocument = gql`
    query getMsgLogBlock($guildId: BigInt!, $channelId: BigInt!) {
  msgLogBlockByGuildIdAndChannelId(guildId: $guildId, channelId: $channelId) {
    ...MsgLogBlockData
  }
}
    ${MsgLogBlockDataFragmentDoc}`;
export const GetMsgLogBlocksDocument = gql`
    query getMsgLogBlocks($guildId: BigInt!) {
  allMsgLogBlocks(condition: {guildId: $guildId}) {
    nodes {
      ...MsgLogBlockData
    }
  }
}
    ${MsgLogBlockDataFragmentDoc}`;
export const UpsertMsgLogBlockDocument = gql`
    mutation upsertMsgLogBlock($guildId: BigInt!, $channelId: BigInt!, $blockType: MsgLogBlockType!) {
  upsertMsgLogBlock(
    input: {msgLogBlock: {guildId: $guildId, channelId: $channelId, blockType: $blockType}}
  ) {
    msgLogBlock {
      ...MsgLogBlockData
    }
  }
}
    ${MsgLogBlockDataFragmentDoc}`;
export const CreateNotificationDocument = gql`
    mutation createNotification($notification: NotificationInput!) {
  createNotification(input: {notification: $notification}) {
    notification {
      ...NotificationData
    }
  }
}
    ${NotificationDataFragmentDoc}`;
export const DeleteNotificationDocument = gql`
    mutation deleteNotification($guildId: BigInt!, $userId: BigInt!, $keyword: String!) {
  deleteNotificationByUserIdAndGuildIdAndKeyword(
    input: {userId: $userId, guildId: $guildId, keyword: $keyword}
  ) {
    notification {
      ...NotificationData
    }
  }
}
    ${NotificationDataFragmentDoc}`;
export const GetUserNotificationsDocument = gql`
    query getUserNotifications($guildId: BigInt!, $userId: BigInt!) {
  allNotifications(condition: {guildId: $guildId, userId: $userId}) {
    nodes {
      ...NotificationData
    }
  }
}
    ${NotificationDataFragmentDoc}`;
export const SearchNotificationsStartingWithDocument = gql`
    query searchNotificationsStartingWith($userId: BigInt!, $query: String!) {
  notificationsStartingWith(userId: $userId, query: $query) {
    nodes
    totalCount
  }
}
    `;
export const CreateReminderDocument = gql`
    mutation createReminder($reminder: ReminderInput!) {
  createReminder(input: {reminder: $reminder}) {
    reminder {
      ...ReminderData
    }
  }
}
    ${ReminderDataFragmentDoc}`;
export const DeleteReminderDocument = gql`
    mutation deleteReminder($userId: BigInt!, $setAt: Datetime!) {
  deleteReminderByUserIdAndSetAt(input: {setAt: $setAt, userId: $userId}) {
    reminder {
      ...ReminderData
    }
  }
}
    ${ReminderDataFragmentDoc}`;
export const GetUserRemindersDocument = gql`
    query getUserReminders($userId: BigInt!) {
  allReminders(condition: {userId: $userId}) {
    nodes {
      ...ReminderData
    }
    totalCount
  }
}
    ${ReminderDataFragmentDoc}`;
export const AddRoleMenuRolesDocument = gql`
    mutation addRoleMenuRoles($guildId: BigInt!, $menuName: String!, $roleIds: [BigInt]!) {
  addRoleMenuRoles(
    input: {guildId: $guildId, menuName: $menuName, roleIds: $roleIds}
  ) {
    roleMenuRoles {
      ...RoleMenuRoleData
    }
  }
}
    ${RoleMenuRoleDataFragmentDoc}`;
export const CreateRoleMenuDocument = gql`
    mutation createRoleMenu($roleMenu: RoleMenuInput!) {
  createRoleMenu(input: {roleMenu: $roleMenu}) {
    roleMenu {
      ...RoleMenuData
    }
  }
}
    ${RoleMenuDataFragmentDoc}`;
export const DeleteRoleMenuDocument = gql`
    mutation deleteRoleMenu($guildId: BigInt!, $menuName: String!) {
  deleteRoleMenuByGuildIdAndMenuName(
    input: {guildId: $guildId, menuName: $menuName}
  ) {
    roleMenu {
      ...RoleMenuData
    }
  }
}
    ${RoleMenuDataFragmentDoc}`;
export const DeleteRoleMenuRolesDocument = gql`
    mutation deleteRoleMenuRoles($guildId: BigInt!, $menuName: String!, $roleIds: [BigInt]!) {
  deleteRoleMenuRoles(
    input: {menuName: $menuName, roleIds: $roleIds, guildId: $guildId}
  ) {
    roleMenuRoles {
      ...RoleMenuRoleData
    }
  }
}
    ${RoleMenuRoleDataFragmentDoc}`;
export const GetRoleMenuDocument = gql`
    query getRoleMenu($guildId: BigInt!, $menuName: String!) {
  roleMenuByGuildIdAndMenuName(guildId: $guildId, menuName: $menuName) {
    ...RoleMenuData
  }
}
    ${RoleMenuDataFragmentDoc}`;
export const ListRoleMenusDocument = gql`
    query listRoleMenus($guildId: BigInt!) {
  allRoleMenus(condition: {guildId: $guildId}) {
    nodes {
      ...RoleMenuData
    }
    totalCount
  }
}
    ${RoleMenuDataFragmentDoc}`;
export const SearchRoleMenuStartingWithDocument = gql`
    query searchRoleMenuStartingWith($guildId: BigInt!, $menuNameStartsWith: String!) {
  allRoleMenus(
    filter: {guildId: {equalTo: $guildId}, menuName: {startsWith: $menuNameStartsWith}}
    first: 25
  ) {
    nodes {
      menuName
    }
    totalCount
  }
}
    `;
export const SetRoleMenuRoleOrderDocument = gql`
    mutation setRoleMenuRoleOrder($guildId: BigInt!, $menuName: String!, $roleIds: [BigInt]!) {
  setRoleMenuRoleOrder(
    input: {guildId: $guildId, menuName: $menuName, roleIds: $roleIds}
  ) {
    roleMenuRoles {
      ...RoleMenuRoleData
    }
  }
}
    ${RoleMenuRoleDataFragmentDoc}`;
export const UpdateRoleMenuDocument = gql`
    mutation updateRoleMenu($guildId: BigInt!, $menuName: String!, $roleMenuPatch: RoleMenuPatch!) {
  updateRoleMenuByGuildIdAndMenuName(
    input: {guildId: $guildId, menuName: $menuName, roleMenuPatch: $roleMenuPatch}
  ) {
    roleMenu {
      ...RoleMenuData
    }
  }
}
    ${RoleMenuDataFragmentDoc}`;
export const UpsertRoleMenuRoleDocument = gql`
    mutation upsertRoleMenuRole($guildId: BigInt!, $menuName: String!, $roleId: BigInt!, $emoji: String, $description: String) {
  upsertRoleMenuRole(
    input: {roleMenuRole: {guildId: $guildId, menuName: $menuName, roleId: $roleId, emoji: $emoji, description: $description}}
    where: {guildId: $guildId, menuName: $menuName, roleId: $roleId}
  ) {
    roleMenuRole {
      ...RoleMenuRoleData
    }
  }
}
    ${RoleMenuRoleDataFragmentDoc}`;
export const CreateTagDocument = gql`
    mutation createTag($tag: TagInput!) {
  createTag(input: {tag: $tag}) {
    tag {
      ...TagData
    }
  }
}
    ${TagDataFragmentDoc}`;
export const DeleteTagDocument = gql`
    mutation deleteTag($guildId: BigInt!, $tagName: String!) {
  deleteTagByGuildIdAndTagName(input: {guildId: $guildId, tagName: $tagName}) {
    tag {
      ...TagData
    }
  }
}
    ${TagDataFragmentDoc}`;
export const GetRandomTagDocument = gql`
    query getRandomTag($guildId: BigInt!, $ownerId: BigInt, $query: String, $startsWith: Boolean) {
  randomTag(
    guildId: $guildId
    query: $query
    startsWith: $startsWith
    ownerId: $ownerId
  ) {
    ...TagData
  }
}
    ${TagDataFragmentDoc}`;
export const GetTagDocument = gql`
    query getTag($guildId: BigInt!, $tagName: String!) {
  tagByGuildIdAndTagName(guildId: $guildId, tagName: $tagName) {
    ...TagData
  }
}
    ${TagDataFragmentDoc}`;
export const ListGuildTagsDocument = gql`
    query listGuildTags($guildId: BigInt!) {
  allTags(condition: {guildId: $guildId}, orderBy: TAG_NAME_ASC) {
    edges {
      node {
        ...TagData
      }
      cursor
    }
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    totalCount
  }
}
    ${TagDataFragmentDoc}`;
export const SearchTagsDocument = gql`
    query searchTags($guildId: BigInt, $ownerId: BigInt, $filter: TagFilter) {
  allTags(
    filter: $filter
    condition: {guildId: $guildId, ownerId: $ownerId}
    orderBy: TAG_NAME_ASC
  ) {
    edges {
      node {
        ...TagData
      }
    }
    totalCount
  }
}
    ${TagDataFragmentDoc}`;
export const UpdateTagDocument = gql`
    mutation updateTag($guildId: BigInt!, $tagName: String!, $tagPatch: TagPatch!) {
  updateTagByGuildIdAndTagName(
    input: {tagPatch: $tagPatch, guildId: $guildId, tagName: $tagName}
  ) {
    tag {
      ...TagData
    }
  }
}
    ${TagDataFragmentDoc}`;
export const CreateUserDocument = gql`
    mutation createUser($id: BigInt!) {
  createUser(input: {user: {id: $id, fishies: "0", isPatron: false, rep: "0"}}) {
    user {
      ...UserData
    }
  }
}
    ${UserDataFragmentDoc}`;
export const UserByIdDocument = gql`
    query userByID($id: BigInt!) {
  userById(id: $id) {
    ...UserData
  }
}
    ${UserDataFragmentDoc}`;
export const UpdateUserDocument = gql`
    mutation updateUser($id: BigInt!, $userPatch: UserPatch!) {
  updateUserById(input: {id: $id, userPatch: $userPatch}) {
    user {
      ...UserData
    }
  }
}
    ${UserDataFragmentDoc}`;
export const UserGlobalLevelDocument = gql`
    query userGlobalLevel($userId: BigInt!) {
  allUserLevels(condition: {userId: $userId}) {
    aggregates {
      sum {
        msgAllTime
        msgDay
        msgMonth
        msgWeek
      }
    }
    nodes {
      lastMsg
    }
  }
}
    `;
export const UserGuildLevelAndRankDocument = gql`
    query userGuildLevelAndRank($guildId: BigInt!, $userId: BigInt!) {
  userGuildRank(guildId: $guildId, userId: $userId) {
    lastMsg
    guildId
    msgAllTime
    msgAllTimeRank
    msgDay
    msgWeekRank
    msgWeekTotal
    msgWeek
    msgMonthTotal
    msgMonthRank
    msgMonth
    msgDayTotal
    msgDayRank
    msgAllTimeTotal
  }
}
    `;
export const AddXpBlockDocument = gql`
    mutation addXpBlock($guildId: BigInt!, $blockId: BigInt!, $blockType: BlockType!) {
  createXpBlock(
    input: {xpBlock: {guildId: $guildId, blockId: $blockId, blockType: $blockType}}
  ) {
    xpBlock {
      ...XpBlockData
    }
  }
}
    ${XpBlockDataFragmentDoc}`;
export const DeleteXpBlockDocument = gql`
    mutation deleteXpBlock($guildId: BigInt!, $blockId: BigInt!) {
  deleteXpBlockByGuildIdAndBlockId(input: {guildId: $guildId, blockId: $blockId}) {
    xpBlock {
      ...XpBlockData
    }
  }
}
    ${XpBlockDataFragmentDoc}`;
export const GetXpBlocksDocument = gql`
    query getXpBlocks($guildId: BigInt!) {
  allXpBlocks(condition: {guildId: $guildId}) {
    nodes {
      ...XpBlockData
    }
  }
}
    ${XpBlockDataFragmentDoc}`;
export const UpdateUserXpDocument = gql`
    mutation updateUserXp($guildId: BigInt!, $channelId: BigInt!, $userId: BigInt!, $roleIds: [BigInt!]!) {
  updateUserXp(
    input: {channelId: $channelId, userId: $userId, guildId: $guildId, roleIds: $roleIds}
  ) {
    userXpUpdateResult {
      addRoleIds
      newLevel
      oldLevel
      removeRoleIds
    }
  }
}
    `;
export type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>
export function getSdk<C, E>(requester: Requester<C, E>) {
  return {
    getUserBans(variables: GetUserBansQueryVariables, options?: C): Promise<GetUserBansQuery> {
      return requester<GetUserBansQuery, GetUserBansQueryVariables>(GetUserBansDocument, variables, options) as Promise<GetUserBansQuery>;
    },
    getRedisGuild(variables: GetRedisGuildQueryVariables, options?: C): Promise<GetRedisGuildQuery> {
      return requester<GetRedisGuildQuery, GetRedisGuildQueryVariables>(GetRedisGuildDocument, variables, options) as Promise<GetRedisGuildQuery>;
    },
    guildConfigByID(variables: GuildConfigByIdQueryVariables, options?: C): Promise<GuildConfigByIdQuery> {
      return requester<GuildConfigByIdQuery, GuildConfigByIdQueryVariables>(GuildConfigByIdDocument, variables, options) as Promise<GuildConfigByIdQuery>;
    },
    updateGuildConfig(variables: UpdateGuildConfigMutationVariables, options?: C): Promise<UpdateGuildConfigMutation> {
      return requester<UpdateGuildConfigMutation, UpdateGuildConfigMutationVariables>(UpdateGuildConfigDocument, variables, options) as Promise<UpdateGuildConfigMutation>;
    },
    createLevelRoleApplyJob(variables: CreateLevelRoleApplyJobMutationVariables, options?: C): Promise<CreateLevelRoleApplyJobMutation> {
      return requester<CreateLevelRoleApplyJobMutation, CreateLevelRoleApplyJobMutationVariables>(CreateLevelRoleApplyJobDocument, variables, options) as Promise<CreateLevelRoleApplyJobMutation>;
    },
    deleteLevelRoleApplyJob(variables: DeleteLevelRoleApplyJobMutationVariables, options?: C): Promise<DeleteLevelRoleApplyJobMutation> {
      return requester<DeleteLevelRoleApplyJobMutation, DeleteLevelRoleApplyJobMutationVariables>(DeleteLevelRoleApplyJobDocument, variables, options) as Promise<DeleteLevelRoleApplyJobMutation>;
    },
    getLevelRoleApplyJobByGuildId(variables: GetLevelRoleApplyJobByGuildIdQueryVariables, options?: C): Promise<GetLevelRoleApplyJobByGuildIdQuery> {
      return requester<GetLevelRoleApplyJobByGuildIdQuery, GetLevelRoleApplyJobByGuildIdQueryVariables>(GetLevelRoleApplyJobByGuildIdDocument, variables, options) as Promise<GetLevelRoleApplyJobByGuildIdQuery>;
    },
    updateLevelRoleApplyJob(variables: UpdateLevelRoleApplyJobMutationVariables, options?: C): Promise<UpdateLevelRoleApplyJobMutation> {
      return requester<UpdateLevelRoleApplyJobMutation, UpdateLevelRoleApplyJobMutationVariables>(UpdateLevelRoleApplyJobDocument, variables, options) as Promise<UpdateLevelRoleApplyJobMutation>;
    },
    deleteLevelRole(variables: DeleteLevelRoleMutationVariables, options?: C): Promise<DeleteLevelRoleMutation> {
      return requester<DeleteLevelRoleMutation, DeleteLevelRoleMutationVariables>(DeleteLevelRoleDocument, variables, options) as Promise<DeleteLevelRoleMutation>;
    },
    getEligibleLevelRoles(variables: GetEligibleLevelRolesQueryVariables, options?: C): Promise<GetEligibleLevelRolesQuery> {
      return requester<GetEligibleLevelRolesQuery, GetEligibleLevelRolesQueryVariables>(GetEligibleLevelRolesDocument, variables, options) as Promise<GetEligibleLevelRolesQuery>;
    },
    getLevelRole(variables: GetLevelRoleQueryVariables, options?: C): Promise<GetLevelRoleQuery> {
      return requester<GetLevelRoleQuery, GetLevelRoleQueryVariables>(GetLevelRoleDocument, variables, options) as Promise<GetLevelRoleQuery>;
    },
    getLevelRoles(variables: GetLevelRolesQueryVariables, options?: C): Promise<GetLevelRolesQuery> {
      return requester<GetLevelRolesQuery, GetLevelRolesQueryVariables>(GetLevelRolesDocument, variables, options) as Promise<GetLevelRolesQuery>;
    },
    upsertLevelRole(variables: UpsertLevelRoleMutationVariables, options?: C): Promise<UpsertLevelRoleMutation> {
      return requester<UpsertLevelRoleMutation, UpsertLevelRoleMutationVariables>(UpsertLevelRoleDocument, variables, options) as Promise<UpsertLevelRoleMutation>;
    },
    bulkDeleteModLog(variables: BulkDeleteModLogMutationVariables, options?: C): Promise<BulkDeleteModLogMutation> {
      return requester<BulkDeleteModLogMutation, BulkDeleteModLogMutationVariables>(BulkDeleteModLogDocument, variables, options) as Promise<BulkDeleteModLogMutation>;
    },
    bulkUpdateModLogReason(variables: BulkUpdateModLogReasonMutationVariables, options?: C): Promise<BulkUpdateModLogReasonMutation> {
      return requester<BulkUpdateModLogReasonMutation, BulkUpdateModLogReasonMutationVariables>(BulkUpdateModLogReasonDocument, variables, options) as Promise<BulkUpdateModLogReasonMutation>;
    },
    createModLog(variables: CreateModLogMutationVariables, options?: C): Promise<CreateModLogMutation> {
      return requester<CreateModLogMutation, CreateModLogMutationVariables>(CreateModLogDocument, variables, options) as Promise<CreateModLogMutation>;
    },
    deleteModLog(variables: DeleteModLogMutationVariables, options?: C): Promise<DeleteModLogMutation> {
      return requester<DeleteModLogMutation, DeleteModLogMutationVariables>(DeleteModLogDocument, variables, options) as Promise<DeleteModLogMutation>;
    },
    getModLog(variables: GetModLogQueryVariables, options?: C): Promise<GetModLogQuery> {
      return requester<GetModLogQuery, GetModLogQueryVariables>(GetModLogDocument, variables, options) as Promise<GetModLogQuery>;
    },
    getRecentModLogs(variables: GetRecentModLogsQueryVariables, options?: C): Promise<GetRecentModLogsQuery> {
      return requester<GetRecentModLogsQuery, GetRecentModLogsQueryVariables>(GetRecentModLogsDocument, variables, options) as Promise<GetRecentModLogsQuery>;
    },
    getModLogsInRange(variables: GetModLogsInRangeQueryVariables, options?: C): Promise<GetModLogsInRangeQuery> {
      return requester<GetModLogsInRangeQuery, GetModLogsInRangeQueryVariables>(GetModLogsInRangeDocument, variables, options) as Promise<GetModLogsInRangeQuery>;
    },
    getNextCaseID(variables: GetNextCaseIdQueryVariables, options?: C): Promise<GetNextCaseIdQuery> {
      return requester<GetNextCaseIdQuery, GetNextCaseIdQueryVariables>(GetNextCaseIdDocument, variables, options) as Promise<GetNextCaseIdQuery>;
    },
    getPendingModLog(variables: GetPendingModLogQueryVariables, options?: C): Promise<GetPendingModLogQuery> {
      return requester<GetPendingModLogQuery, GetPendingModLogQueryVariables>(GetPendingModLogDocument, variables, options) as Promise<GetPendingModLogQuery>;
    },
    getUserModLogHistory(variables: GetUserModLogHistoryQueryVariables, options?: C): Promise<GetUserModLogHistoryQuery> {
      return requester<GetUserModLogHistoryQuery, GetUserModLogHistoryQueryVariables>(GetUserModLogHistoryDocument, variables, options) as Promise<GetUserModLogHistoryQuery>;
    },
    searchModLogs(variables: SearchModLogsQueryVariables, options?: C): Promise<SearchModLogsQuery> {
      return requester<SearchModLogsQuery, SearchModLogsQueryVariables>(SearchModLogsDocument, variables, options) as Promise<SearchModLogsQuery>;
    },
    updateModLog(variables: UpdateModLogMutationVariables, options?: C): Promise<UpdateModLogMutation> {
      return requester<UpdateModLogMutation, UpdateModLogMutationVariables>(UpdateModLogDocument, variables, options) as Promise<UpdateModLogMutation>;
    },
    deleteMessagesBefore(variables: DeleteMessagesBeforeMutationVariables, options?: C): Promise<DeleteMessagesBeforeMutation> {
      return requester<DeleteMessagesBeforeMutation, DeleteMessagesBeforeMutationVariables>(DeleteMessagesBeforeDocument, variables, options) as Promise<DeleteMessagesBeforeMutation>;
    },
    getMessages(variables: GetMessagesQueryVariables, options?: C): Promise<GetMessagesQuery> {
      return requester<GetMessagesQuery, GetMessagesQueryVariables>(GetMessagesDocument, variables, options) as Promise<GetMessagesQuery>;
    },
    upsertMessage(variables: UpsertMessageMutationVariables, options?: C): Promise<UpsertMessageMutation> {
      return requester<UpsertMessageMutation, UpsertMessageMutationVariables>(UpsertMessageDocument, variables, options) as Promise<UpsertMessageMutation>;
    },
    deleteMsgLogBlock(variables: DeleteMsgLogBlockMutationVariables, options?: C): Promise<DeleteMsgLogBlockMutation> {
      return requester<DeleteMsgLogBlockMutation, DeleteMsgLogBlockMutationVariables>(DeleteMsgLogBlockDocument, variables, options) as Promise<DeleteMsgLogBlockMutation>;
    },
    getMsgLogBlock(variables: GetMsgLogBlockQueryVariables, options?: C): Promise<GetMsgLogBlockQuery> {
      return requester<GetMsgLogBlockQuery, GetMsgLogBlockQueryVariables>(GetMsgLogBlockDocument, variables, options) as Promise<GetMsgLogBlockQuery>;
    },
    getMsgLogBlocks(variables: GetMsgLogBlocksQueryVariables, options?: C): Promise<GetMsgLogBlocksQuery> {
      return requester<GetMsgLogBlocksQuery, GetMsgLogBlocksQueryVariables>(GetMsgLogBlocksDocument, variables, options) as Promise<GetMsgLogBlocksQuery>;
    },
    upsertMsgLogBlock(variables: UpsertMsgLogBlockMutationVariables, options?: C): Promise<UpsertMsgLogBlockMutation> {
      return requester<UpsertMsgLogBlockMutation, UpsertMsgLogBlockMutationVariables>(UpsertMsgLogBlockDocument, variables, options) as Promise<UpsertMsgLogBlockMutation>;
    },
    createNotification(variables: CreateNotificationMutationVariables, options?: C): Promise<CreateNotificationMutation> {
      return requester<CreateNotificationMutation, CreateNotificationMutationVariables>(CreateNotificationDocument, variables, options) as Promise<CreateNotificationMutation>;
    },
    deleteNotification(variables: DeleteNotificationMutationVariables, options?: C): Promise<DeleteNotificationMutation> {
      return requester<DeleteNotificationMutation, DeleteNotificationMutationVariables>(DeleteNotificationDocument, variables, options) as Promise<DeleteNotificationMutation>;
    },
    getUserNotifications(variables: GetUserNotificationsQueryVariables, options?: C): Promise<GetUserNotificationsQuery> {
      return requester<GetUserNotificationsQuery, GetUserNotificationsQueryVariables>(GetUserNotificationsDocument, variables, options) as Promise<GetUserNotificationsQuery>;
    },
    searchNotificationsStartingWith(variables: SearchNotificationsStartingWithQueryVariables, options?: C): Promise<SearchNotificationsStartingWithQuery> {
      return requester<SearchNotificationsStartingWithQuery, SearchNotificationsStartingWithQueryVariables>(SearchNotificationsStartingWithDocument, variables, options) as Promise<SearchNotificationsStartingWithQuery>;
    },
    createReminder(variables: CreateReminderMutationVariables, options?: C): Promise<CreateReminderMutation> {
      return requester<CreateReminderMutation, CreateReminderMutationVariables>(CreateReminderDocument, variables, options) as Promise<CreateReminderMutation>;
    },
    deleteReminder(variables: DeleteReminderMutationVariables, options?: C): Promise<DeleteReminderMutation> {
      return requester<DeleteReminderMutation, DeleteReminderMutationVariables>(DeleteReminderDocument, variables, options) as Promise<DeleteReminderMutation>;
    },
    getUserReminders(variables: GetUserRemindersQueryVariables, options?: C): Promise<GetUserRemindersQuery> {
      return requester<GetUserRemindersQuery, GetUserRemindersQueryVariables>(GetUserRemindersDocument, variables, options) as Promise<GetUserRemindersQuery>;
    },
    addRoleMenuRoles(variables: AddRoleMenuRolesMutationVariables, options?: C): Promise<AddRoleMenuRolesMutation> {
      return requester<AddRoleMenuRolesMutation, AddRoleMenuRolesMutationVariables>(AddRoleMenuRolesDocument, variables, options) as Promise<AddRoleMenuRolesMutation>;
    },
    createRoleMenu(variables: CreateRoleMenuMutationVariables, options?: C): Promise<CreateRoleMenuMutation> {
      return requester<CreateRoleMenuMutation, CreateRoleMenuMutationVariables>(CreateRoleMenuDocument, variables, options) as Promise<CreateRoleMenuMutation>;
    },
    deleteRoleMenu(variables: DeleteRoleMenuMutationVariables, options?: C): Promise<DeleteRoleMenuMutation> {
      return requester<DeleteRoleMenuMutation, DeleteRoleMenuMutationVariables>(DeleteRoleMenuDocument, variables, options) as Promise<DeleteRoleMenuMutation>;
    },
    deleteRoleMenuRoles(variables: DeleteRoleMenuRolesMutationVariables, options?: C): Promise<DeleteRoleMenuRolesMutation> {
      return requester<DeleteRoleMenuRolesMutation, DeleteRoleMenuRolesMutationVariables>(DeleteRoleMenuRolesDocument, variables, options) as Promise<DeleteRoleMenuRolesMutation>;
    },
    getRoleMenu(variables: GetRoleMenuQueryVariables, options?: C): Promise<GetRoleMenuQuery> {
      return requester<GetRoleMenuQuery, GetRoleMenuQueryVariables>(GetRoleMenuDocument, variables, options) as Promise<GetRoleMenuQuery>;
    },
    listRoleMenus(variables: ListRoleMenusQueryVariables, options?: C): Promise<ListRoleMenusQuery> {
      return requester<ListRoleMenusQuery, ListRoleMenusQueryVariables>(ListRoleMenusDocument, variables, options) as Promise<ListRoleMenusQuery>;
    },
    searchRoleMenuStartingWith(variables: SearchRoleMenuStartingWithQueryVariables, options?: C): Promise<SearchRoleMenuStartingWithQuery> {
      return requester<SearchRoleMenuStartingWithQuery, SearchRoleMenuStartingWithQueryVariables>(SearchRoleMenuStartingWithDocument, variables, options) as Promise<SearchRoleMenuStartingWithQuery>;
    },
    setRoleMenuRoleOrder(variables: SetRoleMenuRoleOrderMutationVariables, options?: C): Promise<SetRoleMenuRoleOrderMutation> {
      return requester<SetRoleMenuRoleOrderMutation, SetRoleMenuRoleOrderMutationVariables>(SetRoleMenuRoleOrderDocument, variables, options) as Promise<SetRoleMenuRoleOrderMutation>;
    },
    updateRoleMenu(variables: UpdateRoleMenuMutationVariables, options?: C): Promise<UpdateRoleMenuMutation> {
      return requester<UpdateRoleMenuMutation, UpdateRoleMenuMutationVariables>(UpdateRoleMenuDocument, variables, options) as Promise<UpdateRoleMenuMutation>;
    },
    upsertRoleMenuRole(variables: UpsertRoleMenuRoleMutationVariables, options?: C): Promise<UpsertRoleMenuRoleMutation> {
      return requester<UpsertRoleMenuRoleMutation, UpsertRoleMenuRoleMutationVariables>(UpsertRoleMenuRoleDocument, variables, options) as Promise<UpsertRoleMenuRoleMutation>;
    },
    createTag(variables: CreateTagMutationVariables, options?: C): Promise<CreateTagMutation> {
      return requester<CreateTagMutation, CreateTagMutationVariables>(CreateTagDocument, variables, options) as Promise<CreateTagMutation>;
    },
    deleteTag(variables: DeleteTagMutationVariables, options?: C): Promise<DeleteTagMutation> {
      return requester<DeleteTagMutation, DeleteTagMutationVariables>(DeleteTagDocument, variables, options) as Promise<DeleteTagMutation>;
    },
    getRandomTag(variables: GetRandomTagQueryVariables, options?: C): Promise<GetRandomTagQuery> {
      return requester<GetRandomTagQuery, GetRandomTagQueryVariables>(GetRandomTagDocument, variables, options) as Promise<GetRandomTagQuery>;
    },
    getTag(variables: GetTagQueryVariables, options?: C): Promise<GetTagQuery> {
      return requester<GetTagQuery, GetTagQueryVariables>(GetTagDocument, variables, options) as Promise<GetTagQuery>;
    },
    listGuildTags(variables: ListGuildTagsQueryVariables, options?: C): Promise<ListGuildTagsQuery> {
      return requester<ListGuildTagsQuery, ListGuildTagsQueryVariables>(ListGuildTagsDocument, variables, options) as Promise<ListGuildTagsQuery>;
    },
    searchTags(variables?: SearchTagsQueryVariables, options?: C): Promise<SearchTagsQuery> {
      return requester<SearchTagsQuery, SearchTagsQueryVariables>(SearchTagsDocument, variables, options) as Promise<SearchTagsQuery>;
    },
    updateTag(variables: UpdateTagMutationVariables, options?: C): Promise<UpdateTagMutation> {
      return requester<UpdateTagMutation, UpdateTagMutationVariables>(UpdateTagDocument, variables, options) as Promise<UpdateTagMutation>;
    },
    createUser(variables: CreateUserMutationVariables, options?: C): Promise<CreateUserMutation> {
      return requester<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, variables, options) as Promise<CreateUserMutation>;
    },
    userByID(variables: UserByIdQueryVariables, options?: C): Promise<UserByIdQuery> {
      return requester<UserByIdQuery, UserByIdQueryVariables>(UserByIdDocument, variables, options) as Promise<UserByIdQuery>;
    },
    updateUser(variables: UpdateUserMutationVariables, options?: C): Promise<UpdateUserMutation> {
      return requester<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, variables, options) as Promise<UpdateUserMutation>;
    },
    userGlobalLevel(variables: UserGlobalLevelQueryVariables, options?: C): Promise<UserGlobalLevelQuery> {
      return requester<UserGlobalLevelQuery, UserGlobalLevelQueryVariables>(UserGlobalLevelDocument, variables, options) as Promise<UserGlobalLevelQuery>;
    },
    userGuildLevelAndRank(variables: UserGuildLevelAndRankQueryVariables, options?: C): Promise<UserGuildLevelAndRankQuery> {
      return requester<UserGuildLevelAndRankQuery, UserGuildLevelAndRankQueryVariables>(UserGuildLevelAndRankDocument, variables, options) as Promise<UserGuildLevelAndRankQuery>;
    },
    addXpBlock(variables: AddXpBlockMutationVariables, options?: C): Promise<AddXpBlockMutation> {
      return requester<AddXpBlockMutation, AddXpBlockMutationVariables>(AddXpBlockDocument, variables, options) as Promise<AddXpBlockMutation>;
    },
    deleteXpBlock(variables: DeleteXpBlockMutationVariables, options?: C): Promise<DeleteXpBlockMutation> {
      return requester<DeleteXpBlockMutation, DeleteXpBlockMutationVariables>(DeleteXpBlockDocument, variables, options) as Promise<DeleteXpBlockMutation>;
    },
    getXpBlocks(variables: GetXpBlocksQueryVariables, options?: C): Promise<GetXpBlocksQuery> {
      return requester<GetXpBlocksQuery, GetXpBlocksQueryVariables>(GetXpBlocksDocument, variables, options) as Promise<GetXpBlocksQuery>;
    },
    updateUserXp(variables: UpdateUserXpMutationVariables, options?: C): Promise<UpdateUserXpMutation> {
      return requester<UpdateUserXpMutation, UpdateUserXpMutationVariables>(UpdateUserXpDocument, variables, options) as Promise<UpdateUserXpMutation>;
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;